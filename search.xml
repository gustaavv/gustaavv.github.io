<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>算法题001：求数组可能的最大得分</title>
    <url>/2023/09/21/Algorithm-Problem-001-Calculate-Maximum-Possible-Score-of-an-Array/</url>
    <content><![CDATA[<h1 id="题目">题目</h1>
<blockquote>
<p>题目来源：牛客笔试</p>
</blockquote>
<p>给定一个从 $0$ 开始的数组 $nums$ 和一个非负整数 $k$。</p>
<p>在一次操作中，你可以做以下操作：</p>
<ul>
<li>选择一个之前未选择过的下标 $i$，范围为 $[0, nums.length - 1]$ 。</li>
<li>将 $nums[i]$ 替换为范围 $[nums[i] - k, nums[i] + k]$ 内的任意整数（包含两端）。</li>
</ul>
<p>在应用任意次数的操作后，返回数组 $nums$ 的最大可能分数。</p>
<p>数组<strong>分数</strong>是“数组中最多的重复元素个数”</p>
<p>注意，你<strong>只能</strong>对每个下标应用<strong>一次</strong>操作。</p>
<span id="more"></span>
<h1 id="示例">示例</h1>
<h2 id="示例1">示例1</h2>
<p>输入：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span><span class="number">4</span><span class="punctuation">,</span><span class="number">6</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>说明：</p>
<p>在这个示例中，我们进行了以下操作：</p>
<ul>
<li>选择下标1，将其替换为4（范围为[4, 8]），nums = [4,4,1,2]。</li>
<li>选择下标3，将其替换为4（范围为[0, 4]），nums = [4,4,1,4]。</li>
</ul>
<p>应用这些操作后，数组 nums 的得分为3（由下标 0、1 和 3 组成的子序列）。可以证明，3 是我们可以达到的最大可能长度。</p>
<h2 id="示例2">示例2</h2>
<p>输入：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>说明：</p>
<p>在这个示例中，我们无需执行任何操作。</p>
<p>数组nums的得分是4（整个数组）。</p>
<h1 id="思路">思路</h1>
<h2 id="重新读题">重新读题</h2>
<p>题目的表述有一股浓重的机翻味，我们不妨重新表述一下：</p>
<p>给定一个数组 $nums$ 和一个自然数 $k$</p>
<p>对于任意下标 $i$，我们可以将该元素 $nums[i]$ 替换为 $[nums[i] - k, nums[i] + k]$ 中的任意整数。一个下标只能操作一次，也可以不操作。</p>
<p>返回任意次操作后，$nums$ 中最大可能的重复元素数量。</p>
<h2 id="观察1：排序">观察1：排序</h2>
<p>为了得到尽可能多的重复元素，我们需要地将<strong>大小接近</strong>的元素进行操作，使它们的值相等。</p>
<p>如何找出大小接近的元素呢？—— 排序</p>
<h2 id="观察2：找规律">观察2：找规律</h2>
<p>假设在排序后，我们试图使区间 $[i, j]$内的元素在操作后的值相等。那么此时 $i$ 和 $j$ 需要满足什么条件呢？</p>
<ul>
<li>在排序后，已知 $nums[i] \le nums[i + 1] \le … \le nums[j - 1] \le nums[j]$</li>
<li>$nums[i]$ 的替换范围是 $[nums[i] - k, nums[i] + k]$ ；$nums[j]$ 的替换范围是 $[nums[j] - k, nums[j] + k]$</li>
<li>则 $nums[i] + k \ge nums[j] - k$</li>
<li>化简，得到  <strong>$0 \le nums[j] - nums[i] \le 2k$</strong></li>
</ul>
<p>可以看出，当 $i$ 固定时，为了尽可能使区间范围 $j - i + 1$ 变大，我们需要找到一个 $j$ ，使得 $nums[j] - nums[i]$ 尽可能地接近 $2k$。此时的区间范围 $j - i + 1$才有可能是我们想要的答案。</p>
<h2 id="观察3：滑动窗口">观察3：滑动窗口</h2>
<p>经过我们的分析，这道题变成了：</p>
<ul>
<li>对于一个有序数组 $nums$，和一个自然数 $k$</li>
<li>当下标 $i$ 固定，我们需要找到一个尽可能大的下标 $j$，并且满足 $0 \le nums[j] - nums[i] \le 2k$</li>
<li>在所有满足条件的区间 $[i, j]$ 中，最大的 $j - i + 1$ 即为答案</li>
</ul>
<p>那么，使用<strong>滑动窗口</strong>算法能够将暴力遍历的时间复杂度从 $O(n^2)$ 降低到 $O(n)$</p>
<h1 id="代码">代码</h1>
<h2 id="Java">Java</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumScore</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// sliding window</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; n &amp;&amp; nums[j] &lt;= nums[i] + <span class="number">2</span> * k) j++;</span><br><span class="line">            ans = Math.max(ans, j - i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>算法题002：螺旋矩阵 II</title>
    <url>/2023/10/03/Algorithm-Problem-002-spiral-matrix-ii/</url>
    <content><![CDATA[<h1 id="题目">题目</h1>
<blockquote>
<p>题目来源：<a href="https://leetcode.cn/problems/spiral-matrix-ii/">59. 螺旋矩阵 II</a></p>
</blockquote>
<p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n^2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p>
<span id="more"></span>
<h1 id="示例">示例</h1>
<h2 id="示例-1">示例 1</h2>
<p>输入：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src="./MDImgs/Algorithm-Problem-002-spiral-matrix-ii/spiraln.jpg" alt="img"></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="punctuation">[</span><span class="number">8</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="punctuation">[</span><span class="number">7</span><span class="punctuation">,</span><span class="number">6</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<h2 id="示例-2">示例 2</h2>
<p>输入：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>这道题是一道典型的模拟题，我们需要按照遍历整个矩阵。</p>
<h2 id="思路-1">思路 1</h2>
<p>我自己的做法是将矩阵分层（<code>layer</code>），一层一层地遍历。比如，当 $n = 3$ 时，矩阵为</p>
<p><img src="./MDImgs/Algorithm-Problem-002-spiral-matrix-ii/spiraln.jpg" alt="img"></p>
<p>此时，我们定义第一层为 <code>layer = 0</code>，包含数字 1 - 8；第二层为 <code>layer = 1</code>，包含数字 9；</p>
<p>遍历每一层时，依次编写向右（1、2）、向下（3、4）、向左（5、6）、向右（7、8）的循环代码</p>
<p>这种方法的重点在于找数学规律，找到 <code>layer</code> 和当前遍历的某一行/某一列的大小关系</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span>[][] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">layer</span> <span class="operator">=</span> <span class="number">0</span>; layer &lt;= n / <span class="number">2</span>; layer++) &#123;</span><br><span class="line">            <span class="comment">// 向右</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> layer; j &lt; n - layer - <span class="number">1</span>; ++j, ++counter) &#123;</span><br><span class="line">                ans[layer][j] = counter;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 向下</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> layer; i &lt; n - layer - <span class="number">1</span>; ++i, ++counter) &#123;</span><br><span class="line">                ans[i][n - layer - <span class="number">1</span>] = counter;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 向左</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n - layer - <span class="number">1</span>; j &gt; layer; --j, ++counter) &#123;</span><br><span class="line">                ans[n - layer - <span class="number">1</span>][j] = counter;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 向上</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - layer - <span class="number">1</span>; i &gt; layer; --i, ++counter) &#123;</span><br><span class="line">                ans[i][layer] = counter;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对于边长为奇数的方阵，中心元素需要手动处理</span></span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            ans[n / <span class="number">2</span>][n / <span class="number">2</span>] = counter;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>显然，这种做法很容易错，毕竟找规律挺无聊的。</strong></p>
<p>力扣上的几位大佬，提供了一种不需要找规律的解法，比如 <a href="https://leetcode.cn/problems/spiral-matrix-ii/solutions/12594/spiral-matrix-ii-mo-ni-fa-she-ding-bian-jie-qing-x/">Krahets 的题解</a>：手动地控制上下左右四个边界，当遍历到边界时，就到头了，向下一个方向开始遍历。</p>
<h2 id="思路-2">思路 2</h2>
<p>由于我们要生成一个矩阵（<strong>非常规则</strong>的图形），我们往往会从<strong>宏观</strong>的角度控制遍历，即思路 1。所谓宏观，即知道全局，它体现在我的解法的找数学规律，也体现在大佬的解法的控制四个边界。</p>
<p>那我们不妨从<strong>微观</strong>角度出发：假如我们自己站在一个<strong>巨大的、看不到边界的</strong>棋盘上，要去填入这些数字，我们会怎么填？我们<strong>只能看到四周的格子</strong>上的数字。此时，宏观的方法不再奏效，我们应该怎么做？</p>
<p><img src="./MDImgs/Algorithm-Problem-002-spiral-matrix-ii/spiraln.jpg" alt="img"></p>
<p>假设我们站在格子 1 上（面朝右），往前走，边走边写数字。当走到了格子 3，发现前面无路可走。因为要顺时针填入数字，我们不妨右拐（面朝下），此时面向的格子，就是要填入数字 4 的格子。</p>
<p>同理，当我们走到了格子 8（面朝上），此时前面的格子已经填入了数字 1。我们再次右拐（面朝右），此时面向的格子，就是要填入数字 9 的格子。</p>
<p>因此，在代码中，我们不妨<strong>只关心 agent 当前的坐标</strong>，让他<strong>认准一个方向一直走</strong>，直到遇到边界、或者已经填入了数字，<strong>此时右拐即可</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span>[][] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="comment">// (dx[k], dy[k]) 表示移动的方向，按照轮询的顺序，依次是向右、向下、向左、向上、向右 ...</span></span><br><span class="line">        <span class="type">int</span>[] dx = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] dy = &#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (x, y) 是 agent 的坐标;</span></span><br><span class="line">        <span class="comment">// dir 表示当前移动的方向，是 dx, dy 数组的索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, y = <span class="number">0</span>, dir = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 循环变量，以及循环退出条件</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">1</span>, limit = n * n;</span><br><span class="line">        <span class="keyword">while</span> (counter &lt;= limit) &#123;</span><br><span class="line">            <span class="comment">// 当前坐标在边界内，同时当前格子没有填入数字</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="number">0</span> &lt;= x &amp;&amp; x &lt; n &amp;&amp; <span class="number">0</span> &lt;= y &amp;&amp; y &lt; n &amp;&amp; ans[x][y] == <span class="number">0</span>) &#123;</span><br><span class="line">                ans[x][y] = counter;</span><br><span class="line">                counter++;</span><br><span class="line">                <span class="comment">// 继续走</span></span><br><span class="line">                x += dx[dir];</span><br><span class="line">                y += dy[dir];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 回撤一步</span></span><br><span class="line">            x -= dx[dir];</span><br><span class="line">            y -= dy[dir];</span><br><span class="line">            <span class="comment">// 向右转</span></span><br><span class="line">            dir = (dir + <span class="number">1</span>) % dx.length;</span><br><span class="line">            <span class="comment">// 往前一步后，位置 (x, y) 即为下一轮 while 循环要处理的第一个格子</span></span><br><span class="line">            x += dx[dir];</span><br><span class="line">            y += dy[dir];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思考">思考</h1>
<p>我会想出思路 2，是因为我最近做了一道算法题，它要求我顺时针地给一个边长为 <code>n</code> 的等腰直角三角形（直角边平行于坐标轴）填入数字。</p>
<p>比如，当 <code>n = 4</code> 时，要按如下的方式填入数字：</p>
<img src="./MDImgs/Algorithm-Problem-002-spiral-matrix-ii/image-20231003171918667.png" alt="image-20231003171918667" style="zoom:67%;" />
<p>按照思路 1 的解法，从宏观层面找规律，我根本懒得找，想想就麻烦。如果按照大佬们的边界法，斜边遍历的代码（ $x + y \le k$ ），又何尝不是一种找规律？</p>
<p>按照思路 2，所谓顺时针，其实就是轮询这几个方向：向上、向右下、向左。那么，在代码层面就是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] dx = &#123;-<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] dy = &#123;<span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>改一改思路 2 的代码即可。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>算法题003：对角线遍历 II</title>
    <url>/2023/10/29/Algorithm-Problem-003-diagonal-traverse-ii/</url>
    <content><![CDATA[<h1 id="题目">题目</h1>
<blockquote>
<p>题目来源：<a href="https://leetcode.cn/problems/diagonal-traverse-ii/">1424. 对角线遍历 II</a></p>
</blockquote>
<p>给你一个列表 <code>nums</code> ，里面每一个元素都是一个整数列表。请你依照下面各图的规则，按顺序返回 <code>nums</code> 中对角线上的整数。</p>
<h2 id="示例-1">示例 1</h2>
<p><img src="./MDImgs/Algorithm-Problem-003-diagonal-traverse-ii/image-20231029115351760.png" alt="image-20231029115351760"></p>
<blockquote>
<p>输入：nums = <code>[[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]]</code>
输出：<code>[1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16]</code></p>
</blockquote>
<span id="more"></span>
<h2 id="示例-2">示例 2</h2>
<p><img src="./MDImgs/Algorithm-Problem-003-diagonal-traverse-ii/image-20231029115127660.png" alt="image-20231029115127660"></p>
<blockquote>
<p>输入：nums = <code>[[1,2,3],[4,5,6],[7,8,9]]</code>
输出：<code>[1,4,2,7,5,3,8,6,9]</code></p>
</blockquote>
<h2 id="示例-3">示例 3</h2>
<blockquote>
<p>输入：nums = <code>[[1,2,3],[4],[5,6,7],[8],[9,10,11]]</code>
输出：<code>[1,4,2,5,3,8,6,9,7,10,11]</code></p>
</blockquote>
<h2 id="数据范围">数据范围</h2>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>1 &lt;= nums[i].length &lt;= 10^5</code></li>
<li><code>1 &lt;= nums[i][j] &lt;= 10^9</code></li>
<li><code>nums</code> 中最多有 <code>10^5</code> 个数字。</li>
</ul>
<h1 id="思路">思路</h1>
<p>对于自然数 $k \in \mathbb{N}$，第 $k + 1$ 条对角线上的元素坐标为 $\set{(i,j) | i + j = k}$。例如，当 $k = 2$ 时，第 $3$ 条对角线的元素坐标是 $\set{(0,2),(1,1),(2,0)}$</p>
<p>如果 <code>nums</code> 是个矩阵，那这题是一道简单模拟题，按照对角线遍历即可，时间复杂度为 $O(mn)$。</p>
<p>但是，<code>nums</code> 的行数 $m \le 10^5$，列数 $n \le 10^5$，$O(mn)$ 的时间复杂度会超时。因此，我们不应该把 <code>nums</code> 当作一个矩阵来遍历，否则会访问大量的空格子。</p>
<p>观察示例1：</p>
<p><img src="./MDImgs/Algorithm-Problem-003-diagonal-traverse-ii/image-20231029115351760.png" alt="image-20231029115351760"></p>
<p>观察1️⃣：对于任意的 $k \in \mathbb{N}$，第 $k + 1$ 条对角线的元素遍历顺序是从左下到右上，即 $(k, 0), (k - 1,1),\cdots,(0,k)$。因此，如果我们要获得第 $k + 1$ 条对角线上的元素，我们应该<strong>倒序遍历</strong> <code>nums</code> 中每一行的对应元素。</p>
<p>观察2️⃣：易得，对于<code>nums</code>中的每一行 <code>nums[j]</code>，其中的元素都属于不同的对角线，因此是<strong>相互独立</strong>的。</p>
<p>观察3️⃣：<strong>倒序遍历</strong> <code>nums</code> 中每一行时：</p>
<ul>
<li>对于<strong>最后一行</strong>的元素 $12,13,14,15,16$，它们都是自己对角线上的<strong>第一个</strong>元素，尽管后 4 个元素所属的对角线在第一列上不存在元素。</li>
<li>对于<strong>倒数第二行</strong>的元素 $9,10,11$，它们都是所属对角线的<strong>下一个</strong>应该遍历的元素</li>
<li>以此类推……</li>
</ul>
<p>我们的目标是要收集 <code>nums</code> 中的所有元素，收集方式是按照对角线元素顺序收集。</p>
<p>因此，我们可以先为每个对角线创建一个 list，将对应元素放入该 list 中。然后再正序遍历每个对角线 list，获得最终的结果。如果这样做，我们需要首先创建 <code>m + n - 1</code> 个 list。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums.size();</span><br><span class="line"><span class="comment">// n 为最大列数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.stream().mapToInt(List::size).max().getAsInt();</span><br><span class="line"><span class="comment">// ans 中存放 m + n - 1 个 list，代表各个对角线中遍历到的元素</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">IntStream.range(<span class="number">0</span>, m + n - <span class="number">1</span>).forEach(i -&gt; ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 核心：如何遍历？？？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正序收集 ans 中每行的元素</span></span><br><span class="line"><span class="keyword">return</span> ans.stream().flatMap(l -&gt; l.stream()).mapToInt(i -&gt; i).toArray();</span><br></pre></td></tr></table></figure>
<p>那么如何遍历呢？为了不超时，肯定是按照行遍历。</p>
<ul>
<li>根据『观察1️⃣』，倒序遍历 <code>nums</code> ；</li>
<li>根据『观察2️⃣』，对于每一行，每遍历到一个元素 <code>nums[i][j]</code>，就把它放入第 $i+j + 1$ 个 list 中</li>
<li>根据『观察3️⃣』，上述元素 <code>nums[i][j]</code> 应该添加到对应 list 最后。因为前 $n - i - 1$ 行（$n -1,n - 2 ,\cdots, i + 1$）中该对角线上的元素已经遍历过了，并且它们已经按照同样的方法、有序存放在该 list 中了—— 使用递归或者数学归纳法证明</li>
</ul>
<p>代码是简单的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 倒序遍历 nums</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    List&lt;Integer&gt; row = nums.get(i);</span><br><span class="line">    <span class="comment">// 每遍历到一个元素 nums[i][j]，就把它放入第 i + j + 1 个 list 中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; row.size(); j++) &#123;</span><br><span class="line">        ans.get(i + j).add(row.get(j));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度是 $O(m + n + \text{(nums 元素个数)})$</p>
<p>空间复杂度是 $O(m+n)$</p>
<h1 id="代码">代码</h1>
<h2 id="Java">Java</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findDiagonalOrder(List&lt;List&lt;Integer&gt;&gt; nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums.size();</span><br><span class="line">        <span class="comment">// n 为最大列数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.stream().mapToInt(List::size).max().getAsInt();</span><br><span class="line">        <span class="comment">// ans 中存放 m + n - 1 个 list，代表各个对角线中遍历到的元素</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        IntStream.range(<span class="number">0</span>, m + n - <span class="number">1</span>).forEach(i -&gt; ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 倒序遍历 nums</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            List&lt;Integer&gt; row = nums.get(i);</span><br><span class="line">            <span class="comment">// 每遍历到一个元素 nums[i][j]，就把它放入第 i + j + 1 个 list 中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; row.size(); j++) &#123;</span><br><span class="line">                ans.get(i + j).add(row.get(j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 正序收集 ans 中每行的元素</span></span><br><span class="line">        <span class="keyword">return</span> ans.stream().flatMap(l -&gt; l.stream()).mapToInt(i -&gt; i).toArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>算法题004：参加会议的最多员工数</title>
    <url>/2023/11/01/Algorithm-Problem-004-maximum-employees-to-be-invited-to-a-meeting/</url>
    <content><![CDATA[<h1 id="题目">题目</h1>
<blockquote>
<p>题目来源：<a href="https://leetcode.cn/problems/maximum-employees-to-be-invited-to-a-meeting/">2127. 参加会议的最多员工数</a>（每日一题）</p>
</blockquote>
<p>一个公司准备组织一场会议，邀请名单上有 <code>n</code> 位员工。公司准备了一张 <strong>圆形</strong> 的桌子，可以坐下 <strong>任意数目</strong> 的员工。</p>
<p>员工编号为 <code>0</code> 到 <code>n - 1</code> 。每位员工都有一位 <strong>喜欢</strong> 的员工，每位员工 <strong>当且仅当</strong> 他被安排在喜欢员工的旁边，他才会参加会议。每位员工喜欢的员工 <strong>不会</strong> 是他自己。</p>
<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>favorite</code> ，其中 <code>favorite[i]</code> 表示第 <code>i</code> 位员工喜欢的员工。请你返回参加会议的 <strong>最多员工数目</strong> 。</p>
<h2 id="示例-1">示例 1</h2>
<blockquote>
<p>输入：favorite = [2,2,1,2]
输出：3</p>
</blockquote>
<p><img src="./MDImgs/Algorithm-Problem-004-maximum-employees-to-be-invited-to-a-meeting/image-20231101114926490.png" alt="image-20231101114926490" style="zoom:65%;" /><img src="./MDImgs/Algorithm-Problem-004-maximum-employees-to-be-invited-to-a-meeting/image-20231101125447756-16988146128191.png" alt="image-20231101125447756" style="zoom:35%;" /></p>
<span id="more"></span>
<h2 id="示例-2">示例 2</h2>
<blockquote>
<p>输入：favorite = [1,2,0]
输出：3</p>
</blockquote>
<p><img src="./MDImgs/Algorithm-Problem-004-maximum-employees-to-be-invited-to-a-meeting/image-20231101115048286.png" alt="image-20231101115048286"></p>
<h2 id="示例-3">示例 3</h2>
<blockquote>
<p>输入：favorite = [3,0,1,4,1]
输出：4</p>
</blockquote>
<p><img src="./MDImgs/Algorithm-Problem-004-maximum-employees-to-be-invited-to-a-meeting/image-20231101115200232.png" alt="image-20231101115200232" style="zoom:65%;" /><img src="./MDImgs/Algorithm-Problem-004-maximum-employees-to-be-invited-to-a-meeting/image-20231101125539019.png" alt="image-20231101125539019" style="zoom:33%;" /></p>
<h1 id="思路">思路</h1>
<p>根据 <code>favorite</code> 的定义，如果将每个员工视作一个节点，指向自己喜欢的员工，那么 $n$ 条边、$n$ 个节点、每个节点的出度为 $1$ ，这形成了一个<strong>有向有环图</strong>。</p>
<p>观察示例 2 和 示例 3，参加圆桌会议的员工一定形成一个环。因为每个节点的出度为 $1$，该员工又必须坐在自己喜欢的员工旁。所以，参加会议的最多员工数目，等于<strong>最大环的长度</strong>。（结论 1️⃣）</p>
<p>结论 1️⃣也可以反过来论证：</p>
<p>观察示例 3，节点 2 不能参加会议，因为将该员工插入圆桌任一位置后不符合条件——已有的环被打破了。例如，将 2 插入 0 和 1 之间，那么 1 的旁边是 2 和 4，都不是自己喜欢的员工，条件不再成立。</p>
<p>所以，那些能参加会议的员工组成的图，一定是一个环，不可能再有其他节点链（单向链表）指向环中的某个节点。</p>
<p>如图，答案是 $\set{0,1,2,3}$，而不可能包含 $\set{7,8}$ 和 $\set{4,5,6}$。</p>
<img src="./MDImgs/Algorithm-Problem-004-maximum-employees-to-be-invited-to-a-meeting/image-20231101132810263.png" alt="image-20231101132810263" style="zoom: 50%;" />
<p><strong>但是</strong>，对于<strong>长度为 2 的环</strong>（互相指向的两个节点），只要两个员工坐在一起，这个环就无法被打破。因此，长度为 2 的环需要<strong>特殊处理</strong>。观察示例 1，节点 1 和 2 形成环，此时的圆桌可以再进入 1 人。</p>
<p>再观察如下示例：</p>
<img src="./MDImgs/Algorithm-Problem-004-maximum-employees-to-be-invited-to-a-meeting/image-20231101133700388.png" alt="image-20231101133700388" style="zoom:50%;" />
<p>节点 0 和 1 形成长度为 2 的环，节点链 $(3,2)$ 指向 0，节点链$(5,4),(6)$ 指向 1。最终圆桌上的员工按顺序依次为：$3,2,0,1,4,5$。即<strong>以环为中心，选择环中两个节点各自最长的节点链加入结果集</strong>。（结论2️⃣）所以，我们选择 $(5,4)$，而不是 $(6)$。</p>
<p>注意到，这个图可能包含多个连通分量。我们需要修正上述两个结论：</p>
<ul>
<li>对于长度大于 2 的环，整个圆桌必须归其中的节点所有，不允许其它节点出现。因此，当有多个环时，选择长度最大的作为结果。</li>
<li>对于长度等于 2 的环，“每位员工当且仅当他被安排在喜欢员工的旁边，他才会参加会议”，这个条件的成立仅仅依赖于环，而不依赖于独占圆桌。因此，<strong>最终的结果是符合『结论2️⃣』的所有结果集的并集</strong>。一个结果集中的员工只要坐在一起，<strong>那么所有的结果集就能同时存在</strong>。</li>
</ul>
<p>观察下面的示例，答案为三个长度为 2 的环和延伸出去的节点链，总共 8 个节点；而剩下的连通分量，是一个长度为 4 的环。</p>
<img src="./MDImgs/Algorithm-Problem-004-maximum-employees-to-be-invited-to-a-meeting/image-20231101134045195.png" alt="image-20231101134045195" style="zoom: 50%;" />
<h1 id="代码">代码</h1>
<p>根据上一节的推论，我们在代码中需要求得如下信息：</p>
<ul>
<li>各个环的长度</li>
<li>长度为 2 的环的每个节点的节点链的最大长度</li>
</ul>
<h2 id="如何找到图中的环？">如何找到图中的环？</h2>
<p>拓扑排序。因为这是包含 <strong>$n$ 条边、$n$ 个节点、每个节点的出度为 $1$</strong> 的有向图，因此拓扑排序过程中无法被访问的节点一定是环中的节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> favorite.length;</span><br><span class="line"><span class="type">int</span>[] inDegree = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">ArrayDeque&lt;Integer&gt; que = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"><span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    inDegree[favorite[i]]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">        que.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> que.pollFirst();</span><br><span class="line">    visited[cur] = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> favorite[cur];</span><br><span class="line"></span><br><span class="line">    inDegree[next]--;</span><br><span class="line">    <span class="keyword">if</span> (inDegree[next] == <span class="number">0</span>) &#123;</span><br><span class="line">        que.addLast(next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此时遍历完了所有非环节点，并将它们标记为 visited</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">maxCircleSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// circle 收集当前环中的所有节点</span></span><br><span class="line">    ArrayList&lt;Integer&gt; circle = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> i;</span><br><span class="line">    <span class="keyword">while</span> (!visited[cur]) &#123;</span><br><span class="line">        circle.add(cur);</span><br><span class="line">        visited[cur] = <span class="literal">true</span>;</span><br><span class="line">        cur = favorite[cur];</span><br><span class="line">    &#125;</span><br><span class="line">    maxCircleSize = Math.max(maxCircleSize, circle.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="如何统计节点链？">如何统计节点链？</h2>
<p>节点链是不属于环的单链表。该链表从一个入度为 0 的节点开始，以指向一个环中节点而结束。我们可以定义一个 <code>pathLen</code> 数组，<code>pathLen[i]</code> 表示<strong>指向节点 <code>i</code> 的最长节点链的长度</strong></p>
<p>由于拓扑排序不断地遍历当前入度为 0 的节点，如果节点 a 指向 b，那么 a 一定先被访问。如果 a 的节点链已经计算完毕，那么我们可以很方便地计算 b 的节点链：</p>
<p>$pathLen[b] = \max\limits_{(a,b)\in E}\set{1 + pathLen[a]}$</p>
<p>所以我们可以在拓扑排序的过程中计算 <code>pathLen</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始值为 0</span></span><br><span class="line"><span class="type">int</span>[] pathLen = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> que.pollFirst();</span><br><span class="line">    visited[cur] = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> favorite[cur];</span><br><span class="line">    <span class="comment">// 在这里更新 pathLen</span></span><br><span class="line">    pathLen[next] = Math.max(pathLen[next], pathLen[cur] + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    inDegree[next]--;</span><br><span class="line">    <span class="keyword">if</span> (inDegree[next] == <span class="number">0</span>) &#123;</span><br><span class="line">        que.addLast(next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最终代码">最终代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumInvitations</span><span class="params">(<span class="type">int</span>[] favorite)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> favorite.length;</span><br><span class="line">        <span class="type">int</span>[] inDegree = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] pathLen = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        ArrayDeque&lt;Integer&gt; que = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拓扑排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            inDegree[favorite[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                que.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> que.pollFirst();</span><br><span class="line">            visited[cur] = <span class="literal">true</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> favorite[cur];</span><br><span class="line">            pathLen[next] = Math.max(pathLen[next], pathLen[cur] + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            inDegree[next]--;</span><br><span class="line">            <span class="keyword">if</span> (inDegree[next] == <span class="number">0</span>) &#123;</span><br><span class="line">                que.addLast(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 拓扑排序完毕，此时遍历完了所有非环节点，并将它们标记为 visited</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 最大环长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxCircleLength</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 符合『结论2️⃣』的所有结果集的并集的大小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">twoCirclePath</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始找环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// circle 收集当前环中的所有节点</span></span><br><span class="line">            ArrayList&lt;Integer&gt; circle = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">while</span> (!visited[cur]) &#123;</span><br><span class="line">                circle.add(cur);</span><br><span class="line">                visited[cur] = <span class="literal">true</span>;</span><br><span class="line">                cur = favorite[cur];</span><br><span class="line">            &#125;</span><br><span class="line">            maxCircleLength = Math.max(maxCircleLength, circle.size());</span><br><span class="line">            <span class="keyword">if</span> (circle.size() == <span class="number">2</span>) &#123;</span><br><span class="line">                twoCirclePath += pathLen[circle.get(<span class="number">0</span>)] + pathLen[circle.get(<span class="number">1</span>)] + <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxCircleLength, twoCirclePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>图</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>算法题005：平衡子序列的最大和</title>
    <url>/2023/11/06/Algorithm-Problem-005-maximum-balanced-subsequence-sum/</url>
    <content><![CDATA[<h1 id="题目">题目</h1>
<blockquote>
<p>题目来源：<a href="https://leetcode.cn/problems/maximum-balanced-subsequence-sum/">2926. 平衡子序列的最大和</a></p>
<p>本文是对 <a href="/2023/11/05/leetcode-370-weekly-contest-summary/">力扣第 370 场周赛</a> 没做出来的最后一题的题解的分析。题解参考了<a href="https://leetcode.cn/problems/maximum-balanced-subsequence-sum/solutions/2513121/shu-zhuang-shu-zu-you-hua-dp-by-endlessc-3zf4/">灵茶山艾府的文章</a>。</p>
</blockquote>
<p><img src="./MDImgs/Algorithm-Problem-005-maximum-balanced-subsequence-sum/image-20231105162645031.png" alt="image-20231105162645031"></p>
<span id="more"></span>
<p><img src="./MDImgs/Algorithm-Problem-005-maximum-balanced-subsequence-sum/image-20231105162654150.png" alt="image-20231105162654150"></p>
<h1 id="思路">思路</h1>
<h2 id="DP">DP</h2>
<p>重新读题：一个平衡子序列中连续的两个元素 <code>nums[i]</code> 和 <code>nums[j]</code> 需要满足 $i &lt; j$ 且 $nums[j] - nums[i] \ge j -i$</p>
<p>对上述不等式移项，得到 $nums[j] - j \ge nums[i] - i$</p>
<p>令 $b[i] = nums[i] - i$，则平衡子序列中每个元素需要满足的条件只和自身下标有关。</p>
<p>因此，这道题类似于最长递增子序列，用 DP 解决：</p>
<p>DP 定义：<code>dp[j]</code> 表示以 <code>nums[j]</code> <strong>结尾</strong>的 <strong>平衡</strong> 子序列里面的 <strong>最大元素和</strong> 。</p>
<p>递推式：$dp[j] = nums[j] + \max\set{dp[i] | (i &lt; j) ∧ (b[j] \ge b[i])}$</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">maxBalancedSubsequenceSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// b[i] = nums[i] - i</span></span><br><span class="line">        <span class="type">int</span>[] b = IntStream.range(<span class="number">0</span>, n).map(i -&gt; nums[i] - i).toArray();</span><br><span class="line">        <span class="comment">// dp[i]： 以 nums[i] 结尾的子序列的最大元素和</span></span><br><span class="line">        <span class="type">long</span>[] dp = <span class="keyword">new</span> <span class="title class_">long</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            dp[j] = nums[j];</span><br><span class="line">            <span class="type">long</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; j; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (b[j] &gt;= b[i])</span><br><span class="line">                    max = Math.max(max, dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[j] += max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(dp).max().getAsLong();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然，两层循环的时间复杂度是 $O(n^2)$，肯定会超时。我们应该如何优化呢？</p>
<h2 id="树状数组-BIT">树状数组 BIT</h2>
<p>根据上述递推式，我们的代码逻辑应该是这样的：</p>
<ul>
<li>对于每一个 $j$</li>
<li>遍历区间 $[0, j)$，找到其中使得 $b[j] \ge b[i]$ 并且 $dp[i]$ 最大的下标 $i$ —— 区间查询最大值</li>
<li>令 $dp[j] = nums[j] + dp[i]$ —— 单点更新</li>
</ul>
<p>我们需要让 『区间查询』+ 『单点更新』的时间复杂度严格小于 $O(n)$，这样才不会超时。哪一种现有的数据结构能做到这一点？—— 树状数组（Binary Index Tree）。</p>
<blockquote>
<p>我本来以为 BIT 只适合区间查询求和（对于差分数组的优化），但这道题告诉了我们，区间查询的对象可以拓展到最小值和最大值。</p>
</blockquote>
<p>BIT 中存放的是什么？<code>&lt;b[j], dp[j]&gt;</code> 的键值对，即 <code>b[j]</code> 是下标，<code>dp[j]</code> 是数组元素。我们要查询所有下标 $\le b[j]$  的元素的最大值，即前缀区间的最大值。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">BIT</span> &#123;</span><br><span class="line">        <span class="type">long</span>[] arr;</span><br><span class="line">        <span class="type">int</span> offset;</span><br><span class="line"></span><br><span class="line">        BIT(<span class="type">int</span> min, <span class="type">int</span> max) &#123;</span><br><span class="line">            <span class="comment">// 将区间 [min, max] 移动到从 0 开始</span></span><br><span class="line">            offset = -min;</span><br><span class="line">            <span class="comment">// BIT 的下标 0 必须留空，因此上述区间从 1 开始</span></span><br><span class="line">            offset++;</span><br><span class="line">            arr = <span class="keyword">new</span> <span class="title class_">long</span>[max - min + <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="title function_">lsb</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i &amp; -i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">setMax</span><span class="params">(<span class="type">int</span> i, <span class="type">long</span> val)</span> &#123;</span><br><span class="line">            i += offset;</span><br><span class="line">            <span class="comment">// 下标 i 会对之后所有区间产生影响，因此是加上 lsb</span></span><br><span class="line">            <span class="keyword">for</span> (; i &lt; arr.length; i += lsb(i)) &#123;</span><br><span class="line">                arr[i] = Math.max(arr[i], val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="title function_">getMax</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">            i += offset;</span><br><span class="line">            <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> Long.MIN_VALUE;</span><br><span class="line">            <span class="comment">// 前缀区间，因此是减去 lsb</span></span><br><span class="line">            <span class="keyword">for</span> (; i &gt; <span class="number">0</span>; i -= lsb(i)) &#123;</span><br><span class="line">                ans = Math.max(ans, arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">maxBalancedSubsequenceSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// b[i] = nums[i] - i</span></span><br><span class="line">        <span class="type">int</span>[] b = IntStream.range(<span class="number">0</span>, n).map(i -&gt; nums[i] - i).toArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Arrays.stream(b).max().getAsInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Arrays.stream(b).min().getAsInt();</span><br><span class="line">        <span class="comment">// 根据 b 中元素的范围定制 BIT#arr 的大小</span></span><br><span class="line">        <span class="type">BIT</span> <span class="variable">tree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BIT</span>(min, max);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> Long.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="comment">// 区间查询最大值</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">dp_i</span> <span class="operator">=</span> Math.max(tree.getMax(b[j]), <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 单点更新</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">dp_j</span> <span class="operator">=</span> dp_i + nums[j];</span><br><span class="line">            tree.setMax(b[j], dp_j);</span><br><span class="line"></span><br><span class="line">            ans = Math.max(ans, dp_j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提交该代码：</p>
<p><img src="./MDImgs/Algorithm-Problem-005-maximum-balanced-subsequence-sum/image-20231106113338051.png" alt="image-20231106113338051"></p>
<p>注意题目的数据范围：$n \le 10^5$ ，$nums[i] \in[-10^9,10^9]$</p>
<p>因此 <code>b[i]</code> 的取值范围约等于 32-bit 整型的取值范围，即 $2^{32}$，这显然会在创建 <code>BIT#arr</code> 时导致 OOM。如何优化空间呢？</p>
<h2 id="离散化">离散化</h2>
<blockquote>
<p>参考 <a href="https://oi-wiki.org/misc/discrete/">OI-wiki</a> 的描述：</p>
<p>离散化是一种数据处理的技巧，本质上可以看成是一种哈希，其保证数据在哈希以后仍然保持原来的全/偏序关系。</p>
<p>通俗地讲就是当<strong>有些数据</strong>因为本身很大或者类型不支持，自身<strong>无法作为数组的下标</strong>来方便地处理，而<strong>影响最终结果的只有元素之间的相对大小关系</strong>时，我们可以将原来的数据<strong>按照排名来处理问题</strong>，即离散化。</p>
</blockquote>
<p>结合本题来理解：</p>
<ul>
<li>我们要查询所有下标 $\le b[j]$  的元素的最大值 —— $b[j]$ 有 $2^{32}$ 个可能取值。</li>
<li>而数组 <code>b</code> 只有 <code>n</code> 个元素。</li>
<li>假设 <code>b[j]</code> 在排序后是第 $k$ 小的元素，那么我们只需要查询前 $k - 1$ 个比 <code>b[j]</code> 小的元素中的最大值。</li>
<li>因此，<code>BIT#arr</code> 的长度也是 <code>n</code> ，且 $n \ll 2^{32}$。</li>
<li>假设我们知道 <code>b[j]</code> 在排序后的下标 <code>k</code>，那么『查询所有下标 $\le b[j]$  的元素的最大值』就等价于 <code>getMax(k)</code>。</li>
</ul>
<blockquote>
<p>从结果上来看，『离散化』应该叫做『归一化』更合适？🤔</p>
</blockquote>
<p>离散化的过程也是典型的模板，背出来就行了：</p>
<blockquote>
<ol>
<li>创建原数组的副本。</li>
<li>将副本中的值从小到大排序。</li>
<li>将排序好的副本去重。</li>
<li>查找原数组的每一个元素在副本中的位置，位置即为排名，将其作为离散化后的值。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> ans[i] 表示 b[i] 在排序后是第几小的元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span>[] discretize(<span class="type">int</span>[] b) &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = Arrays.stream(b).sorted().distinct().toArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> b.length;</span><br><span class="line">    <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// b[i] 一定存在于 arr 中</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">order</span> <span class="operator">=</span> Arrays.binarySearch(arr, b[i]);</span><br><span class="line">        <span class="comment">// ans[i] &gt;= 1 是因为 BIT 的下标 0 必须留空。实际上可以不用加 1</span></span><br><span class="line">        ans[i] = order + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不去重，C++ 使用 <code>std::lower_bound</code> 代替 <code>std::binary_search</code>。但是 Java 中没有这样的函数，因此一定要去重。</p>
<h1 id="代码">代码</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">BIT</span> &#123;</span><br><span class="line">        <span class="type">long</span>[] arr;</span><br><span class="line"></span><br><span class="line">        BIT(<span class="type">int</span> n) &#123;</span><br><span class="line">            arr = <span class="keyword">new</span> <span class="title class_">long</span>[n + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="title function_">lsb</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i &amp; -i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">setMax</span><span class="params">(<span class="type">int</span> i, <span class="type">long</span> val)</span> &#123;</span><br><span class="line">            <span class="comment">// 下标 i 会对之后所有区间产生影响，因此是加上 lsb</span></span><br><span class="line">            <span class="keyword">for</span> (; i &lt; arr.length; i += lsb(i)) &#123;</span><br><span class="line">                arr[i] = Math.max(arr[i], val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="title function_">getMax</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> Long.MIN_VALUE;</span><br><span class="line">            <span class="comment">// 前缀区间，因此是减去 lsb</span></span><br><span class="line">            <span class="keyword">for</span> (; i &gt; <span class="number">0</span>; i -= lsb(i)) &#123;</span><br><span class="line">                ans = Math.max(ans, arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ans[i] 表示 b[i] 在排序后是第几小的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] discretize(<span class="type">int</span>[] b) &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = Arrays.stream(b).sorted().distinct().toArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> b.length;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// b[i] 一定存在于 arr 中</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">order</span> <span class="operator">=</span> Arrays.binarySearch(arr, b[i]);</span><br><span class="line">            <span class="comment">// ans[i] &gt;= 1 是因为 BIT 的下标 0 必须留空。实际上可以不用加 1</span></span><br><span class="line">            ans[i] = order + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">maxBalancedSubsequenceSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// b[i] = nums[i] - i</span></span><br><span class="line">        <span class="type">int</span>[] b = IntStream.range(<span class="number">0</span>, n).map(i -&gt; nums[i] - i).toArray();</span><br><span class="line">        <span class="comment">// 离散化</span></span><br><span class="line">        <span class="type">int</span>[] arr = discretize(b);</span><br><span class="line">        <span class="type">BIT</span> <span class="variable">tree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BIT</span>(n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> Long.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="comment">// b[j] 是第 k 小的元素</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> arr[j];</span><br><span class="line">            <span class="comment">// 区间查询最大值</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">dp_i</span> <span class="operator">=</span> Math.max(tree.getMax(k), <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 单点更新</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">dp_j</span> <span class="operator">=</span> dp_i + nums[j];</span><br><span class="line">            tree.setMax(k, dp_j);</span><br><span class="line"></span><br><span class="line">            ans = Math.max(ans, dp_j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考文章">参考文章</h1>
<ul>
<li><a href="https://leetcode.cn/problems/maximum-balanced-subsequence-sum/solutions/2513121/shu-zhuang-shu-zu-you-hua-dp-by-endlessc-3zf4/">树状数组优化 DP（Python/Java/C++/Go）</a></li>
<li><a href="https://oi-wiki.org/misc/discrete/">离散化 - OI Wiki</a></li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>树状数组</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title>算法题006：根据前序和后序遍历构造二叉树</title>
    <url>/2024/02/22/Algorithm-Problem-006-construct-binary-tree-from-preorder-and-postorder-traversal/</url>
    <content><![CDATA[<h1 id="题目">题目</h1>
<blockquote>
<p>题目来源：<a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal">889. 根据前序和后序遍历构造二叉树</a>（每日一题）</p>
</blockquote>
<blockquote>
<p><strong>题目描述</strong>：</p>
<p>给定两个整数数组，<code>preorder</code> 和 <code>postorder</code> ，其中 <code>preorder</code> 是一个具有 <strong>无重复</strong> 值的二叉树的前序遍历，<code>postorder</code> 是同一棵树的后序遍历，重构并返回二叉树。</p>
<p>如果存在多个答案，您可以返回其中 <strong>任何</strong> 一个。</p>
</blockquote>
<span id="more"></span>
<blockquote>
<p><strong>示例 1：</strong></p>
<p><img src="./MDImgs/Algorithm-Problem-006-construct-binary-tree-from-preorder-and-postorder-traversal/lc-prepost.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：preorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]</span><br><span class="line">输出：[1,2,3,4,5,6,7]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: preorder = [1], postorder = [1]</span><br><span class="line">输出: [1]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= preorder.length &lt;= 30</code></li>
<li><code>1 &lt;= preorder[i] &lt;= preorder.length</code></li>
<li><code>preorder</code> 中所有值都 <strong>不同</strong></li>
<li><code>postorder.length == preorder.length</code></li>
<li><code>1 &lt;= postorder[i] &lt;= postorder.length</code></li>
<li><code>postorder</code> 中所有值都 <strong>不同</strong></li>
<li>保证 <code>preorder</code> 和 <code>postorder</code> 是同一棵二叉树的前序遍历和后序遍历</li>
</ul>
</blockquote>
<h1 id="思路">思路</h1>
<p>首先，<strong>前序和后序构造的二叉树不唯一</strong>，因此不存在确定的规则，自由反而带来了坏处。与之相对的，『中序和前序』以及『中序和后序』只对应唯一的二叉树，规则明确，按照规则写代码即可。因此，我们要自定义规则。</p>
<p>回忆用『中序和前序』构造二叉树，我们顺序遍历前序列表，每遍历一个值，创建对应节点，然后根据中序确定其子树。这可以理解为前序创建，中序校验。</p>
<p>同理，在这道题中，我们也是“顺序遍历前序列表，每遍历一个值，创建对应节点”，但是根据后序确定 <strong>该节点的位置</strong> （而不是其子树）—— 前序创建，后序校验。</p>
<p>前序是“中左右”，每遍历前序列表一个节点，我们都可以尝试把它放到左子节点。而后序是“左右中”，<strong>假设在后序列表中节点 A 在 B 之后，那么 A 绝对不可能在 B 的左子树中。</strong></p>
<p>例如，观察示例 1 的节点 <code>5</code>。顺序遍历前序列表，我们尝试把 <code>5</code> 作为 <code>4</code> 的左子节点。但是在后序列表中，<code>5</code> 在 <code>4</code> 之后，那么这种尝试是不允许的。 <strong><code>5</code> 只可能在 <code>4</code> 的某一个祖先的右子树中</strong>，在这里是 <code>2</code> 的右节点。</p>
<p>因此，我们需要追踪<strong>从根节点到上一个遍历到的节点的一条路径</strong>，将它们存入一个栈中。</p>
<ul>
<li>只要当前节点和栈顶节点不满足上述后序约束，就出栈，直到满足为止。此时，当前节点是栈顶节点的右子节点。</li>
<li>如果已经满足约束，当前节点直接成为栈顶节点的左子节点。</li>
</ul>
<h1 id="代码">代码</h1>
<p>上述思路是一个大致描述，还是要注意一些细节。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructFromPrePost</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = preorder.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 只操作 vector 尾部，相当于 stack</span></span><br><span class="line">        vector&lt;TreeNode*&gt; ve;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="comment">// 和『中序和前序』一样，将校验列表的 &lt;元素, 索引&gt; 存入哈希表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            mp[postorder[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v: preorder) &#123;</span><br><span class="line">            TreeNode* cur = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(v);</span><br><span class="line">            <span class="comment">// 只有第一个元素（根节点）才可能触发这个条件</span></span><br><span class="line">            <span class="keyword">if</span> (ve.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                ve.<span class="built_in">push_back</span>(cur);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">bool</span> popped = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span>((!ve.<span class="built_in">empty</span>()) &amp;&amp; (mp[v] &gt; mp[ve.<span class="built_in">back</span>()-&gt;val])) &#123;</span><br><span class="line">                ve.<span class="built_in">pop_back</span>();</span><br><span class="line">                popped = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!popped) &#123;</span><br><span class="line">                ve.<span class="built_in">back</span>()-&gt;left = cur;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ve.<span class="built_in">back</span>()-&gt;right = cur;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 存入当前节点，用于下一个节点的判断</span></span><br><span class="line">            ve.<span class="built_in">push_back</span>(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第一个节点永远是根节点，且不会被弹出</span></span><br><span class="line">        <span class="keyword">return</span> ve.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：$O(n)$</p>
<ul>
<li>顺序遍历 <code>preorder</code> 和 <code>postorder</code>；</li>
<li>所有节点只会进出 <code>ve</code> 一次；</li>
</ul>
<p>空间复杂度：$O(n)$</p>
<ul>
<li><code>mp</code> 存放了 $n$ 个节点的值及其索引；</li>
<li>最坏的情况，所有节点都进入 <code>ve</code>；</li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>算法题007：串联所有单词的子串</title>
    <url>/2025/01/15/Algorithm-Problem-007-substring-with-concatenation-of-all-words/</url>
    <content><![CDATA[<h1 id="题目">题目</h1>
<blockquote>
<p>题目来源：<a href="https://leetcode.cn/problems/substring-with-concatenation-of-all-words/">30. 串联所有单词的子串</a></p>
</blockquote>
<blockquote>
<p><strong>题目描述：</strong></p>
<p>给定一个字符串 <code>s</code> 和一个字符串数组 <code>words</code><strong>。</strong> <code>words</code> 中所有字符串 <strong>长度相同</strong>。</p>
<p><code>s</code> 中的 <strong>串联子串</strong> 是指一个包含 <code>words</code> 中所有字符串以任意顺序排列连接起来的子串。</p>
<ul>
<li>例如，如果 <code>words = [&quot;ab&quot;,&quot;cd&quot;,&quot;ef&quot;]</code>， 那么 <code>&quot;abcdef&quot;</code>， <code>&quot;abefcd&quot;</code>，<code>&quot;cdabef&quot;</code>， <code>&quot;cdefab&quot;</code>，<code>&quot;efabcd&quot;</code>， 和 <code>&quot;efcdab&quot;</code> 都是串联子串。 <code>&quot;acdbef&quot;</code> 不是串联子串，因为他不是任何 <code>words</code> 排列的连接。</li>
</ul>
<p>返回所有串联子串在 <code>s</code> 中的开始索引。你可以以 <strong>任意顺序</strong> 返回答案。</p>
</blockquote>
<span id="more"></span>
<blockquote>
<p><strong>示例 1：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;barfoothefoobarman&quot;</span><span class="punctuation">,</span> words = <span class="punctuation">[</span><span class="string">&quot;foo&quot;</span><span class="punctuation">,</span><span class="string">&quot;bar&quot;</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="number">0</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">]</span></span><br><span class="line">解释：因为 words.length == <span class="number">2</span> 同时 words<span class="punctuation">[</span>i<span class="punctuation">]</span>.length == <span class="number">3</span>，连接的子字符串的长度必须为 <span class="number">6</span>。</span><br><span class="line">子串 <span class="string">&quot;barfoo&quot;</span> 开始位置是 <span class="number">0</span>。它是 words 中以 <span class="punctuation">[</span><span class="string">&quot;bar&quot;</span><span class="punctuation">,</span><span class="string">&quot;foo&quot;</span><span class="punctuation">]</span> 顺序排列的连接。</span><br><span class="line">子串 <span class="string">&quot;foobar&quot;</span> 开始位置是 <span class="number">9</span>。它是 words 中以 <span class="punctuation">[</span><span class="string">&quot;foo&quot;</span><span class="punctuation">,</span><span class="string">&quot;bar&quot;</span><span class="punctuation">]</span> 顺序排列的连接。</span><br><span class="line">输出顺序无关紧要。返回 <span class="punctuation">[</span><span class="number">9</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">]</span> 也是可以的。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;wordgoodgoodgoodbestword&quot;</span><span class="punctuation">,</span> words = <span class="punctuation">[</span><span class="string">&quot;word&quot;</span><span class="punctuation">,</span><span class="string">&quot;good&quot;</span><span class="punctuation">,</span><span class="string">&quot;best&quot;</span><span class="punctuation">,</span><span class="string">&quot;word&quot;</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">解释：因为 words.length == <span class="number">4</span> 并且 words<span class="punctuation">[</span>i<span class="punctuation">]</span>.length == <span class="number">4</span>，所以串联子串的长度必须为 <span class="number">16</span>。</span><br><span class="line">s 中没有子串长度为 <span class="number">16</span> 并且等于 words 的任何顺序排列的连接。</span><br><span class="line">所以我们返回一个空数组。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;barfoofoobarthefoobarman&quot;</span><span class="punctuation">,</span> words = <span class="punctuation">[</span><span class="string">&quot;bar&quot;</span><span class="punctuation">,</span><span class="string">&quot;foo&quot;</span><span class="punctuation">,</span><span class="string">&quot;the&quot;</span><span class="punctuation">]</span></span><br><span class="line">输出：<span class="punctuation">[</span><span class="number">6</span><span class="punctuation">,</span><span class="number">9</span><span class="punctuation">,</span><span class="number">12</span><span class="punctuation">]</span></span><br><span class="line">解释：因为 words.length == <span class="number">3</span> 并且 words<span class="punctuation">[</span>i<span class="punctuation">]</span>.length == <span class="number">3</span>，所以串联子串的长度必须为 <span class="number">9</span>。</span><br><span class="line">子串 <span class="string">&quot;foobarthe&quot;</span> 开始位置是 <span class="number">6</span>。它是 words 中以 <span class="punctuation">[</span><span class="string">&quot;foo&quot;</span><span class="punctuation">,</span><span class="string">&quot;bar&quot;</span><span class="punctuation">,</span><span class="string">&quot;the&quot;</span><span class="punctuation">]</span> 顺序排列的连接。</span><br><span class="line">子串 <span class="string">&quot;barthefoo&quot;</span> 开始位置是 <span class="number">9</span>。它是 words 中以 <span class="punctuation">[</span><span class="string">&quot;bar&quot;</span><span class="punctuation">,</span><span class="string">&quot;the&quot;</span><span class="punctuation">,</span><span class="string">&quot;foo&quot;</span><span class="punctuation">]</span> 顺序排列的连接。</span><br><span class="line">子串 <span class="string">&quot;thefoobar&quot;</span> 开始位置是 <span class="number">12</span>。它是 words 中以 <span class="punctuation">[</span><span class="string">&quot;the&quot;</span><span class="punctuation">,</span><span class="string">&quot;foo&quot;</span><span class="punctuation">,</span><span class="string">&quot;bar&quot;</span><span class="punctuation">]</span> 顺序排列的连接。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 104</code></li>
<li><code>1 &lt;= words.length &lt;= 5000</code></li>
<li><code>1 &lt;= words[i].length &lt;= 30</code></li>
<li><code>words[i]</code> 和 <code>s</code> 由小写英文字母组成</li>
</ul>
</blockquote>
<h1 id="思路">思路</h1>
<p>为了方便起见，记 <code>words.length</code> 为 <code>n</code>，<code>words[i].length</code> 为 <code>n2</code>。</p>
<p>一个暴力的解法是，依次遍历 <code>s</code> 的每一个下标 <code>i</code>，然后判断以下标 <code>i</code> 为起始的长度为 <code>n * n2</code> 的子串（<code>s[i : i + n * n2)</code>）是否是一个串联子串。该解法类似于暴力求解字符串匹配问题。显然，对于这道困难题，这种做法的时间复杂度是不合格的。</p>
<p>因此，我们要想办法优化该做法。注意到题目中的“<code>words</code> 中所有字符串长度相同”。这显然是一个非常特殊的条件。假设我们已经考察了 <code>s1 = s[i : i + n * n2)</code>，并且记录了该子串与串联子串相差多少个 word，记该状态为 <code>state1</code>。那么，当我们考察 <code>s2 = s[i + n2 : i + n * (n2 + 1))</code> 时，<code>s2</code> 比 <code>s1</code> 少一个子串 <code>s[i : i + n2)</code>，多一个子串 <code>s[i + n * n2: i + n * (n2 + 1))</code>，且这两个子串的长度都与 word 的长度相同。那么，我们就<strong>很容易根据 <code>state1</code> 以及这两个引起变化的子串</strong>求出 <code>s2</code> 距离达成串联子串相差多少个 word，即<strong>求出状态 <code>state2</code></strong>。</p>
<p>让我们举个例子，假设 <code>words = [&quot;ab&quot;,&quot;cd&quot;,&quot;ef&quot;]</code>，<code>s = &quot;ggcdabef&quot;</code>。则此时 <code>n = 3</code>，<code>n2 = 2</code>。</p>
<p>令 <code>s1 = s[0: 6) = &quot;ggcdab&quot;</code>，此时 <code>s1</code> 距离达成串联子串的条件多出一个 word <code>gg</code>，少了一个 word <code>ef</code> —— 该状态为 <code>state1</code>。当我们考察 <code>s2 = s[0 + 2, 6 + 2) = &quot;cdabef&quot;</code> 时，<code>s2</code> 比 <code>s1</code> 少一个子串 <code>gg</code>，多一个子串 <code>ed</code>。<strong>将 <code>s2</code> 相对于 <code>s1</code> 的变化应用到 <code>state1</code> 上</strong>，我们得到 <code>state2</code>：<code>s2</code> 达成了串联子串的条件 —— 使用了 <code>words</code> 中所有的单词，不多也不少。</p>
<p>为什么 <code>s1</code> 到 <code>s2</code> 要移动 <code>n2</code> 距离？—— 因为串联子串是 <code>words</code> 的排列，而 <code>words[i].length</code> 为 <code>n2</code>， 不移动 <code>n2</code> 距离，没法复用结果。</p>
<p>回到这道题本身，我们想要求出所有串联子串的开始索引。一共有多少个初始状态？—— <code>n2</code> 个：<code>s[0: n * n2)</code>，<code>s[1: n * n2 + 1)</code>，……，<code>s[n2 - 1: n * (n2 + 1) - 1)</code>。之后的所有长度为 <code>n2 * n</code> 的子串都可以从这些初始状态中求出。</p>
<p>下面的问题，就是如何高效地记录状态、并实现状态转移，让我们结合代码来解决这一问题。</p>
<h1 id="代码">代码</h1>
<p>考虑到 <code>words</code> 中可能有重复的 word，我们使用 Map 而不是 Set 来计数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">unordered_map&lt;string, <span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="keyword">for</span> (string &amp; w : words) &#123;</span><br><span class="line">    mp[w]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们定义两个 <code>vector</code>，注意观察它们的构造器：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(n2, mp.size())</span></span>;</span><br><span class="line">vector&lt;unordered_map&lt;string, <span class="type">int</span>&gt;&gt; <span class="built_in">v2</span>(n2, mp);</span><br></pre></td></tr></table></figure>
<p><code>v2</code> 中的每个哈希表记录的是『形成串联子串的 word 的计数情况（即初始的 <code>mp</code>）』与『长度为 <code>n2 * n</code> 的子串中 word 的计数情况』的差值。</p>
<p><code>v1</code> 记录的是对应哈希表中 value 不为 <code>0</code> 的数量。换句话说，如果 <code>v1</code> 中某元素为 <code>0</code>，则此时对应的 长度为 <code>n2 * n</code> 的子串是一个串联子串。<code>v1</code> 的存在就是为了<strong>快速判断</strong>是否满足串联子串的条件。</p>
<p>我们以构造初始状态为例，观察这两个 <code>vector</code> 是如何工作的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n2; ++i) &#123;</span><br><span class="line">  	<span class="comment">// 判断子串 s[i : i + n * n2) 的状态</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">        string s2 = s.<span class="built_in">substr</span>(i + n2 * j, n2); <span class="comment">// 获得第一个长度为 n2 的子串 s2</span></span><br><span class="line">        <span class="type">int</span> v = --v2[i][s2]; <span class="comment">// 修改计数情况</span></span><br><span class="line">        <span class="comment">// 如果 v2[i][s2] &gt; 0，则距离形成串联子串还**缺少** v2[i][s2] 个 s2</span></span><br><span class="line">        <span class="comment">// 如果 v2[i][s2] &lt; 0，则距离形成串联子串还**多出** v2[i][s2] 个 s2</span></span><br><span class="line">        <span class="comment">// 由于在构造初始状态时， v2[i][s2] 只可能减小</span></span><br><span class="line">        <span class="keyword">if</span> (v == <span class="number">0</span>) v1[i]--; <span class="comment">// 所以当 v2[i][s2] 为 0 时，v1[i] 要减一</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (v == <span class="number">-1</span>) v1[i]++; <span class="comment">// 但是当 v2[i][s2] 首次小于 0 时，v1[i] 反而要加一，因为此时来自子串的 word 反而变得多余了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (v1[i] == <span class="number">0</span>) &#123; <span class="comment">// 此时达成了串联子串的条件，记录到结果集中</span></span><br><span class="line">        ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后，我们要不断地对初始状态做状态转移，其过程与构造初始状态类似，只不过多出了添加 word 的情况：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n2; i + n2 * n &lt;= s.<span class="built_in">size</span>(); ++i) &#123; <span class="comment">// 注意循环中止条件</span></span><br><span class="line">    <span class="comment">// 注意 v2 的定义，这里要做加一操作</span></span><br><span class="line">    string oldStr = s.<span class="built_in">substr</span>(i - n2, n2);</span><br><span class="line">    <span class="type">int</span> v = ++v2[i % n2][oldStr]; <span class="comment">// 别忘了对 n2 取模</span></span><br><span class="line">    <span class="keyword">if</span> (v == <span class="number">0</span>) v1[i % n2]--;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v == <span class="number">1</span>) v1[i % n2]++;</span><br><span class="line"></span><br><span class="line">    string newStr = s.<span class="built_in">substr</span>(i + n2 * (n - <span class="number">1</span>), n2);</span><br><span class="line">    v = --v2[i % n2][newStr];</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="number">0</span>) v1[i % n2]--;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v == <span class="number">-1</span>) v1[i % n2]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (v1[i % n2] == <span class="number">0</span>) &#123; <span class="comment">// 此时达成了串联子串的条件，记录到结果集中</span></span><br><span class="line">        ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，最终的代码是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findSubstring</span><span class="params">(string s, vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = words.<span class="built_in">size</span>(), n2 = words[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        unordered_map&lt;string, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span> (string &amp; w : words) &#123;</span><br><span class="line">            mp[w]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(n2, mp.size())</span></span>;</span><br><span class="line">        vector&lt;unordered_map&lt;string, <span class="type">int</span>&gt;&gt; <span class="built_in">v2</span>(n2, mp);</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() &lt; n * n2) &#123; <span class="comment">// 唯一一个 corner case</span></span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n2; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                string s2 = s.<span class="built_in">substr</span>(i + n2 * j, n2);</span><br><span class="line">                <span class="type">int</span> v = --v2[i][s2];</span><br><span class="line">                <span class="keyword">if</span> (v == <span class="number">0</span>) v1[i]--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (v == <span class="number">-1</span>) v1[i]++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (v1[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n2; i + n2 * n &lt;= s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            string oldStr = s.<span class="built_in">substr</span>(i - n2, n2);</span><br><span class="line">            <span class="type">int</span> v = ++v2[i % n2][oldStr];</span><br><span class="line">            <span class="keyword">if</span> (v == <span class="number">0</span>) v1[i % n2]--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (v == <span class="number">1</span>) v1[i % n2]++;</span><br><span class="line"></span><br><span class="line">            string newStr = s.<span class="built_in">substr</span>(i + n2 * (n - <span class="number">1</span>), n2);</span><br><span class="line">            v = --v2[i % n2][newStr];</span><br><span class="line">            <span class="keyword">if</span> (v == <span class="number">0</span>) v1[i % n2]--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (v == <span class="number">-1</span>) v1[i % n2]++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (v1[i % n2] == <span class="number">0</span>) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<code>O(n * n2 * n2 + s.size() * n2)</code>。</p>
<p>空间复杂度：<code>O(n * n2 * n2)</code>，主要是 <code>v2</code> 的开销。</p>
<p>注意到，一个 word 长度为 <code>n2</code>，因此其空间开销是 <code>O(n2)</code>，而从 <code>s</code> 中获取一个 word 的时间开销也是 <code>O(n2)</code>。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>滑动窗口</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>Azure Pipelines 架构解析</title>
    <url>/2023/10/06/Azure-Pipelines-Architecture/</url>
    <content><![CDATA[<h1 id="介绍">介绍</h1>
<p>Azure Pipelines 是 Azure DevOps（SaaS 平台）的一个组件，是一个自动化 CI/CD 的“流水线”。类似的技术有<a href="https://github.com/features/actions">GitHub Actions</a> 和 <a href="https://www.jenkins.io/">Jenkins</a>。</p>
<p>作为使用者，我们只需要在 YAML 中定义各个任务，触发 Pipeline，Azure Pipelines 就能帮我们自动执行这些任务。</p>
<p>那么，任务是怎么被执行的呢？是否存在并行任务上限？我们怎样设计更高效地定义 YAML，从而让一次 Pipeline 更快地跑完呢？—— 本文将从任务调度的角度，解析 Azure Pipelines 的架构。在探讨的过程中，上述问题自然能得到解答。</p>
<span id="more"></span>
<h1 id="Azure-Pipelines-术语">Azure Pipelines 术语</h1>
<p><img src="./MDImgs/Azure-Pipelines-Architecture/key-pipeline-concepts-overview-ca80c85c.png" alt="img"></p>
<p><strong>对于 Azure Pipelines 的使用者</strong>，一个 YAML 文件唯一定义了一条 Pipeline 的运行逻辑：</p>
<ul>
<li>一条 Pipeline 可以包含多个 Stage</li>
<li>一个 Stage 可以包含多个 Job</li>
<li>一个 Job 可以包含多个 Step</li>
<li>一个 Step 可以包含多个 task</li>
</ul>
<p><strong>对于 Azure Pipelines 本身</strong>，当一条 Pipeline 被触发，它需要调用计算资源，去执行 Pipeline 的逻辑。具体来说，会有一台机器（agent）负责执行一个 job。</p>
<p>一个 job 只会在一台 agent 上跑，它不会被进一步地拆分。而一条 Pipeline 的所有 job 可能会分配给不同的 agent 去执行。</p>
<p>这种分配是如何完成的呢？</p>
<h1 id="Azure-Pipelines-任务调度">Azure Pipelines 任务调度</h1>
<p>Azure Pipelines 的任务调度是一种典型的分布式任务调度模型（类似的技术有<a href="http://www.quartz-scheduler.org/">QUARTZ</a> 和 <a href="https://github.com/xuxueli/xxl-job">xxl-job</a>）：</p>
<ul>
<li>Azure Pipelines 上有一个**『任务队列』**，里面存放着所有待运行的 <u>job</u>（既指任务调度模型中的 Job/Task，又指 Pipeline 中的 job 术语）</li>
<li>Agent 是 Worker，它会定时地查看**『任务队列』**中是否有 job 要运行。如果有，则某一台 Agent 会竞争获得执行该 Job 的权利，同时获得访问相应资源的权限。此时，它就可以开始执行这个 job 了。</li>
</ul>
<p>因此，一条 Pipeline 是这样执行的：</p>
<ol>
<li>触发 Pipeline。Azure Pipelines 解析 YAML，拆分为多个 Job，存入『任务队列』中。</li>
<li>假如此时有空闲的 Agent，说明『任务队列』此时为空。那么，它监听到了任务队列中加入新 job 后，开始与其他 Agent（假如有的话）竞争执行该 job。
<ul>
<li>竞争成功，开始执行；</li>
<li>竞争失败，继续监听；</li>
</ul>
</li>
<li>假如此时没有空闲的 Agent，则说明『任务队列』之前已经有 job 了，或者没有 Agent 跑完自己之前领取的 job。那么这些新产生的 job 就会有序地等待 Agent 来执行。（job 按照 Pipeline 触发的时间来排队等待，因此是公平的）</li>
</ol>
<h1 id="Parallel-Jobs">Parallel Jobs</h1>
<p>任务调度框架意味着<strong>并行（parallel）</strong>。这也意味着，我们在定义 YAML 时，<strong>应该将没有依赖的 Steps 或 Tasks 提升为 Jobs，使得它们能够并行执行，缩短运行时间</strong>。</p>
<blockquote>
<p>在实习过程中，却鲜有人这样做，大家都用着默认的 Steps 级别，即使大部分 Agents 经常是空闲的。🤔</p>
</blockquote>
<p>那么，既然一个新 job 能否立刻执行取决于空闲 Agent 的存在，增加 Agent 的数量是否就能提高整体的吞吐量（单位时间内执行完成的 job 数量）呢？—— 很遗憾，并不是。</p>
<p>微软毕竟要靠 Azure 盈利的，他们又提出了 『Parallel Jobs』这个概念，表示能并行执行的 job 上限。这个量是需要购买的。</p>
<p>也就是说，如果想并行跑 job，我们不仅需要购买 Azure VM agents，还需要购买 Parallel Jobs。即使我们自己有很多台机器，也还是需要购买 Parallel Jobs。</p>
<h1 id="参考链接">参考链接</h1>
<ul>
<li><a href="https://learn.microsoft.com/en-us/training/modules/explore-azure-pipelines/3-describe-azure-pipelines">Describe Azure Pipelines</a></li>
<li><a href="https://learn.microsoft.com/en-us/training/modules/explore-azure-pipelines/4-understand-key-terms">Understand Azure Pipelines key terms</a></li>
<li><a href="https://learn.microsoft.com/en-us/training/modules/manage-azure-pipeline-agents-pools/7-communicate-with-azure-pipelines">Communicate with Azure Pipelines</a></li>
<li><a href="https://azure.microsoft.com/en-us/products/devops/pipelines#overview">Azure Pipelines 产品介绍</a></li>
<li><a href="https://learn.microsoft.com/en-us/azure/devops/pipelines/agents/agents">Azure Pipelines agents</a></li>
</ul>
]]></content>
      <categories>
        <category>tech</category>
        <category>Azure</category>
      </categories>
      <tags>
        <tag>Azure</tag>
        <tag>Azure Pipelines</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>ChangeDetection 安装和使用</title>
    <url>/2024/10/02/ChangeDetection-install-and-usage/</url>
    <content><![CDATA[<h1 id="序言">序言</h1>
<p>最近在等待某个网站上的通知，于是时不时打开网站看一眼。后来觉得太麻烦了，准备写个爬虫自动监测。又发现网上有很多现成的平台（于是懒得写代码了），但是它们的免费方案都只包括监控静态网页，想要处理 JSON 要付费，因此开始寻找开源替代方案。于是，就有了本文的主题 —— <a href="https://github.com/dgtlmoon/changedetection.io">ChangeDetection</a>。</p>
<p>ChangeDetection 有两个功能：监控 URL 内容变化；通知这些变化。这两个功能足以覆盖大部分日常场景。</p>
<span id="more"></span>
<h1 id="Docker-compose">Docker compose</h1>
<p>ChangeDetection 最基本的配置如下，有一个端口映射、一个容器卷即可。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">changedetection:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">dgtlmoon/changedetection.io:0.46.04</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">changedetection</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">55000</span><span class="string">:5000</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">changedetection-data:/datastore</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">changedetection-data:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<hr>
<p>ChangeDetection 也提供可视化界面，让不懂编程的用户可以像使用浏览器那样选择要监控的内容。其中：</p>
<ul>
<li>Browser Steps 功能可以记录一系列操作；</li>
<li>Visual Filter Selector 功能可以选择网页的某一部分；</li>
</ul>
<p>这些实际上是底层的 Playwright 提供的功能，因此需要 WebDriver。<a href="https://github.com/dgtlmoon/changedetection.io/blob/master/docker-compose.yml">官方提供的 docker compose</a> 中有具体的配置，需要启动一个额外的 Chrome 容器给 Playwright 使用。我没有这个需求，就不配置了。</p>
<hr>
<p>如果监控某一网站的频率很高，建议加一个代理，防止自己的 IP 被封、导致干不了正事了。</p>
<h1 id="使用">使用</h1>
<p>ChangeDetection 的使用很简单，因为页面上一共也没几个按钮。</p>
<h2 id="Filter">Filter</h2>
<p>『Filters &amp; Triggers』一栏是我们要重点关注的，在这里进行数据清洗。过滤器种类很多，我主要使用 CSS 和 JQ。具体的规则建议让 GPT 来写。</p>
<h2 id="邮件通知">邮件通知</h2>
<p>在 『Settings | Notifications』 中可以配置通知服务。我目前使用邮箱来通知，其原理就是自己给自己发一封邮件。规则如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mailto://&#123;user&#125;:&#123;password&#125;@qq.com</span><br></pre></td></tr></table></figure>
<p>需要注意的是，不同邮箱的 <code>password</code> 不同。Gmail 的就是邮箱的登录密码，而 QQ 的要在『账号与安全 | 安全设置 』生成一个授权码（类似于 API TOKEN）。</p>
<p>邮件的内容使用的是 Jinja2 模板，修改方便。</p>
<p>配置完毕后，测试一下是否可用。</p>
<h1 id="参考">参考</h1>
<ul>
<li><a href="https://github.com/dgtlmoon/changedetection.io/wiki/Notification-configuration-notes">ChangeDetection doc: Notification configuration notes</a></li>
</ul>
]]></content>
      <categories>
        <category>tech</category>
        <category>NAS</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>NAS</tag>
        <tag>Docker</tag>
        <tag>ChangeDetection</tag>
      </tags>
  </entry>
  <entry>
    <title>Dashy 安装与配置</title>
    <url>/2024/04/04/Dashy-install-and-config/</url>
    <content><![CDATA[<h1 id="序言">序言</h1>
<p><a href="https://github.com/Lissy93/dashy">Dashy</a> 是一个开源的个性化 dashboard 软件，需要自主部署。我的使用场景是放置常用网站的链接。这篇博文主要记录安装和使用时遇到的一些问题。</p>
<blockquote>
<p>dashboard 翻译为仪表盘？我总觉得有点奇怪🤔</p>
</blockquote>
<h1 id="安装">安装</h1>
<span id="more"></span>
<p>Docker compose：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">dashy:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">lissy93/dashy:2.1.2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">dashy</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/opt/docker/dashy/conf.yml:/app/public/conf.yml</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/opt/docker/dashy/dashboard-icons:/app/public/item-icons</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">bridge</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">54000</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> [<span class="string">&#x27;CMD&#x27;</span>, <span class="string">&#x27;node&#x27;</span>, <span class="string">&#x27;/app/services/healthcheck&#x27;</span>]</span><br><span class="line">      <span class="attr">interval:</span> <span class="string">1m30s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">10s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">start_period:</span> <span class="string">40s</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>config.yml</code> 是核心配置文件。我喜欢直接修改配置文件，而不是用 UI 改了、再保存到文件。</li>
</ul>
<h1 id="设置图标">设置图标</h1>
<p>图标的种类很多，我常用的是『本地图标』、『<a href="https://fontawesome.com/search">Font Awesome</a>』和 『<a href="https://simpleicons.org/">Simple Icons</a>』。</p>
<h2 id="本地图标">本地图标</h2>
<p>本地图标就是本地图片，文件名后缀可以是 <code>png</code> 和 <code>svg</code>，但不能是 <code>ico</code>。</p>
<p>本地图标<strong>必须</strong>放在 <code>/app/public/item-icons/</code> 下，Dashy <strong>只能</strong>识别这个目录下的<strong>相对路径</strong>。在 docker compose 中，我将本机的 <code>/opt/docker/dashy/dashboard-icons</code> 映射到上述目录。这个本地目录是 <a href="https://github.com/walkxcode/dashboard-icons">dashboard-icons</a> 项目的克隆。</p>
<p>dashboard-icons 项目中的图标都是一些常用的软件，但完全没有国内软件的图标。当然，我们也可以自己下载图标，放在这个目录中。</p>
<p>由于这里面都是彩色图片，而后面两种图标都是黑白的，<strong>我优先选择这种方式</strong>。</p>
<p>一些例子：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dashboard-icons 项目中的图标</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">icon:</span> <span class="string">svg/portainer.svg</span></span><br><span class="line"><span class="comment"># downloaded 文件夹存放自己下载的图标</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">icon:</span> <span class="string">downloaded/AutoBangumi.svg</span></span><br></pre></td></tr></table></figure>
<h2 id="Font-Awesome">Font Awesome</h2>
<p>命名规则：<code>[category] [name]</code></p>
<p>例子：<code>fas fa-rocket</code>, <code>fab fa-monero</code></p>
<p>以 envelope 为例：</p>
<p>在 HTML 代码中，<code>name</code> 为 <code>fa-envelope</code>，但是 <code>category</code> 需要我们自己简写为 <code>far</code>。</p>
<p><img src="./MDImgs/Dashy-install-and-config/image-20240404105243668.png" alt="image-20240404105243668"></p>
<p>在 VUE 代码中，<code>category</code> 是对的，但是 <code>name</code> 又不对了。</p>
<p><img src="./MDImgs/Dashy-install-and-config/image-20240404105359193.png" alt="image-20240404105359193"></p>
<p>不太清楚哪里可以直接复制粘贴。</p>
<p>如果要使用 pro 图标，需要在 <code>appConfig.fontAwesomeKey</code> 中配置 license key，通常是长度为 10 的字符串。</p>
<h2 id="Simple-Icons">Simple Icons</h2>
<p>这个网站的图标也是常用软件，但包括国内软件。</p>
<p>命名规则：<code>si-[name]</code></p>
<p>例子：<code>si-googlechrome</code>、<code>si-bilibili</code></p>
<p>这里的 <code>name</code> 可以直接从官网拷贝（点击文字，就会自动拷贝）：</p>
<p><img src="./MDImgs/Dashy-install-and-config/image-20240404110008224.png" alt="image-20240404110008224"><img src="./MDImgs/Dashy-install-and-config/image-20240404110022088.png" alt="image-20240404110022088"></p>
<p>点击 『.NET』 复制到的是 <code>dotnet</code>，而点击 『365 Data Science』 复制到的是 <code>365datascience</code>。可见，不要自己手动输入，容易出错。</p>
<h2 id="效果展示">效果展示</h2>
<p><img src="./MDImgs/Dashy-install-and-config/image-20240404110533178.png" alt="image-20240404110533178"></p>
<h1 id="参考">参考</h1>
<ul>
<li><a href="https://github.com/Lissy93/dashy">Dashy</a></li>
</ul>
]]></content>
      <categories>
        <category>tech</category>
        <category>NAS</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>NAS</tag>
        <tag>Docker</tag>
        <tag>Dashy</tag>
      </tags>
  </entry>
  <entry>
    <title>开发随笔 1</title>
    <url>/2025/06/04/Developer-Diary-1/</url>
    <content><![CDATA[<h1 id="序言">序言</h1>
<p>最近自学了很多课程，并且在开发很多项目，因此没有写博文。鉴于博客要经常更新，我决定写另一种形式的博文——开发随笔——来记录开发过程中的所见所思。本文包含以下内容：选择第三方库、Go、八股文。</p>
<span id="more"></span>
<h1 id="选择第三方库">选择第三方库</h1>
<p>为了让项目实现某项功能，我们通常选择现有的第三方库，避免重复造轮子。当有很多第三方库时，我们常常会陷入选择困难，不知道选哪个好。我总结了自己在选择第三方库时的一些考虑（要素不分先后，要综合考虑）：</p>
<ul>
<li>开源：通常来说，开源 &gt;&gt; 闭源，但是也不绝对。一些不怎么更新的开源库可能不再适配，亦或是被提交恶意代码。闭源的商业产品可能非常优秀，且价格合适，性价比很高，相比开源产品能够节省大量时间。</li>
<li>Star 数量：这个指标非常有迷惑性。一方面，我们倾向于认为有最多 Stars 的就是最好的，统计数据的确可以印证这一点。另一方面，一个库的 Star 数量高可能来自于非技术性的原因，比如作者更会宣传、人为买 Stars。</li>
<li>功能：该库是否包含我们需要的功能？它提供的选项是否完备、丰富？是否存在很多提 bug 的 Issue？</li>
<li>文档：文档是否详细、全面、及时更新、能看得懂？</li>
<li>活跃度：从提交频率、Issue close 频率、PR merge/reject 频率、发布频率等多方面判断。</li>
<li>安全性：是否被曝出过重大安全漏洞？</li>
<li>可持续性：作者未来是否会继续开发这个库？除非作者明确写了不再准备支持、或是这个库进入维护阶段，需要从其他的方面来推测该方面，比如作者其他的库。</li>
<li>第三方平台上的评价：参考 Reddit、Stack Overflow、B 站等平台对这个库的讨论。注意区分利益相关者、网络水军等不公正的评价。</li>
<li>相关新闻：正面或是负面的都可以作为参考，甚至可以搜索作者的相关新闻。</li>
<li>政治内容：包含政治内容的一律不用。</li>
</ul>
<p>以上方面或多或少包含在“生态”和“社区”这两个词中，但是我不想使用大概念而是想尽可能具体地描述。</p>
<h1 id="Go">Go</h1>
<p>MIT 6.824 需要使用 Go 语言写项目，于是我开始学习 Go。两年前我曾接触过 Go，觉得这门语言很“抽象”。而在学习了 JS 和一些前端库后，我对于 Go 的印象发生了改变。</p>
<p>Go 的很多理念与 JS 类似，比如函数是一等公民、没有原生的面向对象支持。之前我只熟悉 Java ，所以对于 Go 的这套理念感觉莫名其妙，仿佛只有 Go 特例独行。在深入学习了 JS 后，觉得这些理念很好接受。</p>
<p>另一个曾经让我觉得 Go 很奇怪、难以接受的是它的语法及其背后的设计理念。Go 在语法上几乎不允许任何的 alternative：有了 <code>for</code>，就不允许有 <code>while</code> 和 <code>do-while</code>；既然有 <code>if</code>，那么三元运算符 <code>bool ? v1 : v2</code> 就没必要存在了。当然，我当时也理解这么做的好处 —— 在语言层面就让所有开发者遵守同一套规范。但是我始终有些难以接受：Go 是否太专制了？</p>
<p>让我们先看看别的语言是怎么做的。Spring Boot 的设计原则是“约定大于配置”，提供了很多开箱即用的功能。我们只有遵循这些约定才能快速开发，否则得手动配置。但是，Spring Boot 至少提供了自由配置的余地，我们完全可以不遵守默认配置，搞一套我们自己的规则。与之不同，Redux Toolkit、Next.js 非常 opinionated（固执己见的、顽固的），我们必须遵守它们的约定/规则，几乎没有配置的余地（就算可以配置，也极其麻烦）。</p>
<p>再回到 Go，由于学过了 RTK、Next.js，我现在对于其语法的唯一性可以接受了：Go 是一款 opinionated 的编程语言。注意，opinionated 不见得是坏事，就像第三方库太多导致的选择困难症，有大厂背书的编程规则反而减轻了我们花费在对比不同方案上的时间成本，提高了效率。</p>
<p>从这两方面可以看出，多学点东西总是有好处的，可以培养自己的技术积累，也更能接受新技术。</p>
<h1 id="八股文">八股文</h1>
<p>什么是八股文？DeepSeek 的回答如下：</p>
<blockquote>
<p>在计算机领域，“<strong>八股文</strong>” 这个词是一个<strong>带有贬义的比喻</strong>，它指的是那些<strong>僵化、套路化、脱离实际、过分注重形式而忽视实质内容</strong>的知识点、答题方式或面试风格。</p>
<p><strong>面试八股文：</strong> 指那些在技术面试中被反复问到、要求候选人必须准确背诵的标准答案式问题。</p>
</blockquote>
<p>的确，谈到八股，很多人都是负面评价，但是又不得不背，不然无法通过技术面试。值得注意的是，这些问题本身并没有错，相反，它们是理解某一个领域很好的入口，因为大部分都是基础性、底层性的问题。</p>
<p>注意，我说的好的八股文是作者精心整理后的，比如小林 coding，而不是随便在网上抄一抄就发一篇博文的。后者在网上一搜一大把，且内容同质化严重。</p>
<p>引起我对于八股文态度反思的是我在项目中使用 SQLite 事务。由于我不熟悉 SQLite 事务模型和并发模型，我担心产生死锁，便上网查找相关文档。国内有用的资料不多，一些有用的资料也存在大量重复，让我怀疑其真实性。而官方文档我没太看明白。最终，我通过 LLM 解决了疑惑，但是没有对于 SQLite 的整体架构有深入了解。</p>
<p>你可能会问：为什么我不直接问 LLM 呢？答案是：如果网上不存在有价值的 SQLite 资料，LLM 是如何训练得能够准确回答 SQLite 的问题的呢？它难道不会产生幻觉，给我一个错误答案吗？之前我问 WPF 相关问题时就碰到过幻觉。</p>
<p>与之相对，MySQL 的八股文到处都是。我们既可以自己看，也可以相对放心地让 LLM 替我们总结。这也是为什么我期待网上有 SQLite 的八股文可供参考。</p>
<p>最后，抛开“八股文”这个贬义的称呼不谈，秉持凡是“能够帮我们扩展一个逻辑的边界的问题，就是好问题”的理念，在我们学会使用一个技术后、想要深入钻研时，八股文以 FAQ 的形式为我们提供了一条有别于官方文档和读源码的道路，这是一件好事。况且不少人还靠着八股文拿到了 offer，没必要过河拆桥。</p>
]]></content>
      <categories>
        <category>开发随笔</category>
      </categories>
      <tags>
        <tag>开发随笔</tag>
        <tag>Go</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>如何访问 Docker 容器？IP 地址还是容器名？</title>
    <url>/2024/06/11/Docker-Accessing-Containers-IP-or-Container-Name/</url>
    <content><![CDATA[<h1 id="序言">序言</h1>
<p>本文包括了多种访问 Docker 容器的情况，探讨了每种情况应该使用容器的 IP 地址还是容器名。本文的内容对于熟练使用 Docker 的人不值一提，但在实践中，我常常忘记这些基本概念，浪费了不少时间。因此，我决定以 cheat sheet 的形式写一篇博文。本文的大部分内容由 ChatGPT 生成的。</p>
<p>总的来说，记住以下两点就够了：</p>
<ul>
<li>尽管我们喜欢用容器名访问容器，但这个 DNS 服务是由 docker 提供的，因此<strong>只能被容器使用</strong>。</li>
<li>对于端口映射 <code>-p 8080:80</code> ：用容器名/容器 IP 访问容器时，用容器的端口 <code>80</code>；用主机访问容器时，用主机的端口 <code>8080</code>。</li>
</ul>
<span id="more"></span>
<h1 id="从容器中访问目标容器">从容器中访问目标容器</h1>
<p>此时要区分两个容器是否在一个 docker network 中。</p>
<h2 id="两者在同一个网络中">两者在同一个网络中</h2>
<p>情况一：两个容器属于同一个 Compose</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mywebapp</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080:80&quot;</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql</span></span><br></pre></td></tr></table></figure>
<p>情况二：创建容器时使用 <code>--network</code> 选项使两个容器在一个网络中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker network create my_network</span><br><span class="line">docker run -d --name web --network my_network mywebapp</span><br><span class="line">docker run -d --name db --network my_network mysql</span><br></pre></td></tr></table></figure>
<p>两种情况下，都可以通过容器名访问（使用容器端口）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl http://web:80</span><br></pre></td></tr></table></figure>
<p><strong>注意，如果目标容器在 bridge 网络中，则不属于这种情况。需要通过 IP 访问。</strong></p>
<h2 id="两者不在同一个网络中">两者不在同一个网络中</h2>
<p>需要使用目标容器的 IP。</p>
<p>首先获得容器 IP，然后通过 IP 访问：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CONTAINER_IP=$(docker inspect -f &#x27;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27; 容器)</span><br><span class="line">curl http://$CONTAINER_IP:80</span><br></pre></td></tr></table></figure>
<h1 id="从本地主机访问目标容器">从本地主机访问目标容器</h1>
<p>有两种方式：</p>
<p>一、通过容器 IP 访问。</p>
<p>二、使用本地端口访问：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl http://localhost:8080</span><br></pre></td></tr></table></figure>
<p>注意，这里是本机端口，不再是容器端口。</p>
<h1 id="从外部主机访问目标容器">从外部主机访问目标容器</h1>
<p>使用本地主机的 IP 访问：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl http://host_ip:8080</span><br></pre></td></tr></table></figure>
<h1 id="参考">参考</h1>
<ul>
<li>ChatGPT</li>
</ul>
]]></content>
      <categories>
        <category>tech</category>
        <category>Docker</category>
        <category>cheat sheet</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker: healthcheck 和 depends_on</title>
    <url>/2024/06/03/Docker-Healthcheck/</url>
    <content><![CDATA[<h1 id="序言">序言</h1>
<p>本文主要包括 Docker healthcheck 的机制、语法，以及 Docker compose 的 <code>depends_on</code> 机制、语法。本文可以视作一个 cheat sheet。</p>
<h1 id="healthcheck-机制">healthcheck 机制</h1>
<blockquote>
<p>When a container has a healthcheck specified, it has a health status <strong>in addition to its normal status.</strong> This status is <strong>initially <code>starting</code></strong>. Whenever a <strong>health check passes</strong>, it becomes <strong><code>healthy</code></strong> (whatever state it was previously in). After a certain number of <strong>consecutive failures</strong>, it becomes <strong><code>unhealthy</code></strong>.</p>
</blockquote>
<span id="more"></span>
<p>healthcheck 有如下参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>--interval=DURATION</code></td>
<td><code>30s</code></td>
<td>间隔多久执行一次 healthcheck。</td>
</tr>
<tr>
<td><code>--timeout=DURATION</code></td>
<td><code>30s</code></td>
<td>每一次 healthcheck 最多执行多久。如果超过该时间，视为失败。</td>
</tr>
<tr>
<td><code>--retries=N</code></td>
<td><code>3</code></td>
<td>如果连续 <code>retries</code> 次失败，则容器状态变为 <code>unhealthy</code>。</td>
</tr>
<tr>
<td><code>--start-period=DURATION</code></td>
<td><code>0s</code></td>
<td>在这段时间内，如果 healthcheck 失败了，不会记录到累计 <code>retries</code> 次数中。但是，只要 healthcheck 成功了，容器视作启动成功，start period 自动结束。</td>
</tr>
<tr>
<td><code>--start-interval=DURATION</code></td>
<td><code>5s</code></td>
<td>在 start period 内，间隔多久执行一次 healthcheck。</td>
</tr>
</tbody>
</table>
<p>容器启动后，它处于 <code>starting</code> 状态，也就是处于 start period。start period 内，容器只可能变为 <code>healthy</code> 状态，不可能变为 <code>unhealthy</code> 状态。</p>
<h1 id="healthcheck-语法">healthcheck 语法</h1>
<h2 id="语法">语法</h2>
<blockquote>
<p>本文不考虑 dockerfile 和 cli 中的语法，只考虑 compose 中的语法。</p>
</blockquote>
<p>compose 内的 healthcheck 会覆盖 dockerfile 中的 healthcheck 。</p>
<p>例子：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">healthcheck:</span></span><br><span class="line">  <span class="attr">test:</span> <span class="string">curl</span> <span class="string">-f</span> <span class="string">https://localhost</span> <span class="string">||</span> <span class="string">exit</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">interval:</span> <span class="string">1m30s</span></span><br><span class="line">  <span class="attr">timeout:</span> <span class="string">10s</span></span><br><span class="line">  <span class="attr">retries:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">start_period:</span> <span class="string">40s</span></span><br><span class="line">  <span class="attr">start_interval:</span> <span class="string">5s</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>test</code> defines the command Compose runs to check container health. It can be <strong>either a string or a list</strong>.</p>
<p>If it’s a list, the first item must be either <code>NONE</code>, <code>CMD</code> or <code>CMD-SHELL</code>.</p>
<p>If it’s a string, it’s equivalent to specifying <code>CMD-SHELL</code> followed by that string.</p>
</blockquote>
<p>以下两种形式等价：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">test:</span> [<span class="string">&quot;CMD-SHELL&quot;</span>, <span class="string">&quot;curl -f http://localhost || exit 1&quot;</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">test:</span> <span class="string">curl</span> <span class="string">-f</span> <span class="string">https://localhost</span> <span class="string">||</span> <span class="string">exit</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>显然，第二种更方便。</p>
<h2 id="debug-test-命令">debug <code>test</code> 命令</h2>
<p>常用的 <code>test</code> 命令模板见<a href="/2024/04/12/MySQL-Docker/#healthcheck">之前的文章</a>。如何 debug 自己写的 <code>test</code> 命令？—— 使用 <code>docker inspect</code>。healthcheck 信息在 <code>State.Health</code> 中，可以直接用以下命令获得：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker inspect --format=<span class="string">&#x27;&#123;&#123;json .State.Health&#125;&#125;&#x27;</span> 容器</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;healthy&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;FailingStreak&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Log&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-06-02T13:45:22.110841425+08:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;End&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-06-02T13:45:22.178282083+08:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ExitCode&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Output&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mysqladmin: [Warning] Using a password on the command line interface can be insecure.\nmysqld is alive\n&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-06-02T13:45:27.208737778+08:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;End&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-06-02T13:45:27.261481813+08:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ExitCode&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Output&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mysqladmin: [Warning] Using a password on the command line interface can be insecure.\nmysqld is alive\n&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p><code>Log</code> 元素的属性的含义：</p>
<ul>
<li><code>Output</code> ：执行命令后的输出，用来 debug。</li>
<li><code>Exitcode</code>：<code>0</code> 表示容器健康，<code>1</code> 表示不健康。</li>
</ul>
<h2 id="禁用-healthcheck">禁用 healthcheck</h2>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">healthcheck:</span></span><br><span class="line">  <span class="attr">disable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h1 id="depends-on-机制">depends_on 机制</h1>
<blockquote>
<p>You can <strong>control the order of service startup and shutdown</strong> with the <code>depends_on</code> attribute. Compose always starts and stops containers in dependency order.</p>
<p>It is useful if services are closely coupled, and the startup sequence impacts the application’s functionality.</p>
</blockquote>
<p>要注意，<code>depends_on</code> 只是表示启动顺序，不代表先启动的容器准备好了。</p>
<blockquote>
<p>On startup, Compose <strong>does not wait until a container is “ready”, only until it’s running</strong>.</p>
</blockquote>
<p>通过设置 <code>depends_on</code> 的 <code>condition</code> 属性，可以指定依赖 A 的容器 B 何时启动。该属性有如下值：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>service_started</code></td>
<td>默认值，只要 A 启动了 B 就启动。</td>
</tr>
<tr>
<td><code>service_healthy</code></td>
<td>只有 A 变为 <code>healthy</code> 状态，B 才能启动。</td>
</tr>
<tr>
<td><code>service_completed_successfully</code></td>
<td>当 A 成功执行完它的 <code>command</code> 命令，B 才能启动。这里 A 通常用来执行一个命令/脚本（而不是作为一个服务），执行完毕后 A 停止。命令/脚本退出码为 0 表示成功。可以看这个<a href="https://stackoverflow.com/a/69612290/23172420">具体的例子</a>。</td>
</tr>
</tbody>
</table>
<p>因此，如果要求 compose 中作为服务启动的多个容器实现真正的有序启动，需要利用 healthcheck 机制，同时设置 <code>condition</code> 为 <code>service_healthy</code>。</p>
<hr>
<p>需要注意的是，利用 <code>depends_on</code> 只是在使用 <code>docker compose up|start</code> 启动时有效。如果容器的 <code>restart</code> 设置为 <code>unless-stopped</code> 或者 <code>always</code>，那么在服务器重启后，这些容器<strong>不会</strong>按照 <code>depends_on</code> 的顺序启动。</p>
<h1 id="depends-on-语法">depends_on 语法</h1>
<h2 id="简单配置">简单配置</h2>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres</span></span><br></pre></td></tr></table></figure>
<p>此时 <code>condition</code> 默认为 <code>service_started</code>。</p>
<h2 id="详细配置">详细配置</h2>
<p>这种配置可以指定 <code>condition</code>。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="attr">db:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">service_healthy</span></span><br><span class="line">      <span class="attr">redis:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">service_started</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres</span></span><br></pre></td></tr></table></figure>
<h1 id="参考">参考</h1>
<ul>
<li><a href="https://docs.docker.com/reference/dockerfile/#healthcheck">Dockerfile HEALTHCHECK</a></li>
<li><a href="https://docs.docker.com/compose/compose-file/05-services/#healthcheck">Docker compose healthcheck</a></li>
<li><a href="https://docs.docker.com/compose/startup-order/">Control startup and shutdown order in Compose</a></li>
<li><a href="https://stackoverflow.com/a/69612290/23172420">How to start service only when other service had completed?</a></li>
<li><a href="https://docs.docker.com/compose/compose-file/05-services/#depends_on">Docker compose depends_on</a></li>
</ul>
]]></content>
      <categories>
        <category>tech</category>
        <category>Docker</category>
        <category>cheat sheet</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Docker 中部署 Nginx，并在局域网配置 SSL 证书</title>
    <url>/2024/01/31/Docker-Nginx-SSL-Local-Network/</url>
    <content><![CDATA[<h1 id="序言">序言</h1>
<p>在上一篇博文里，我成功搭建了 LANraragi 服务器，并且分享给了家庭局域网内的其他设备。但是，又产生了新的问题：</p>
<ul>
<li>LANraragi 不需要登录就能访问其中的漫画；</li>
<li>就算 LANraragi 有登录的功能，用的也还是 HTTP 明文传输，相当于没有密码；</li>
</ul>
<p>这些问题的根源是：可以联网的手机、智能家居都和 LANraragi 服务器在一个局域网内，这些设备并不可信，可能有后门（“用户自愿传输隐私数据以改善服务”）。无论如何，上述问题亟需解决。</p>
<p>解决方案 —— Nginx：</p>
<ul>
<li>使用 Nginx 自带的 basic authentication，只有输入账号密码才能访问 URL；</li>
<li>利用 Nginx 的反向代理。只要给 Nginx 配置了 HTTPS，被代理的软件都可以使用加密传输；</li>
</ul>
<p>因此，重点在于 Nginx 的配置和 SSL 证书的配置。麻烦之处在于，我要给内网 IP 请求证书，并且这个 IP 没有对应的域名。这篇文章探讨了这些解决方案，同时也是我第一次接触 Nginx 和 SSL 证书的配置。</p>
<span id="more"></span>
<h1 id="Nginx-容器">Nginx 容器</h1>
<h2 id="拿到默认配置文件">拿到默认配置文件</h2>
<p>创建一个临时的容器，从里面复制 <code>nginx.conf</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run --name tmp-nginx-container -d nginx:1.24</span><br><span class="line">docker <span class="built_in">cp</span> tmp-nginx-container:/etc/nginx/nginx.conf /opt/nginx.conf</span><br><span class="line">docker <span class="built_in">rm</span> -f tmp-nginx-container</span><br></pre></td></tr></table></figure>
<h2 id="Docker-Compose">Docker Compose</h2>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.24</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/opt/docker/nginx/nginx.conf:/etc/nginx/nginx.conf:ro</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/opt/nginx_ssl:/etc/nginx/ssl/:ro</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">bridge</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">50443</span><span class="string">:443</span></span><br></pre></td></tr></table></figure>
<ul>
<li>除了配置文件，还要映射一个目录，存放 SSL 私钥和证书；</li>
<li>网络模式要选桥接，不然访问不了其他容器；</li>
<li>只映射了 <code>443</code> 端口，不准备开放 <code>80</code> 端口 ；</li>
</ul>
<h1 id="SSL-证书">SSL 证书</h1>
<h2 id="创建-CA">创建 CA</h2>
<p>创建 CA 密钥 <code>myCAPK.key</code> 和（自签名）证书 <code>myCACertificate.crt</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">openssl req -x509 -sha256 -nodes -days 3650 -newkey rsa:4096 -keyout myCAPK.key -out myCACertificate.crt</span><br></pre></td></tr></table></figure>
<p>用这个命令生成的私钥和证书可以直接作为 Nginx 的 SSL 配置。但是，如果一个新的服务器也需要配置 SSL 证书，那么我们就需要手动让客户端设备信任这个新的证书，很麻烦。</p>
<p>如果把这个证书用作 CA 证书，那么只要设备信任了这个证书，使用 CA 签字的所有其他证书就自动地被信任了。因此，设备上只要手动添加一次 CA 证书。</p>
<h2 id="查看证书信息">查看证书信息</h2>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">openssl x509 -text -noout -<span class="keyword">in</span> myCACertificate.crt</span><br></pre></td></tr></table></figure>
<h2 id="信任-CA">信任 CA</h2>
<p>这个 CA 证书是我们自己创建的，系统是肯定不认的，我们需要安装到系统中。</p>
<p>如果没有这一步，浏览器可以建立 HTTPS 连接，但会提示连接不安全。</p>
<h3 id="Windows">Windows</h3>
<p>控制面板 | internet 选项 | 内容 | 证书</p>
<p><img src="./MDImgs/Docker-Nginx-SSL-Local-Network/image-20240131172736021.png" alt="image-20240131172736021"></p>
<p>以根证书颁发机构的身份信任 CA</p>
<p><img src="./MDImgs/Docker-Nginx-SSL-Local-Network/image-20240131172831043.png" alt="image-20240131172831043"></p>
<h3 id="Android">Android</h3>
<p>不同系统安装证书的位置不一样，但基本的选项是一样的。这里以三星为例：</p>
<p>要么选 『CA 证书』，要么选 『VPN 和 app 用户证书』。不要选『WLAN 证书』，这个没用。</p>
<p><img src="./MDImgs/Docker-Nginx-SSL-Local-Network/Screenshot_20240201_113254_Settings.png" alt="Screenshot_20240201_113254_Settings"></p>
<h3 id="IOS">IOS</h3>
<blockquote>
<p>这里以 iPadOS 15.7 为例</p>
</blockquote>
<ol>
<li>
<p>打开 email，将 CA 证书作为附件发给自己；</p>
</li>
<li>
<p>用 Safari 浏览器登录邮箱，点击附件，选择“下载描述文件”（此时弹出提示，进入设置界面确认安装）；</p>
</li>
<li>
<p>进入设置，选择“安装描述文件”，输入锁屏密码；</p>
</li>
<li>
<p>设置 | 通用 | 关于本机 | 证书信任设置：开启完全信任</p>
<p><img src="./MDImgs/Docker-Nginx-SSL-Local-Network/IMG_2032.PNG" alt="IMG_2032"></p>
</li>
</ol>
<h2 id="创建服务器密钥">创建服务器密钥</h2>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">openssl genrsa -out nginx_server.key 4096</span><br></pre></td></tr></table></figure>
<h2 id="创建服务器-CSR（证书签名请求）">创建服务器 CSR（证书签名请求）</h2>
<p>创建 <code>openssl.cnf</code>，内容如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">authorityKeyIdentifier</span>=<span class="string">keyid,issuer</span></span><br><span class="line"><span class="attr">basicConstraints</span>=<span class="string">CA:FALSE</span></span><br><span class="line"><span class="attr">subjectAltName</span> = <span class="string">@alt_names</span></span><br><span class="line"><span class="attr">[alt_names]</span></span><br><span class="line"><span class="comment"># 虚拟机</span></span><br><span class="line"><span class="attr">DNS.1</span> = <span class="string">CentOS100</span></span><br><span class="line"><span class="attr">IP.1</span> = <span class="string">192.168.169.132</span></span><br><span class="line"><span class="comment"># 主机</span></span><br><span class="line"><span class="attr">IP.2</span> = <span class="string">192.168.0.105</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个文件的配置其实很复杂，但是对于这个案例，只需要这几个配置项。</p>
</blockquote>
<ul>
<li><code>DNS.x</code> 对应主机名/域名；</li>
<li><code>IP.x</code> 对应 IP 地址；</li>
</ul>
<blockquote>
<p><code>x</code> 都是正整数</p>
</blockquote>
<p>这里使用配置文件的唯一目的：在 CA 签字时，将服务器的域名和 IP 与证书绑定，表示这个证书确实属于该服务器，而不是别人伪装的。如果没有这个配置，浏览器会提示错误：<code>NET::ERR_CERT_COMMON_NAME_INVALID</code>。</p>
<p>使用如下命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">openssl req -new -key nginx_server.key -out nginx_server.csr</span><br></pre></td></tr></table></figure>
<h2 id="CA-签字">CA 签字</h2>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">openssl x509 -req -extfile openssl.cnf  -<span class="keyword">in</span> nginx_server.csr -CA /opt/MyOwnCA/myCACertificate.crt -CAkey /opt/MyOwnCA/myCAPK.key -CAcreateserial -out nginx_server.crt -days 398</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为什么设置 <code>-days 398</code> ？—— 根据苹果的<a href="https://support.apple.com/en-us/102028">新政策</a>，服务器证书不能超过 398 天，否则 SSL 连接出错（<code>NET::ERR_CERT_VALIDITY_TOO_LONG</code>）。注意，只有苹果这么要求，如果我们确定网站不会被苹果设备访问，那么设置 10 年也可以。</p>
</blockquote>
<p>签字完毕后，就有了最终需要的私钥 <code>nginx_server.key</code> 和证书 <code>nginx_server.crt</code>。</p>
<h1 id="Nginx-配置">Nginx 配置</h1>
<h2 id="SSL">SSL</h2>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> default_server ssl http2;</span><br><span class="line">    <span class="attribute">listen</span> [::]:<span class="number">443</span> ssl http2;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_certificate</span> /etc/nginx/ssl/nginx_server.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /etc/nginx/ssl/nginx_server.key;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> /... &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> ...;  </span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这只是最基本的配置，实际有更多 SSL 的配置，但目前够用了。</p>
</blockquote>
<h2 id="Basic-Authentication">Basic Authentication</h2>
<p>1️⃣首先要创建用户名和密码：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 没有该文件就先创建一个</span></span><br><span class="line"><span class="built_in">touch</span> /opt/docker/nginx_auth/.htpasswd-lanraragi</span><br><span class="line"><span class="comment"># 向这个配置文件里添加 alpha 用户</span></span><br><span class="line">htpasswd /opt/docker/nginx_auth/.htpasswd-lanraragi alpha</span><br></pre></td></tr></table></figure>
<p>然后系统提示给 <code>alpha</code> 用户设置密码。要填加多个用户，用相同命令即可：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">htpasswd /opt/docker/nginx_auth/.htpasswd-lanraragi beta</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在 CentOS 中，<code>htpasswd </code> 命令属于 <code>httpd-tools</code> 。如果没有安装，系统会提示安装。</p>
</blockquote>
<hr>
<p>2️⃣在 Nginx 中配置：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> /api &#123;</span><br><span class="line">    <span class="attribute">auth_basic</span>           <span class="string">&quot;Administrator’s Area&quot;</span>;</span><br><span class="line">    <span class="attribute">auth_basic_user_file</span> /etc/nginx/.htpasswd; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>auth_basic</code> 在登录界面会提示用户；</li>
<li><code>auth_basic_user_file</code> 指向之前创建的 <code>.htpasswd</code>；</li>
</ul>
<p>也可以全局启用，但在具体的路径里关闭认证：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attribute">auth_basic</span>           <span class="string">&quot;Administrator’s Area&quot;</span>;</span><br><span class="line">    <span class="attribute">auth_basic_user_file</span> conf/.htpasswd;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> /public/ &#123;</span><br><span class="line">      <span class="attribute">auth_basic</span> <span class="literal">off</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="例子：Lanraragi">例子：Lanraragi</h1>
<p>回到最初的需求：反向代理 Lanraragi，并提供登录功能。</p>
<p>Docker compose:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.24</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nginx-lanraragi</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/opt/docker/nginx_conf/nginx-lanraragi.conf:/etc/nginx/nginx.conf:ro</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/opt/docker/nginx_ssl:/etc/nginx/ssl/:ro</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/opt/docker/nginx_auth:/etc/nginx/auth/:ro</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">43000</span><span class="string">:443</span></span><br><span class="line">  <span class="attr">lanraragi:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">difegue/lanraragi:v.0.9.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">lanraragi</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/mnt/hgfs/doujinshiArchives:/home/koyomi/lanraragi/content:ro</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">lanraragi-database:/home/koyomi/lanraragi/database</span></span><br><span class="line">    <span class="attr">depends_on:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">nginx</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">lanraragi-database:</span></span><br></pre></td></tr></table></figure>
<p>Nginx 配置：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">user</span>  nginx;</span><br><span class="line"><span class="attribute">worker_processes</span>  auto;</span><br><span class="line"></span><br><span class="line"><span class="attribute">error_log</span>  /var/log/nginx/<span class="literal">error</span>.log <span class="literal">notice</span>;</span><br><span class="line"><span class="attribute">pid</span>        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       /etc/nginx/mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">&#x27;<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] &quot;<span class="variable">$request</span>&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> &quot;<span class="variable">$http_referer</span>&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;&quot;<span class="variable">$http_user_agent</span>&quot; &quot;<span class="variable">$http_x_forwarded_for</span>&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span>  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">443</span> default_server ssl http2;</span><br><span class="line">        <span class="attribute">listen</span> [::]:<span class="number">443</span> ssl http2;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">ssl_certificate</span> /etc/nginx/ssl/nginx_server.crt;</span><br><span class="line">        <span class="attribute">ssl_certificate_key</span> /etc/nginx/ssl/nginx_server.key;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">auth_basic</span>           <span class="string">&quot;Login to view any content&quot;</span>;</span><br><span class="line">        <span class="attribute">auth_basic_user_file</span> /etc/nginx/auth/.htpasswd-lanraragi;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="comment"># 在同一个网络中，直接通过服务名访问</span></span><br><span class="line">            <span class="comment"># lanraragi 也不需要映射任何端口</span></span><br><span class="line">            <span class="attribute">proxy_pass</span> http://lanraragi:3000;</span><br><span class="line">            <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">            <span class="attribute">http2_push_preload</span> <span class="literal">on</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Lanraragi 本身的路由策略没法改，这意味着必须把 <code>/</code> 原封不动地映射到 Lanraragi 的 URI。也就是说，需要给 Lanraragi 一个单独的 Nginx 实例。</p>
<p>从计算资源的角度，问题并不大，因为一个 Nginx 实例占用不到 20 MB 的内存。</p>
<p>如果给每个现有的软件都用一个 Nginx ，那么这些 Nginx 实例可以共享一个 SSL 证书。毕竟访问 Linux 主机时，是通过端口区分 Nginx，而证书是和 IP / 域名 绑定的。尽管可以这么做，我不太清楚这是不是最佳实践。但在家庭局域网的场景中，这显然够用了。</p>
<h1 id="参考">参考</h1>
<ul>
<li>ChatGPT</li>
<li><a href="https://mindsers.blog/en/post/https-using-nginx-certbot-docker/">HTTPS using Nginx and Let’s encrypt in Docker</a></li>
<li><a href="https://www.baeldung.com/openssl-self-signed-cert">Creating a Self-Signed Certificate With OpenSSL</a></li>
<li><a href="https://hub.docker.com/_/nginx">Nginx Docker hub</a></li>
<li><a href="https://www.tangyuecan.com/2021/12/17/%E5%B1%80%E5%9F%9F%E7%BD%91%E5%86%85%E6%90%AD%E5%BB%BA%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%AF%E4%BF%A1%E4%BB%BB%E7%9A%84ssl%E8%AF%81%E4%B9%A6/">局域网内搭建浏览器可信任的SSL证书</a></li>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-create-a-self-signed-ssl-certificate-for-nginx-in-ubuntu-16-04">How To Create a Self-Signed SSL Certificate for Nginx in Ubuntu 16.04</a></li>
<li><a href="https://stackoverflow.com/questions/10175812/how-to-generate-a-self-signed-ssl-certificate-using-openssl">How to generate a self-signed SSL certificate using OpenSSL?</a></li>
<li><a href="https://docs.nginx.com/nginx/admin-guide/security-controls/configuring-http-basic-authentication/">Restricting Access with HTTP Basic Authentication</a></li>
<li><a href="https://support.hcltechsw.com/csm?id=kb_article&amp;sysparm_article=KB0098768">在iOS设备上安装根证书(CA)</a></li>
<li><a href="https://discussions.apple.com/thread/253667401?sortBy=best">Enabling self-signed certificates in iOS 15</a></li>
<li><a href="https://support.apple.com/en-us/102028">Apple: About upcoming limits on trusted certificates</a></li>
</ul>
]]></content>
      <categories>
        <category>tech</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Nginx</tag>
        <tag>SSL</tag>
      </tags>
  </entry>
  <entry>
    <title>自动化追番：从 AutoBangumi 回到 qBittorrent RSS</title>
    <url>/2024/06/29/From-AutoBangumi-Back-to-qBittorrent-RSS/</url>
    <content><![CDATA[<h1 id="序言">序言</h1>
<p><a href="https://github.com/EstrellaXD/Auto_Bangumi">AutoBangumi</a> 是一款“基于 RSS 的全自动追番整理下载工具”<strong>（以下简称 AB）</strong>，很适合我这种同时使用 <a href="https://github.com/c0re100/qBittorrent-Enhanced-Edition">qBittorrent</a> <strong>（以下简称 QB）</strong> 和 Jellyfin 的用户。在使用 AB 追了一个季度的番剧后，我对于 AB、Jellyfin等软件以及 RSS、刮削等概念有了更深的理解。尽管 AB 提供了自动化，但引入它也增加了追番流程的复杂度 —— 尤其表现在 AB 出问题时。</p>
<p>回顾以往使用 QB RSS 功能的经历，加上新的理解，我选择不再使用 AB，而是使用 QB RSS 来代替。尽管在每个季度追新番时的步骤增加了一些，但整个系统的复杂度和资源占用量降低了。总的来说，我对这个改变是满意的。</p>
<h1 id="自动化追番流程">自动化追番流程</h1>
<pre><code class="highlight mermaid">flowchart LR
subgraph g1[RSS订阅器]
a1[AB] ~~~ a2[QB ]
end
subgraph g2[RSS下载器]
b1[AB] ~~~ b2[QB]
end
subgraph g3[torrent下载器]
c1[QB] ~~~ c3[Transmission ]
end
subgraph g4[下载后任务（可选）]
d1[邮件通知下载完成] ~~~ d2[修改下载视频名] ~~~ d3[创建硬链接]
end

subgraph g5[Jellyfin（插件）刮削]
e1[Bangumi] ~~~  e2[AniDB] ~~~ e3[TMDB]
end
g1--&gt;g2--&gt;g3--&gt;g4--&gt;g5</code></pre>
<span id="more"></span>
<p>如图，整个自动化追番流程分为五个步骤：</p>
<ol>
<li>RSS 订阅器：通过订阅 Mikan 等网站的 RSS 链接，获取一部番剧每一集的信息（其中最重要的是 torrent 信息）。RSS 订阅器的作用是定时获取最新的内容，因此更常见的使用场景是获取新的文章。</li>
<li>RSS 下载器：根据 RSS 订阅器获取的新的剧集信息，下载番剧。RSS 下载器知道哪些是已经下载了的，哪些是待下载的，因此总是下载新的剧集。</li>
<li>torrent 下载器 —— 没啥好介绍的。</li>
<li>下载后任务（可选）：这个 post-download tasks 的涵盖范围极广。以下是一些可能的下载后任务：
<ul>
<li>QB 可以设置『torrent 完成时运行外部程序』，通过脚本执行任意功能，调用任意其他程序，比如邮件通知。</li>
<li>AB、Sonarr 等软件可以在下载后更新视频名称，使之适合刮削。</li>
<li>如果下载目录和 Jellyfin 媒体目录是分离的，为了节省硬盘寿命，可以在媒体目录中创建对应视频文件的硬链接，而不是移动视频文件本身。（硬链接只能在同一文件系统内使用）</li>
</ul>
</li>
<li>Jellyfin（插件）刮削：Jellyfin 定期扫描媒体库，如果用户选择自动刮削（即从网络获取元数据），那么 Jellyfin 会根据视频名称尝试获取元数据（有可能失败）。这一部分的功能是由 Jellyfin 插件实现的，默认的是 TMDB，但 Bangumi 和 AniDB 的效果更好。</li>
</ol>
<h1 id="AB-的作用">AB 的作用</h1>
<p>当我们要订阅一部新番时，首先获得 RSS 链接，然后点击『添加 RSS』：
<img src="./MDImgs/From-AutoBangumi-Back-to-qBittorrent-RSS/image.png" alt="alt text" style="zoom:50%;" /></p>
<p>然后在主页可以看到该动漫的信息：
<img src="./MDImgs/From-AutoBangumi-Back-to-qBittorrent-RSS/image-1.png" alt="alt text"></p>
<p>AB 会自动订阅该 RSS，同时在 RSS 下载器中添加一条新的规则。当有了新的一集后，RSS 下载器将视频下载到 <code>动漫目录/番剧名/Season 1/</code> 下。下载完成后，AB 会将视频重命名。</p>
<ul>
<li><code>动漫目录</code> 是我们预先在 AB 中配置的，是 QB 的下载目录；</li>
<li><code>番剧名/Season 1/</code> 是 AB 自动生成的，为了符合 Jellyfin 媒体库的结构；</li>
<li>视频重命名是 AB 自动进行的，为了方便 Jellyfin 刮削；</li>
</ul>
<p>可以看到，AB 确实是高度自动化的，成功实现了『 RSS 链接与 torrent 下载器之间』和『torrent 下载器与 Jellyfin 之间』的自动化。但是，在实际使用时，我没有开启视频重命名的功能，Jellyfin 依旧可以准确识别。因此，AB 在我看来只是一个方便的 RSS 订阅器和 RSS 下载器。</p>
<h1 id="使用-QB-RSS-代替-AB">使用 QB RSS 代替 AB</h1>
<p>了解了 AB 的作用后，不难发现 QB RSS 功能可以平替 AB。好处是显而易见的：</p>
<ul>
<li>系统中的组件减少了，资源占用和复杂度降低了；</li>
<li>QB RSS 订阅器可以展示目前已有的番剧信息，而 AB 不能；</li>
<li>QB RSS 下载器功能更加强大；</li>
</ul>
<p>唯一的缺点是不能展示番剧的海报，这可以接受。</p>
<p>QB 订阅一部新番的流程如下：</p>
<ol>
<li>订阅番剧的 RSS 链接：
<img src="./MDImgs/From-AutoBangumi-Back-to-qBittorrent-RSS/image-2.png" alt="alt text" style="zoom:50%;" /></li>
<li>在 RSS 下载器中创建新的规则：
<img src="./MDImgs/From-AutoBangumi-Back-to-qBittorrent-RSS/image-3.png" alt="alt text">
<ul>
<li>规则定义：比如只要 1080p 或者只要简中字幕；</li>
<li>保存到其他目录：仿照 AB 的操作，设置为 <code>动漫目录/番剧名/Season 1/</code>。如果是第二季就写 <code>Season 2</code>；</li>
<li>选择刚才创建的 RSS 订阅规则；</li>
<li>点击保存；</li>
</ul>
</li>
</ol>
<p>mikan 的 RSS 链接的最小粒度是 <code>(bangumiId, subgroupid)</code> 的二元组，即 <code>(番剧, 搬运组/字幕组)</code>。当然，我们也可以选择由 <code>bangumiId</code> 确定的 RSS 链接，此时会包括所有搬运组/字幕组。</p>
<p>下载规则是和番剧绑定的，因此其中可以包括多个搬运组/字幕组。但 Jellyfin 会如何识别多个同一集的视频？我没有尝试过。</p>
]]></content>
      <categories>
        <category>tech</category>
        <category>NAS</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>NAS</tag>
        <tag>Docker</tag>
        <tag>Jellyfin</tag>
        <tag>RSS</tag>
        <tag>AutoBangumi</tag>
        <tag>qBittorrent</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Docker 中安装 Glances</title>
    <url>/2024/04/08/Glances-Docker/</url>
    <content><![CDATA[<h1 id="Glances-介绍">Glances 介绍</h1>
<p>Dashy 中有很多 widgets 可以配置，其中比较实用的是资源监控。面板上展示 CPU 使用率，这对我没啥用 —— 我更关心是哪个程序导致了 CPU 高占用。但是这个功能所依赖的 Glances 软件，却非常实用。</p>
<p>Glances 类似于 top 命令，可以展示系统资源使用情况。但是，它更优秀：</p>
<ul>
<li>数据展示更全面、更人性化；</li>
<li>可以展示每个容器的资源使用情况 —— 在这一点上，它胜过了 Portainer。Portainer 只能以<strong>图表</strong>形式展示<strong>一个</strong>容器的资源使用情况。</li>
<li>可以用服务器模式启动。我们可以通过浏览器监控资源使用情况，很方便。</li>
</ul>
<p><img src="./MDImgs/Glances-Docker/image-20240408112645115.png" alt="image-20240408112645115"></p>
<p>Glances 比较轻量级，只会展示当前的资源情况，不会记录历史数据。而我需要的正是这种轻量级又全面的资源监控软件。</p>
<span id="more"></span>
<h1 id="Docker-安装">Docker 安装</h1>
<p>为什么要用 Docker 安装？官方的首选方式是用 pip 安装：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pip install --user glances</span><br></pre></td></tr></table></figure>
<p>这会破坏本地的 Python 环境，所以还是要 Docker 吧。</p>
<p>docker compose:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">glances:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.io/nicolargo/glances:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">glances</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock:ro</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">bridge</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">61208</span><span class="number">-61209</span><span class="string">:61208-61209</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">GLANCES_OPT=-w</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">pid:</span> <span class="string">host</span></span><br></pre></td></tr></table></figure>
<p>之后浏览器访问 61208 端口。</p>
<h1 id="参考">参考</h1>
<ul>
<li><strong><a href="https://github.com/nicolargo/glances">Glances</a></strong></li>
</ul>
]]></content>
      <categories>
        <category>tech</category>
        <category>NAS</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>NAS</tag>
        <tag>Docker</tag>
        <tag>Glances</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 流程自动化</title>
    <url>/2024/09/06/Hexo-Workflow-automation/</url>
    <content><![CDATA[<h1 id="序言">序言</h1>
<p>最近感到我使用 Hexo 写文章时的流程有些繁琐，因此想要将这一流程自动化。流程自动化的工作包括：更新 NPM 依赖、编写构建脚本弥补 Hexo 现有的不足、使用 GitHub Actions 自动部署网站。</p>
<p>最早开始用 Hexo 时，我还不擅长读文档，喜欢看别人的教程。有了一年多使用 Hexo 的经历，以及半年多部署各种开源软件的经历，让我开始着手这一改进。</p>
<span id="more"></span>
<h1 id="更新-NPM-依赖">更新 NPM 依赖</h1>
<p>我使用的是 Next 主题，它有两种安装方式：Git 和 NPM。之前一直使用 Git，但是它不方便更新。使用 NPM 安装 Next 主题后，整个 Hexo 项目的依赖都被 NPM 统一管理了。</p>
<h2 id="更新命令">更新命令</h2>
<p>更新依赖版本的命令如下：</p>
<p>先安装 NCU：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install -g npm-check-updates</span><br></pre></td></tr></table></figure>
<p>检查更新，并安装新版本：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ncu -u</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
<p>之后根据提示，可能要运行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm audit fix</span><br></pre></td></tr></table></figure>
<h2 id="Dependabot">Dependabot</h2>
<p><code>hexo init</code> 创建的目录中自带 Dependabot 文件。GitHub Dependabot 可以定期检查更新，使用的话可以更加自动化，但是我刻意没有使用。因为和 Maven、NuGet 等依赖管理不同，NPM 还有一个 <code>package-lock.json</code> 文件。Dependabot 只会更新前者的依赖版本号，而后者会连同  <code>package-lock.json</code> 一起被更新，改坏了怎么办？</p>
<p>我也不太懂 NPM，因此还是手动地运行上面的命令吧。</p>
<h1 id="编写构建脚本">编写构建脚本</h1>
<p>我不满意 Hexo 对于 Markdown 图片引用的处理，因为它要求按照它的规则将图片放在特定的位置，而不是根据 Markdown 中的图片链接本身。结果是，我按照正常流程写作，写完还要按照 Hexo 的规则再调整。</p>
<blockquote>
<p>这一点 <a href="https://squidfunk.github.io/mkdocs-material/">Material for MkDocs</a> 做得非常好，它可以自动处理图片链接。但它是个文档框架，尽管有博客插件，整体布局仍然偏向文档，不适合作为博客。</p>
</blockquote>
<p>为了在写作时不去关心这种无聊的事，我编写了一个脚本处理图片链接。</p>
<h2 id="思路">思路</h2>
<p>我的配置是：对于每一个 Markdown 文件，它的图片被保存在 <code>./MDImgs/$&#123;filename&#125;</code>。例如，<code>source/_posts/Glances-Docker.md</code> 中的图片都在 <code>source/_posts/MDImgs/Glances-Docker</code> 中。</p>
<p>运行 <code>hexo generate</code> 后，对应的路径为 <code>public/2024/04/08/Glances-Docker/index.html</code>。而生成的 HTML 中的图片链接仍然是相对链接。Hexo 默认不会帮我们复制图片，因此我们需要将图片复制到对于路径。</p>
<p>路径中的日期就是博文的创建时间，可以通过 frontmatter 中的 <code>date</code> 字段获得。</p>
<h2 id="代码">代码</h2>
<p>将 <code>hexo clean</code> 和 <code>hexo generate</code> 一并通过脚本调用，之后直接通过这个脚本完成所有构建工作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> os.path <span class="keyword">import</span> join</span><br><span class="line"><span class="keyword">import</span> frontmatter</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line">source_path = <span class="string">r&quot;./source/_posts&quot;</span></span><br><span class="line">target_path = <span class="string">r&quot;./public&quot;</span></span><br><span class="line"></span><br><span class="line">os.system(<span class="string">&quot;npx hexo clean&quot;</span>)</span><br><span class="line">os.system(<span class="string">&quot;npx hexo generate&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> os.listdir(source_path):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> f.endswith(<span class="string">&quot;.md&quot;</span>):</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    basename = f.removesuffix(<span class="string">&quot;.md&quot;</span>)</span><br><span class="line"></span><br><span class="line">    p = join(source_path, f)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(p, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        post = frontmatter.loads(file.read())</span><br><span class="line">        date = post[<span class="string">&quot;date&quot;</span>].strftime(<span class="string">&quot;%Y-%m-%d&quot;</span>).split(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    dir1 = join(source_path, <span class="string">&quot;MDImgs&quot;</span>, basename)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(dir1):</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    dir2 = join(</span><br><span class="line">        target_path, date[<span class="number">0</span>], date[<span class="number">1</span>], date[<span class="number">2</span>], basename, <span class="string">&quot;MDImgs&quot;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(dir2):</span><br><span class="line">        os.makedirs(dir2)</span><br><span class="line"></span><br><span class="line">    dir3 = join(dir2, basename)</span><br><span class="line">    shutil.copytree(dir1, dir3)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;copy image task done&quot;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="自动部署网站">自动部署网站</h1>
<p>可以看出，构建脚本是整个自动化流程的重点。那为什么要使用 GitHub Actions 完成自动部署呢？一方面，我认为使用 Actions 是实现自动化的标志；另一方面，随着博文数量越来越多，部署时间明显变长了。此外，<a href="https://theme-next.js.org/docs/getting-started/deployment#Continuous-Integration">文档</a>里还提到了两点好处:</p>
<blockquote>
<ul>
<li>Edit the file directly online, effective immediately</li>
<li>Automatic deployment, simultaneous deployment to multiple locations</li>
</ul>
</blockquote>
<p>文档里给了一个 <a href="https://theme-next.js.org/docs/getting-started/deployment#Github-Pages">workflow 的例子</a>，但它的主要缺点是只能部署到当前仓库的 GitHub Page。GH Page 的可见性与仓库的可见性相同。因此，如果要让别人看到博客，就需要把博客开源，显然不合理。我使用一个私有仓库写博客，然后用一个公有仓库的 GH Page 来部署博客。</p>
<h2 id="Workflow">Workflow</h2>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">Hexo</span> <span class="string">site</span> <span class="string">to</span> <span class="string">Pages</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [<span class="string">master</span>]</span><br><span class="line">  <span class="attr">workflow_dispatch:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="comment"># deploy to which repo</span></span><br><span class="line">  <span class="attr">TARGET_REPO:</span> <span class="string">目标仓库名</span></span><br><span class="line">  <span class="comment"># same as timezone in _config.yml</span></span><br><span class="line">  <span class="attr">TZ:</span> <span class="string">Europe/Berlin</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="comment"># Build job</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Change</span> <span class="string">TZ</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          sudo timedatectl set-timezone $TZ</span></span><br><span class="line"><span class="string">          timedatectl</span></span><br><span class="line"><span class="string"></span>      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v4</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Use</span> <span class="string">Node.js</span> <span class="number">18</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v4</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">&quot;18&quot;</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">Python</span> <span class="number">3.10</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-python@v5</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">python-version:</span> <span class="string">&#x27;3.10&#x27;</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Dependencies</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">| </span></span><br><span class="line"><span class="string">          npm install</span></span><br><span class="line"><span class="string">          pip install -r requirements.txt</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span> <span class="string">Hexo</span> <span class="string">Site</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          python ./hexoBuild.py</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">GH</span> <span class="string">Pages</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">PAT:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.PERSONAL_ACCESS_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          mv public /tmp/public</span></span><br><span class="line"><span class="string">          cd /tmp/public</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">          <span class="string">git</span> <span class="string">init</span></span><br><span class="line">          <span class="string">git</span> <span class="string">config</span> <span class="string">--local</span> <span class="string">user.name</span> <span class="string">&quot;github-actions[bot]&quot;</span></span><br><span class="line">          <span class="string">git</span> <span class="string">config</span> <span class="string">--local</span> <span class="string">user.email</span> <span class="string">&quot;github-actions[bot]@users.noreply.github.com&quot;</span></span><br><span class="line">          <span class="string">git</span> <span class="string">remote</span> <span class="string">add</span> <span class="string">target</span> <span class="string">https://$PAT@github.com/用户名/$TARGET_REPO.git</span></span><br><span class="line"></span><br><span class="line">          <span class="string">git</span> <span class="string">add</span> <span class="string">.</span></span><br><span class="line">          <span class="string">git</span> <span class="string">commit</span> <span class="string">-m</span> <span class="string">&quot;Deploy updated blog&quot;</span></span><br><span class="line">          <span class="string">git</span> <span class="string">push</span> <span class="string">--force</span> <span class="string">--set-upstream</span> <span class="string">target</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>
<h2 id="修改时区">修改时区</h2>
<p>为什么要修改时区？—— <a href="https://github.com/hexojs/hexo/issues/4548">Hexo 的 bug</a>：尽管在 <code>_config.yml</code> 中可以配置 <code>timezone</code> 属性，但生成的 HTML 的路径中包含的时间用的是机器的时区。后果是，上面的构建脚本可能将图片拷贝到错误的路径（时间差一天），图片依旧无法显示。</p>
<p>GitHub Actions 的机器默认都是零时区，因此要调整到与 <code>_config.yml</code> 中的相同。</p>
<h2 id="PAT">PAT</h2>
<p>既然是从一个仓库访问另一个仓库，就需要 token，具体来说是 Settings | Developer Settings 中的 Personal Access Tokens（PAT）。Fine-grained PAT 虽然目前处于 beta 阶段，权限控制明显比 classic 的好用。</p>
<p>申请一个 Fine-grained PAT，要访问的目录为部署的目标目录（公有），权限为“Read and Write access to code”即可。将这个 PAT 加入到源码仓库（私有）的 Actions secrets 中，取名 <code>PERSONAL_ACCESS_TOKEN</code>。</p>
<h2 id="部署命令">部署命令</h2>
<p>下面解释 <code>Deploy to GH Pages</code> 这一步骤：</p>
<p>为什么不用 <code>hexo deploy</code>？因为每次部署实际上就是把 <code>public</code> 重新提交一次。<code>public</code> 目录是 Artifact，体积很大，却要用 Git 来管理，不合适。因此，<code>git push --force --set-upstream target master</code> 的目的就是保证目标目录中始终只有一条提交记录，即最新的 Artifact，不会浪费空间。</p>
<p>前面的步骤没什么特别的，就是新建并配置一个 Git 仓库。通过 PAT 访问其他仓库的方式就是使用 <code>https://$PAT@github.com/用户名/仓库名.git</code> 作为远程地址。</p>
<p>目标仓库为 master 分支配置了 GH Pages。当有新的提交时，会使用 GitHub 内置的 Workflow 来部署。我不想使用 <code>actions/deploy-pages</code>，感觉不如内置的靠谱。</p>
<h1 id="参考">参考</h1>
<ul>
<li>ChatGPT</li>
<li><a href="https://linuxize.com/post/how-to-set-or-change-timezone-in-linux/">How to Set or Change the Time Zone in Linux</a></li>
<li><a href="https://stackoverflow.com/a/68783135/23172420">Authenticate with GitHub using a token</a></li>
</ul>
]]></content>
      <categories>
        <category>tech</category>
        <category>Hexo</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Python</tag>
        <tag>GitHub Actions</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo自定义404页面</title>
    <url>/2023/07/04/Hexo-custom-404/</url>
    <content><![CDATA[<h1 id="自定义-404-页面">自定义 404 页面</h1>
<p>首先，创建一个名为 <code>404</code> 的 post</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">hexo new <span class="number">404</span></span><br></pre></td></tr></table></figure>
<p>在对应的 md 文件中，我们可以自定义 404 页面。由于 Hexo 框架的特性，我们可以编写 JS 脚本，让页面动起来。</p>
<p>这里给出<a href="/404" target="_blank">我的 404 页面</a>。可以看到，上面有一个倒计时。当倒计时为 0 时，会自动跳转到首页。当然，用户也可以手动点击，从而返回首页。</p>
<p>下面是对应的代码，直接放在 md 文件中即可：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://code.jquery.com/jquery-3.7.1.min.js&quot;</span> <span class="attr">integrity</span>=<span class="string">&quot;sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=&quot;</span> <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>您正在访问一个不存在的地址🤔<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>系统会在 <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;seconds&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">span</span>&gt;</span> 秒后自动跳转到首页,<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span> 您也可以点此 <span class="tag">&lt;<span class="name">a</span> <span class="attr">target</span>=<span class="string">&quot;_self&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/&quot;</span> &gt;</span>链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span>, 手动跳转!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    $(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="built_in">setInterval</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> seconds = $(<span class="string">&quot;#seconds&quot;</span>).<span class="title function_">text</span>();</span></span><br><span class="line"><span class="language-javascript">            $(<span class="string">&quot;#seconds&quot;</span>).<span class="title function_">text</span>(--seconds);</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (seconds == <span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                location.<span class="property">href</span> = <span class="string">&quot;/&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;, <span class="number">1000</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>jQuery 在这里只是用于获取 DOM 对象，因此也完全可以用原生 JS 函数来写。</p>
<h1 id="如何让网站跳转到自定义页面？">如何让网站跳转到自定义页面？</h1>
<span id="more"></span>
<p>注意：以下方法仅限于 Github Pages，其他平台的方式可能不同。</p>
<p>在<code>front-matter</code>中添加如下内容，Github Pages 就能设置该页面为 404 页面</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">/404.html</span></span><br></pre></td></tr></table></figure>
<p>不妨随机访问一个不存在的网页？看看效果如何：▶ <a href="/hsfh/40u235u/jasdlafn" target="_blank">点我</a></p>
<h1 id="参考文章">参考文章</h1>
<p><a href="https://docs.github.com/en/pages/getting-started-with-github-pages/creating-a-custom-404-page-for-your-github-pages-site">Creating a custom 404 page for your GitHub Pages site</a></p>
<p><a href="https://theme-next.js.org/docs/theme-settings/custom-pages.html#Custom-404-Page">theme-next: custom-pages</a></p>
]]></content>
      <categories>
        <category>tech</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一次 Intel 13700K 降压的操作</title>
    <url>/2024/06/01/Intel-13700K-Undervolting/</url>
    <content><![CDATA[<h1 id="问题">问题</h1>
<p>最近外网爆出了 Intel 13、14 代 i9 打游戏会报显存错误。这个也许只是 CPU 不稳定导致的<strong>短时</strong>运算错误，不足为惧<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。但是，B站上有人讨论很多 14 代 i9 在待机模式下蓝屏，甚至 13700K 也出现了这种现象。如果消息准确，那么使用了半年的 14代 i9 就出现了“缩缸”现象（硬件损坏导致的<strong>永久</strong>性能损失）。理论上，CPU 的寿命至少是 10 年，而且大部分 CPU 都是不用了、而不是用坏了。我的 CPU 就是 13700K，这让我非常警惕。</p>
<p>对于这个问题的讨论有两点需要厘清：</p>
<ol>
<li>软件报错，比如游戏、压测工具和渲染工具。这一点<strong>占据了极大比例的流量</strong>。目前，无论是 Intel 官方还是第三方网站、博主，给出的解决方案都是限制功耗和降频，使得软件不会报错。Intel 把锅甩给主板厂商，要求它们按照 Intel 标准来设置 BIOS。目前来看，这个所谓的 Intel 标准电压更高、频率更低，跑分更差。要注意，频率降低等于消费者吃亏。因此，<strong>Intel 和主板厂商都有责任</strong>。</li>
<li>CPU“缩缸”，这是产品缺陷。这一点<strong>只占据很小比例的流量</strong>。显然，Intel 永远不会承认这一点。也许从 23 年 6 月 Intel 质保政策开始收紧时<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>，Intel 已经知道了这一事实。</li>
</ol>
<p>我是在 23 年初配的电脑，轻度办公、写一写代码，基本没玩过 3A 大作。最近，我用 CPU-Z 和 R23 测试了性能，和网上的结果<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup><sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>差不多。因此，我的 13700K 应该没有“缩缸”。</p>
<p>话说回来，我倒不是很关心降频，我更关心 CPU 寿命。目前自动核心电压为 1.38 V，R23 跑一次就 100 度。这样的配置，迟早要“缩缸”。因此，本文主要记录我是如何给 CPU 降压的，以及在研究过程中发现的各种问题。</p>
<span id="more"></span>
<h1 id="一些概念">一些概念</h1>
<ul>
<li>降频：降低 CPU 的频率，比如 13700K 可以跑到 5.3GHz；</li>
<li>降压：降低 CPU 所需的电压；</li>
</ul>
<p>频率需要由电压来保证。高频率需要在高电压下才能稳定，否则 CPU 就会产生错误；但这不意味着低电压就带不动原有的高频率。这也是降压的目的之一。另外，降压也能够避免 CPU 温度达到温度墙（而被强制降频），从而保证高负载下依旧维持高频率。此时 R23 跑分甚至可以更高。</p>
<h1 id="XTU">XTU</h1>
<h2 id="降压方式">降压方式</h2>
<p>最方便的降压降频方法是用 Intel Extreme Tuning Utility，简称 XTU<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>。（这个工具实际上更多地用来超频）。</p>
<p>用这个工具调整设置后，如果系统蓝屏，则开机时会自动恢复默认配置，防止开不了机的情况。</p>
<p>同时，XTU 是个软件，点击就可以修改，不需要每次在 BIOS 里调整。</p>
<p><img src="./MDImgs/Intel-13700K-Undervolting/image-20240601111408430.png" alt="image-20240601111408430"></p>
<p>具体的降压方法<sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>：</p>
<p>电压偏移每次降低 0.01V 或 0.005V，然后点击 Apply。每降低一次，都跑一次 R23，直到系统出现蓝屏。</p>
<p>在出现蓝屏的电压偏移再加上 0.01 V，然后跑 R23 30分钟，看看会不会蓝屏。</p>
<p>不会蓝屏的话，就将当前配置设置为开机自动启用：</p>
<p><img src="./MDImgs/Intel-13700K-Undervolting/image-20240601111910013.png" alt="image-20240601111910013"></p>
<h2 id="Watchdog">Watchdog</h2>
<p>Watchdog 机制是实现超频后 crash safe 的关键。没有这个机制，电脑无法在开机时会自动恢复默认配置。</p>
<p>不幸的是，XTU 提醒我这个功能没有开启：（Advanced | System information 中查看）</p>
<p><img src="./MDImgs/Intel-13700K-Undervolting/image-20240601112232739.png" alt="image-20240601112232739"></p>
<p>但是，在设备管理器中，Watchdog 是存在的（先点击 查看 | 显示隐藏设备，Watchdog 在系统设备中）：</p>
<p><img src="./MDImgs/Intel-13700K-Undervolting/image-20240601112446574.png" alt="image-20240601112446574"></p>
<p>经过一番研究，发现华硕 Z790 主板（无论什么具体型号<sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup>）用 Watchdog 保证 XMP 的稳定性。如果开启了 XMP，那么 XTU 就没法用 Watchdog 了<sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup>。</p>
<blockquote>
<p>早知道不买华硕主板了，现在我得手动调 BIOS 了。</p>
</blockquote>
<h1 id="调整-BIOS">调整 BIOS</h1>
<p>调整 BIOS 的方法看这两个视频<sup class="footnote-ref"><a href="#fn6" id="fnref6:1">[6:1]</a></sup><sup class="footnote-ref"><a href="#fn9" id="fnref9">[9]</a></sup>。问题在于，旧 BIOS 本来只有一个地方可以设置 CPU 电压 offset。现在新的华硕主板把它变成了多个配置，又把问题给搞复杂了。</p>
<p>先说结论：Global Core SVID Voltage 调整为 adaptive mode，然后设置 offset<sup class="footnote-ref"><a href="#fn10" id="fnref10">[10]</a></sup>：</p>
<p><img src="./MDImgs/Intel-13700K-Undervolting/image-20240601124657423.png" alt="image-20240601124657423"></p>
<p>这等价于 XTU 里面的 Core Voltage Offset<sup class="footnote-ref"><a href="#fn11" id="fnref11">[11]</a></sup>。</p>
<hr>
<p>这几个电压的关系可以看这两篇帖子（别把自己给看晕了），不过和我们的操作关系不大：</p>
<ul>
<li><a href="https://nga.178.com/read.php?tid=34908324">华硕Z790 APEX，CPU两个关键电压设置的疑问</a></li>
<li><a href="https://www.reddit.com/r/overclocking/comments/typcy6/please_help_me_overclock_12700k_with_this_poor/">Please Help Me Overclock 12700K With This Poor Asus Board</a></li>
</ul>
<h1 id="降压过程">降压过程</h1>
<h2 id="降压前">降压前</h2>
<p>买回来就没升级过 BIOS：</p>
<p><img src="./MDImgs/Intel-13700K-Undervolting/20240601_130522.jpg" alt="20240601_130522"></p>
<p>在 CPU 降压前，我的 BIOS 只打开了 XMP 和 iGPU Multi-Monitor（使用独显时开启核显）。</p>
<p>降压前记得把开启自启动的软件都关掉，说不定系统崩溃时就把它们搞坏了。</p>
<p>降压时的工具：R23 和 HWMonitor。</p>
<p>HWMonitor 中需要关注主板 VCORE（CPU 实际电压）、CPU 温度和 CPU 功耗。</p>
<h2 id="r23-跑一轮">r23 跑一轮</h2>
<p>测试极限 offset：</p>
<table>
<thead>
<tr>
<th>offset</th>
<th>r23 跑分</th>
<th>最大功耗（W）</th>
<th>最大电压 (V)</th>
<th>最大温度（°C）</th>
</tr>
</thead>
<tbody>
<tr>
<td>0.0</td>
<td>30425</td>
<td>243</td>
<td>1.403</td>
<td>100</td>
</tr>
<tr>
<td>-0.005</td>
<td>30488</td>
<td>240</td>
<td>1.350</td>
<td>100</td>
</tr>
<tr>
<td>-0.01</td>
<td>30788</td>
<td>237</td>
<td>1.332</td>
<td>100</td>
</tr>
<tr>
<td>-0.02</td>
<td>30713</td>
<td>232</td>
<td>1.332</td>
<td>98</td>
</tr>
<tr>
<td>-0.03</td>
<td>30752</td>
<td>228</td>
<td>1.314</td>
<td>97</td>
</tr>
<tr>
<td>-0.04</td>
<td>30668</td>
<td>224</td>
<td>1.296</td>
<td>96</td>
</tr>
<tr>
<td>-0.05</td>
<td>30744</td>
<td>220</td>
<td>1.288</td>
<td>95</td>
</tr>
<tr>
<td>-0.06</td>
<td>30416</td>
<td>218</td>
<td>1.279</td>
<td>96</td>
</tr>
<tr>
<td>-0.07</td>
<td>30867</td>
<td>212</td>
<td>1.270</td>
<td>92</td>
</tr>
<tr>
<td>-0.08</td>
<td>29622</td>
<td>207</td>
<td>1.261</td>
<td>91</td>
</tr>
<tr>
<td>-0.09</td>
<td>30745</td>
<td>204</td>
<td>1.243</td>
<td>90</td>
</tr>
<tr>
<td>-0.10</td>
<td>30442</td>
<td>202</td>
<td>1.234</td>
<td>88</td>
</tr>
<tr>
<td>-0.11</td>
<td>30694</td>
<td>196</td>
<td>1.225</td>
<td>87</td>
</tr>
<tr>
<td>-0.12</td>
<td>30739</td>
<td>193</td>
<td>1.217</td>
<td>87</td>
</tr>
<tr>
<td>-0.13</td>
<td>报错</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
<p>功耗是 package power</p>
<p>电压是 vcore</p>
<p>温度是 package temperature</p>
</blockquote>
<p>当 offset 来到 <code>-0.13</code> 时，cinebench 报错，意味着需要回退 offset。</p>
<blockquote>
<p>无论是 cinebench 报错，还是系统黑屏、蓝屏，都表明当前的 offset 不合格。</p>
</blockquote>
<img src="./MDImgs/Intel-13700K-Undervolting/屏幕截图(14).png" alt="屏幕截图(14)" style="zoom: 67%;" />
<hr>
<p>从表格中可以看出，随着电压减少，温度降低，r23 跑分反而更高了，因为不会再触发温度墙而导致降频。</p>
<h2 id="r23-跑-30-分钟">r23 跑 30 分钟</h2>
<p>测试满足稳定性条件时的 offset：</p>
<table>
<thead>
<tr>
<th>offset</th>
<th>cinebench 何时报错</th>
</tr>
</thead>
<tbody>
<tr>
<td>-0.115</td>
<td>32 秒</td>
</tr>
<tr>
<td>-0.11</td>
<td>15 秒</td>
</tr>
<tr>
<td>-0.10</td>
<td>11 分 13 秒</td>
</tr>
<tr>
<td>-0.09</td>
<td>18 分</td>
</tr>
<tr>
<td>-0.08</td>
<td>6 分</td>
</tr>
<tr>
<td>-0.07</td>
<td>成功</td>
</tr>
</tbody>
</table>
<p>因此，<code>-0.07</code> 是最极限的 offset。30分钟结束后，r23 跑了 70 轮，得分 30337，最大温度为 97 °C，最大功耗为 217 W。</p>
<p><code>-0.07</code> 距离单轮 r23 的极限值 <code>-0.12</code> 差了 <code>0.05</code>，看来这颗 13700K 的体质不咋地。</p>
<h2 id="日常使用场景测试">日常使用场景测试</h2>
<table>
<thead>
<tr>
<th>使用场景</th>
<th>是否通过</th>
</tr>
</thead>
<tbody>
<tr>
<td>浏览器看视频</td>
<td>✅</td>
</tr>
<tr>
<td>玩『猎人：荒野的召唤』</td>
<td>✅</td>
</tr>
<tr>
<td>同时打开多个 IDE 窗口</td>
<td>✅</td>
</tr>
<tr>
<td>同时打开 4 个虚拟机（先拍了个快照，防止崩溃）</td>
<td>✅</td>
</tr>
<tr>
<td>在虚拟机里打开 bluestacks 模拟器玩手机游戏</td>
<td>✅</td>
</tr>
</tbody>
</table>
<p>在后四种场景下，风扇声音明显比之前小，说明成功通过降压实现了降温，保护了 CPU 寿命。</p>
<p>我又跑了下 CPU-Z 的稳定性测试，发现此时只占用了 180 W，温度不到 90 °C。看来 CPU-Z 的程序并不像 r23 那样会吃满 CPU，不适合作为压测工具。</p>
<h1 id="总结">总结</h1>
<p>在这次 CPU 降压的过程中，我研究了很多东西。很显然，Intel 和华硕都有错，不然我也不用折腾了 —— 以后还是买 AMD 的 CPU 吧。感觉降压降的不是 CPU 的电压，而是我的血压🤪。</p>
<h1 id="参考">参考</h1>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="https://www.pcgamer.com/there-are-increased-reports-of-crashing-in-unreal-engine-games-etc-and-epic-is-blaming-intel-chips/">There are increased reports of crashing in Unreal Engine games, etc. and Epic is blaming Intel chips</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p><a href="https://www.bilibili.com/video/BV1Mo4y1u7oj">英特尔盒装CPU拒保？硬件去哪买番外篇！</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p><a href="https://valid.x86.fr/bench/971jbu">CPU-Z Benchmark (x64 - 2017.1)</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p><a href="https://nanoreview.net/en/cpu-list/cinebench-scores">Cinebench R23 Scores</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p><a href="https://www.intel.com/content/www/us/en/download/17881/intel-extreme-tuning-utility-intel-xtu.html">Intel® Extreme Tuning Utility (Intel® XTU)</a> <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p><a href="https://youtu.be/CHndRWqOTxs">🔧 Undervolt Your INTEL CPU to increase FPS, Lower TEMPS &amp; Use LESS POWER ✅</a> <a href="#fnref6" class="footnote-backref">↩︎</a> <a href="#fnref6:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn7" class="footnote-item"><p><a href="https://www.reddit.com/r/ASUS/comments/yhlf3v/help_with_intel_xtu_new_build_issue/">Help with Intel XTU - New Build issue</a> <a href="#fnref7" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn8" class="footnote-item"><p><a href="https://rog-forum.asus.com/t5/intel-700-600-series/asus-z790e-gaming-wifi-ii-with-intel-14900k-watchdog-present/m-p/993333/highlight/true#M21024">Asus Z790E Gaming WiFi II with Intel 14900K Watchdog Present False</a> <a href="#fnref8" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn9" class="footnote-item"><p><a href="https://www.bilibili.com/video/BV1yD4y1V7fd">风冷压13900K，也不是不可以</a> <a href="#fnref9" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn10" class="footnote-item"><p><a href="https://www.bilibili.com/video/BV1R24y1Q7Tw">华硕主板vid offset超频13700k 13900k（通用主板）</a> <a href="#fnref10" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn11" class="footnote-item"><p><a href="https://www.reddit.com/r/overclocking/comments/xn49e8/whats_the_difference_between_actual_vrm_core/">What’s the difference between actual VRM core voltage and global core SVID voltage?</a> <a href="#fnref11" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>硬件</category>
      </categories>
      <tags>
        <tag>CPU</tag>
        <tag>BIOS</tag>
        <tag>Intel</tag>
        <tag>硬件</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Docker 中安装 Jellyfin</title>
    <url>/2024/02/11/Jellyfin-Docker/</url>
    <content><![CDATA[<h1 id="序言">序言</h1>
<blockquote>
<p><a href="https://jellyfin.org/">Jellyfin</a> 是一个开源的媒体服务器。我的用法是：在电脑上使用 qBittorrent 下载每日新番，启动 Jellyfin，然后在 iPad 上通过客户端看番。</p>
</blockquote>
<p>之前在 Windows 主机上安装了便捷版的 Jellyfin，因为 Linux 虚拟机没法使用显卡，无法硬件转码。后来发现，Android 和 IOS 的客户端支持大部分编码，服务器无需提供转码服务。正好我已经熟悉了 Jellyfin 的使用和配置，可以将 Jellyfin 迁移到 Docker 上去了。</p>
<p>虽然 Jellyfin 软件是跨平台的，但是它的配置还是 OS-dependent 的，更何况我是要从 Windows 迁移到 Docker 中去。尽管有一个<a href="https://github.com/MMMZZZZ/Jellyfin-Migrator">第三方脚本</a>可以使用，但保险起见，我还是重新配置了一遍，反正也不多。</p>
<p>这篇文章主要讲解了如何用 Docker 安装 Jellyfin、期间碰到的问题及其解决方案。</p>
<span id="more"></span>
<h1 id="Jellyfin-安装">Jellyfin 安装</h1>
<p>先创建两个容器卷：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker volume create jellyfin-config</span><br><span class="line">docker volume create jellyfin-cache</span><br></pre></td></tr></table></figure>
<p>Docker Compose:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">jellyfin:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">jellyfin/jellyfin:10.8.13-1</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">jellyfin</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">bridge</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">58096</span><span class="string">:8096</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">58920</span><span class="string">:8920</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">jellyfin-config:/config</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">jellyfin-cache:/cache</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/mnt/hgfs/jellyfin-media:/media:ro</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/opt/docker/jellyfin_ssl/jellyfin.pfx:/ssl/jellyfin.pfx:ro</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">jellyfin-config:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">jellyfin-cache:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>镜像要指定版本，<code>10.8.13</code> 是目前最新稳定版，而之后的版本都有 <code>unstable</code> 一词，最好别用 <code>latest</code>；</p>
</li>
<li>
<p><code>8096</code> 是默认的 HTTP 端口，<code>8920</code> 是默认的 HTTPS 端口；</p>
</li>
<li>
<p>Jellyfin 使用如下路径存储数据：</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>说明</th>
<th>路径</th>
</tr>
</thead>
<tbody>
<tr>
<td>Data Directory</td>
<td>存放 Jellyfin 所有数据的目录，通常用来被其他目录引用</td>
<td>环境变量 <code>JELLYFIN_DATA_DIR</code> 指定</td>
</tr>
<tr>
<td>Configuration Directory</td>
<td>存放配置文件</td>
<td>环境变量 <code>JELLYFIN_CONFIG_DIR</code> 指定；如果没有，则使用 <code>&lt;Data Directory&gt;/config</code></td>
</tr>
<tr>
<td>Cache Directory</td>
<td>存放服务器缓存</td>
<td>环境变量 <code>JELLYFIN_CACHE_DIR</code> 指定；如果没有，则使用 <code>&lt;Data Directory&gt;/cache</code></td>
</tr>
<tr>
<td>Log Directory</td>
<td>存放日志文件</td>
<td>环境变量 <code>JELLYFIN_LOG_DIR</code> 指定；如果没有，则使用 <code>&lt;Data Directory&gt;/log</code></td>
</tr>
</tbody>
</table>
<p><a href="https://hub.docker.com/layers/jellyfin/jellyfin/10.8.13-1/images/sha256-095e6d410d1d27b17cc4a961a9bab9fab5ffce6e49389d8ec685f65ab5538525?context=explore">Dockerfile</a> 中指定了这些环境变量：</p>
  <figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> DOTNET_SYSTEM_GLOBALIZATION_INVARIANT=<span class="number">1</span> LC_ALL=en_US.UTF-<span class="number">8</span> LANG=en_US.UTF-<span class="number">8</span> LANGUAGE=en_US:en JELLYFIN_DATA_DIR=/config JELLYFIN_CACHE_DIR=/cache JELLYFIN_CONFIG_DIR=/config/config JELLYFIN_LOG_DIR=/config/log JELLYFIN_WEB_DIR=/jellyfin/jellyfin-web JELLYFIN_FFMPEG=/usr/lib/jellyfin-ffmpeg/ffmpeg</span><br></pre></td></tr></table></figure>
<p>因此， <strong><code>/config</code> 和 <code>/cache</code> 包含了 Jellyfin 服务器的所有数据</strong> ，而这两个目录又分别挂载到 <code>jellyfin-config</code> 和 <code>jellyfin-cache</code>；</p>
</li>
<li>
<p><code>/mnt/hgfs/jellyfin-media:/media:ro</code>：将本机的媒体文件挂载到 docker 中，路径随意；</p>
</li>
<li>
<p><code>/opt/docker/jellyfin_ssl/jellyfin.pfx</code>：用来配置服务器的 SSL 证书，之后会讲；</p>
</li>
<li>
<p><code>TZ=Asia/Shanghai</code>：设置时区，使得日志的时间和本机的一致；</p>
</li>
</ul>
<h1 id="Jellyfin-设置">Jellyfin 设置</h1>
<p>因为是重新安装，所以配置都要从头走一遍，这里只讲一些重点。</p>
<h2 id="服务器-用户">服务器 | 用户</h2>
<p>不允许转码：就算客户端不支持编码，也不能用服务端的软解，不然压力太大了。</p>
<p>把<strong>每个用户</strong>的下面两个选项去掉；</p>
<p><img src="./MDImgs/Jellyfin-Docker/image-20240213140202762.png" alt="image-20240213140202762"></p>
<p>对于『允许播放需转换但无需重新编码的视频』这个选项，许多文章把这个选项也去掉了，但好像没什么影响，就留着吧。</p>
<h2 id="高级-联网">高级 | 联网</h2>
<p>选择之前挂载的 <code>jellyfin.pfx</code> 文件作为 SSL 证书（如何生成该文件见下文）：</p>
<p><img src="./MDImgs/Jellyfin-Docker/image-20240213140616778.png" alt="image-20240213140616778"></p>
<p>勾选『启用 HTTPS』，然后重启容器。</p>
<p><img src="./MDImgs/Jellyfin-Docker/image-20240213140600270.png" alt="image-20240213140600270"></p>
<p>没必要开启『强制 HTTPS 』，因为防火墙最终只会允许局域网其他设备访问 HTTPS 端口；本机还是可以通过 HTTP 访问 Jellyfin。</p>
<h1 id="SSL-证书">SSL 证书</h1>
<p>首先要有密钥 <code>jellyfin-priv-key.key</code> 和证书 <code>jellyfin.crt</code>（参考<a href="/2024/01/31/Docker-Nginx-SSL-Local-Network/#SSL-%E8%AF%81%E4%B9%A6">上一篇文章</a>）</p>
<p>然后使用以下命令生成 <code>.pfx</code> 文件即可：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">openssl pkcs12 -<span class="built_in">export</span> -out jellyfin.pfx -inkey jellyfin-priv-key.key -<span class="keyword">in</span> jellyfin.crt  -passout pass:</span><br></pre></td></tr></table></figure>
<h1 id="局域网设置">局域网设置</h1>
<blockquote>
<p>再次说一下我的网络环境：</p>
<p>Windows 主机，通过 VMware 安装了 Linux，Docker 运行在该虚拟机上。</p>
<p>主机和其他设备共享家庭内网。</p>
</blockquote>
<p>之前在 Windows 上运行 Jellyfin，我直接允许 Jellyfin 访问专用网络（家庭内网）。即防火墙规则是授权给 Jellyfin 这个可执行文件，而不是某个端口。</p>
<p>现在是在 Docker 中运行，要做如下更改：</p>
<ol>
<li>
<p>添加虚拟机 NAT 映射，将 Linux 的 58920 映射到主机的 58920 端口；</p>
<p><img src="./MDImgs/Jellyfin-Docker/image-20240213141926681.png" alt="image-20240213141926681"></p>
</li>
<li>
<p>新增防火墙入站规则：<code>58920/tcp</code>，专用网络；</p>
</li>
<li>
<p>各个客户端重新连接新的服务器；</p>
</li>
</ol>
<hr>
<p>Windows 的 Jellyfin 开放 58920 端口，更换为 Docker 版后也是这个端口，即都可以在浏览器上通过 <code>https://主机IP:58920</code> 访问 web 客户端。这样可以“骗过” Google Password Manager，直接使用以前的账户和密码。</p>
<h1 id="一些-Bug">一些 Bug</h1>
<h2 id="字体问题1">字体问题1</h2>
<p>创建好容器后，进入容器，执行以下命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">apt update &amp;&amp; apt install fonts-noto-cjk-extra</span><br></pre></td></tr></table></figure>
<p>然后重启容器。</p>
<p>不然的话，媒体库封面图的中文会变成方块。</p>
<h2 id="字体问题2">字体问题2</h2>
<p>包含 ASS 字幕的 MKV 在播放时，字幕都是方块。问题还是出在缺少字体。</p>
<p>在『服务器 | 播放』中设置『备用字体文件路径』，并『启用备用字体』。</p>
<p><img src="./MDImgs/Jellyfin-Docker/image-20240502122456643.png" alt="image-20240502122456643"></p>
<p>在这个目录内，放入一个 woff 字体。</p>
<hr>
<p>以 Windows 系统自带的微软雅黑为例：</p>
<p>进入 <code>C:\Windows\Fonts</code> ，搜索 <code>yahei</code>，复制该字体，得到三个 <code>ttc</code> 文件。我们要将 <code>ttc</code> 转换为 <code>woff</code>。使用如下 Python 代码：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pip install fonttools</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fontTools.ttLib <span class="keyword">import</span> TTFont</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">convert_ttf_to_woff</span>(<span class="params">ttf_path, woff_path</span>):</span><br><span class="line">    font = TTFont(ttf_path, fontNumber=<span class="number">0</span>)</span><br><span class="line">    font.save(woff_path, <span class="string">&quot;woff&quot;</span>)</span><br><span class="line"></span><br><span class="line">ttf_file = <span class="string">r&quot;./msyh.ttc&quot;</span></span><br><span class="line">woff_file = <span class="string">r&quot;./msyh.woff&quot;</span></span><br><span class="line"></span><br><span class="line">convert_ttf_to_woff(ttf_file, woff_file)</span><br></pre></td></tr></table></figure>
<h2 id="符号链接">符号链接</h2>
<p>通过 <code>mklink</code> 命令可以在 Windows 上创建链接。在 Windows 上运行 Jellyfin 时，为了不让 Jellyfin 修改媒体目录， 我使用 <a href="https://github.com/gustaavv/script-house/blob/master/script_house/ops/FileSystemOperation.py#L125"><code>walk_while_link</code> 函数</a> 给每个视频文件创建符号链接。但是虚拟机的共享文件夹可以设置只读，volume 也可以设置只读，因此使用 Docker 后没必要这么做。</p>
<p>更要命的是，这么做会导致视频无法播放，Jellyfin 读媒体数据时会报错。—— 我怀疑这是符号链接的锅，因为很多讲 NAS 的文章都使用硬链接，而不是符号链接。但我不喜欢用硬链接，更何况是在 Windows 上。</p>
<p>但是给文件夹创建符号链接是可以的。比如说共享文件夹为 <code>jellyfin-docker-media</code>，我们可以通过给其他路径的 <code>films</code>、<code>animes</code> 文件夹制作符号链接，将它们都汇总到 <code>jellyfin-docker-media</code> 下。这相当于加了一层封装，减少了虚拟机共享文件夹的数目。</p>
<p>实际上我就是这么做的，Docker-compose 中的 <code>/mnt/hgfs/jellyfin-media</code>，就是主机的 <code>jellyfin-docker-media</code> 共享文件夹。</p>
<h2 id="SSL-证书过期">SSL 证书过期</h2>
<blockquote>
<p>这个 bug 更新于 2025-03-13</p>
</blockquote>
<p>复现过程：</p>
<p>1️⃣通过主机 IP 访问网页，出现『选择服务器』界面，点击后显示无法连接。此时浏览器正常显示 —— 理应显示连接不安全。</p>
<p>2️⃣通过 Jellyfin 安卓版访问，无法连接。此时服务器日志如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[INF] [82] Jellyfin.Api.Auth.CustomAuthenticationHandler: &quot;CustomAuthentication&quot; was not authenticated. Failure message: &quot;Invalid token.&quot;</span><br><span class="line">[INF] [82] Jellyfin.Api.Auth.CustomAuthenticationHandler: &quot;CustomAuthentication&quot; was not authenticated. Failure message: &quot;Invalid token.&quot;</span><br><span class="line">[INF] [82] Jellyfin.Api.Auth.CustomAuthenticationHandler: AuthenticationScheme: &quot;CustomAuthentication&quot; was challenged.</span><br></pre></td></tr></table></figure>
<p>—— 依旧看不出问题。</p>
<p>3️⃣通过虚拟机 IP （HTTP 端口）访问网页，可以正常登录 —— 说明 Jellyfin 服务器工作正常。</p>
<p>4️⃣通过虚拟机 IP （HTTPS 端口）访问网页，浏览器显示连接不安全，点开一看，证书过期了。</p>
<p>对于过期的 SSL 证书，解决方法为：不需要创建新的服务器密钥和 CSR，只需要 CA 重新签字即可。此外，Jellyfin 还要求额外生成 <code>.pfx</code> 文件。</p>
<h1 id="Docker-知识">Docker 知识</h1>
<p>通过安装 Jellyfin，我在实操中加深了对 Docker 的理解。</p>
<h2 id="EXPOSE">EXPOSE</h2>
<p>Dockerfile 中的 <code>EXPOSE</code> 关键字，我一直以为只有用了这个关键字，启动容器时才可以映射对应端口，实则不然。</p>
<blockquote>
<p>The <code>EXPOSE</code> instruction <strong>informs</strong> Docker that the container listens on the specified network ports at runtime. You can specify whether the port listens on TCP or UDP, and the default is TCP if you don’t specify a protocol.</p>
<p>The <code>EXPOSE</code> instruction <strong>doesn’t actually publish the port</strong>. It functions as a type of <strong>documentation</strong> between the person who builds the image and the person who runs the container, about which ports are intended to be published. To publish the port when running the container, use the <code>-p</code> flag on <code>docker run</code> to publish and map one or more ports, or the <code>-P</code> flag to publish all exposed ports and map them to high-order ports.</p>
</blockquote>
<p>上面两段话摘录自官网的文档。<code>EXPOSE</code> 只是一个文档性质的声明，而 <code>-p</code> 才是真正的端口映射，并且可以随意地映射容器的端口，没有限制。</p>
<p>因此，我在<a href="/2024/01/31/Docker-Nginx-SSL-Local-Network/#Nginx-%E5%AE%B9%E5%99%A8">『在 Docker 中部署 Nginx，并在局域网配置 SSL 证书』</a> 的做法是无意义的，没必要为了 <code>EXPOSE</code> 新创建一个镜像。</p>
<blockquote>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx:<span class="number">1.24</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">443</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Cache-Memory">Cache Memory</h2>
<p>在 Portainer 的统计中，可以看到内存使用分为『Memory』和『Cache』。这两个分别是什么意思？哪个才是目前占用的内存？</p>
<p><img src="./MDImgs/Jellyfin-Docker/image-20240213085846776.png" alt="image-20240213085846776"></p>
<p>简单来说，『Memory』是目前占用的内存，而『Cache』是<strong>曾经使用过</strong>的内存。Memory Cache 是 Docker 的一个属性，其值等于 <code>/proc/meminfo</code> 中 <code>Inactive(file)</code> 的值。</p>
<blockquote>
<p><code>Inactive(file)</code> — The amount of file cache memory, in kibibytes, that is newly loaded from the disk, or is a candidate for reclaiming.</p>
</blockquote>
<h1 id="参考">参考</h1>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/624670198">在Docker下安装Jellyfin并正确开启硬件解码</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/640489824">Docker部署开源流媒体软件Jellyfin</a></li>
<li><a href="https://jellyfin.org/docs/general/installation/container#using-docker-compose">Jellyfin doc installation</a></li>
<li><a href="https://jellyfin.org/docs/general/networking/#self-signed-certificate">Jellyfin doc self-signed certificate</a></li>
<li><a href="https://docs.docker.com/engine/reference/builder/#expose">Docker doc EXPOSE</a></li>
<li><a href="https://www.reddit.com/r/portainer/comments/w6pvit/what_is_memory_cache_in_the_container_stats/">What is memory “cache” in the container stat’s?</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/637577131">解决jellyfin中文外挂字幕乱码 - 天高不算高的文章 - 知乎</a></li>
<li><a href="https://echo.solo90.com/archives/1213.html">Jellyfin解决中文字幕乱码的问题！</a></li>
</ul>
]]></content>
      <categories>
        <category>tech</category>
        <category>NAS</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>NAS</tag>
        <tag>Docker</tag>
        <tag>Jellyfin</tag>
      </tags>
  </entry>
  <entry>
    <title>Jellyfin 自定义扫描频率</title>
    <url>/2024/06/11/Jellyfin-custom-scan-frequency/</url>
    <content><![CDATA[<h1 id="序言">序言</h1>
<p>在<a href="/2024/02/20/LANraragi-Using-Experience">之前的文章</a>中，我提到“Jellyfin 计划任务『扫描媒体库』并不吃资源，频繁运行也没事”。实际上，这不准确。这个任务对于资源的占用取决于媒体/文件的数量。</p>
<p>最近我写了一个项目，用来爬取视频，同时自动生成 nfo 文件和视频海报。在这个新的视频目录中，最多有 2000 个文件（大部分是 nfo 和海报图片，视频还没怎么下载），有四级子目录。但此时计划任务的 CPU 占用量已经大幅增加。这显然有问题。</p>
<p>经过一番研究，我发现使用 crontab 定时调用 Jellyfin API，是目前唯一实现不同媒体库不同扫描频率的解决方案。</p>
<span id="more"></span>
<h1 id="步骤">步骤</h1>
<h2 id="关闭计划任务">关闭计划任务</h2>
<p>进入『控制台 | 计划任务 | 扫描媒体库』，删除现有任务：</p>
<p><img src="./MDImgs/Jellyfin-custom-scan-frequency/image-20240611131240942.png" alt="image-20240611131240942"></p>
<h2 id="申请一个-API-密钥">申请一个 API 密钥</h2>
<p>进入『控制台 | API 密钥』，创建一个：</p>
<p><img src="./MDImgs/Jellyfin-custom-scan-frequency/image-20240611131529710.png" alt="image-20240611131529710"></p>
<h2 id="获得-API-端口">获得 API 端口</h2>
<p>我建议直接用 F12 抓包：</p>
<img src="./MDImgs/Jellyfin-custom-scan-frequency/image-20240611131657198.png" alt="image-20240611131657198" style="zoom:50%;" />
<p>点击『刷新』前，先按下 F12。然后找到对应的请求</p>
<img src="./MDImgs/Jellyfin-custom-scan-frequency/image-20240611131710749.png" alt="image-20240611131710749" style="zoom: 33%;" />
<p><code>/Items/媒体库ID/Refresh?扫描参数</code>，这个 URL 可以直接拿来用。</p>
<p><img src="./MDImgs/Jellyfin-custom-scan-frequency/image-20240611131902161.png" alt="image-20240611131902161"></p>
<h2 id="crontab">crontab</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑</span></span><br><span class="line">crontab -e</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看</span></span><br><span class="line">crontab -l</span><br></pre></td></tr></table></figure>
<p>curl 格式如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">curl -k -X POST <span class="string">&quot;https://IP地址:端口/Items/媒体库ID/Refresh?Recursive=true&amp;ImageRefreshMode=Default&amp;MetadataRefreshMode=Default&amp;ReplaceAllImages=false&amp;ReplaceAllMetadata=false&quot;</span> -H <span class="string">&quot;Authorization: MediaBrowser Token=API密钥&quot;</span></span><br></pre></td></tr></table></figure>
<p>crontab 格式如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新番：每十分钟一次</span></span><br><span class="line">*/10 * * * * curl -k -X POST &quot;https://IP地址:端口/Items/媒体库ID/Refresh?Recursive=true&amp;ImageRefreshMode=Default&amp;MetadataRefreshMode=Default&amp;ReplaceAllImages=false&amp;ReplaceAllMetadata=false&quot; -H &quot;Authorization: MediaBrowser Token=API密钥&quot;</span><br></pre></td></tr></table></figure>
<p>其他时间配置：</p>
<ul>
<li>每小时一次：<code>0 * * * *</code>；</li>
<li>每周一次：比如 <code>0 17 * * 0</code>，每周天下午 5 点；</li>
<li>每两周一次：比如 <code>0 11 1,15 * *</code>，每月1号和15号的早上11点；</li>
</ul>
<hr>
<p>查看 crontab 的日志：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. 使用journalctl</span> </span><br><span class="line">journalctl -u crond</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. 直接查看日志文件，这个更全</span></span><br><span class="line">cat /var/log/cron</span><br></pre></td></tr></table></figure>
<h1 id="实际效果">实际效果</h1>
<p><img src="./MDImgs/Jellyfin-custom-scan-frequency/image-20240611154250550.png" alt="image-20240611154250550"></p>
<blockquote>
<p>这个软件是 NetData，我之后会写一篇关于它的博文。</p>
</blockquote>
<p>红色的是扫描爬取的视频的媒体库，而蓝色的是扫描本季新番的媒体库。</p>
<p>可以看到：</p>
<ul>
<li>
<p>蓝色的平均值不超过 5%，因此每十分钟执行一次没问题 —— 这个频率也可以及时地让 Jellyfin 刮削新下载好的番剧。</p>
</li>
<li>
<p>如果按照之前 Jellyfin 的计划任务，所有媒体库都一小时扫描一次，那么对 CPU 的占用显然太大了。</p>
</li>
</ul>
<h1 id="参考">参考</h1>
<ul>
<li><a href="https://www.reddit.com/r/jellyfin/comments/jjxbko/disabling_automatic_scan_per_library/">Disabling automatic scan per library</a></li>
</ul>
]]></content>
      <categories>
        <category>tech</category>
        <category>NAS</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>NAS</tag>
        <tag>Docker</tag>
        <tag>Jellyfin</tag>
      </tags>
  </entry>
  <entry>
    <title>LANraragi 使用心得</title>
    <url>/2024/02/20/LANraragi-Using-Experience/</url>
    <content><![CDATA[<h1 id="序言">序言</h1>
<p>我使用 LANraragi 已经有一段时间了，期间发现了一些问题，都解决了，正好写一篇文章记录一下。读者可以参考我<a href="/2024/01/25/LANraragi-manga-server/">之前安装 LANraragi 的文章</a>。</p>
<h1 id="问题1：挂载缩略图目录导致缩略图无法生成">问题1：挂载缩略图目录导致缩略图无法生成</h1>
<span id="more"></span>
<p>安装 LANraragi 时，为了保证 <code>content</code> 目录只读，我将缩略图目录设置成了容器内部路径。这意味着，每次删除再重启该容器，都需要重新生成缩略图 —— 这样做浪费计算资源，也不符合 Docker 最佳实践。那就使用一个新的 volume 存放缩略图。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">lanraragi:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">difegue/lanraragi:v.0.9.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">lanraragi</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/mnt/hgfs/doujinshiArchives:/home/koyomi/lanraragi/content:ro</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">lanraragi-database:/home/koyomi/lanraragi/database</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">lanraragi-thumbnail:/home/koyomi/lanraragi/thumb</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">lanraragi-database:</span></span><br><span class="line">  <span class="attr">lanraragi-thumbnail:</span></span><br></pre></td></tr></table></figure>
<p><code>lanraragi-thumbnail</code> 就是存放缩略图的 volume。</p>
<p>启动容器，发现缩略图无法生成。进入『Minion Console』，发现如下错误：</p>
<p><img src="./MDImgs/LANraragi-Using-Experience/image-20240220111456968.png" alt="image-20240220111456968"></p>
<p>为什么 <code>mkdir</code> 会没有权限呢？进入容器：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/home/koyomi/lanraragi <span class="comment"># ls -lah</span></span><br><span class="line">total 192K   </span><br><span class="line">drwxr-sr-x    1 koyomi   koyomi      4.0K Feb 20 02:14 .</span><br><span class="line">drwxr-sr-x    1 koyomi   koyomi      4.0K Feb 20 02:14 ..</span><br><span class="line">-rw-r--r--    1 root     koyomi        52 Oct 29 21:19 config.log</span><br><span class="line">drwxrwxrwx    1 root     root       16.0K Feb 17 11:44 content</span><br><span class="line">drwxr-xr-x    3 koyomi   root        4.0K Feb 20 03:10 database</span><br><span class="line">drwxr-sr-x    3 koyomi   koyomi      4.0K Oct 31 00:58 lib</span><br><span class="line">drwxr-sr-x    2 koyomi   koyomi      4.0K Feb 20 02:14 <span class="built_in">log</span></span><br><span class="line">-rw-r--r--    1 koyomi   koyomi       186 Oct 31 00:58 lrr.conf</span><br><span class="line">-rw-r--r--    1 koyomi   koyomi         8 Feb 20 02:14 oshino</span><br><span class="line">-rw-r--r--    1 koyomi   koyomi     97.6K Oct 29 21:02 package-lock.json</span><br><span class="line">-rw-r--r--    1 koyomi   koyomi      2.1K Oct 27 23:07 package.json</span><br><span class="line">drwxr-sr-x    1 root     koyomi      4.0K Feb 20 02:14 public</span><br><span class="line">drwxr-sr-x    2 koyomi   koyomi      4.0K Oct 31 00:58 script</span><br><span class="line">drwxr-sr-x    3 koyomi   koyomi      4.0K Oct 31 00:58 templates</span><br><span class="line">drwxr-sr-x    4 koyomi   koyomi      4.0K Oct 31 00:58 tests</span><br><span class="line">drwxr-xr-x  257 root     root        4.0K Feb 20 02:19 thumb</span><br><span class="line">drwxr-sr-x    1 koyomi   koyomi      4.0K Oct 31 00:59 tools</span><br></pre></td></tr></table></figure>
<p>注意 <code>thumb</code> 目录，它是由 <code>root</code> 用户创建，但运行 LANraragi 的 <code>koyomi</code> 用户没有对该目录的写权限。授权即可：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 777 thumb</span><br></pre></td></tr></table></figure>
<p>然后在『Tags and Thumbnails』里点击『Generate Missing Thumbnails』。</p>
<blockquote>
<p>也可以看到， <code>content</code> 目录作为默认的漫画目录，被作者人为的提高了权限，因此默认使用 <code>content/thumb</code> 作为缩略图目录并不会产生这个问题。</p>
</blockquote>
<h1 id="问题2：无法实时监控文件变动">问题2：无法实时监控文件变动</h1>
<p>见设置中的『Background Workers』：</p>
<blockquote>
<p>This File Watcher is responsible for monitoring your content directory and automatically handling new archives as they come.
If Shinobu is dead or unresponsive, you can reboot her by clicking this button.</p>
</blockquote>
<p>本该实时监控文件变动，但我却用不了这个功能。原因在于该功能的底层使用了 <code>inotify</code> API：</p>
<blockquote>
<p>The inotify API provides a mechanism for monitoring filesystem events.  Inotify can be used to monitor individual files, or to monitor directories.  When a directory is monitored, inotify will return events for the directory itself, and for files inside the directory.</p>
</blockquote>
<p>如果文件系统不支持这个 API，那么 LANraragi 自然无法监控文件变动。</p>
<p>我使用 VMware 的共享文件夹将漫画资源映射到 Linux 中，而共享文件夹底层的文件系统不支持 <code>inotify</code>。</p>
<p>解决方法：点击『Restart File Watcher』，重启后会扫描整个 <code>content</code> 目录；或者写一个定时任务脚本，POST <code>/api/shinobu/restart</code>。</p>
<hr>
<p>其实很多软件都是用 <code>inotify</code> 来监控文件变动，因此这是一个普遍的问题。</p>
<p>我的 Jellyfin 的媒体文件夹同样使用了 VMware 的共享文件夹，因此也有该问题。不过 Jellyfin 知名得多，我从相关帖子中很快发现了这个问题。更重要地是，Jellyfin 明确地写了只有支持 <code>inotify</code> 的文件系统才有这一功能，这一点值得其他软件作者写文档时借鉴。</p>
<blockquote>
<h2 id="Real-Time-Monitoring">Real Time Monitoring</h2>
<p>This will let Jellyfin automatically update libraries when files are added or modified. Unfortunately, this feature is <strong>only supported on certain filesystems</strong>.</p>
<p>For Linux systems, this is performed by inotify. NFS and rclone do not support inotify, but support can be provided by using a union file system such as mergerfs with your networked file systems.</p>
</blockquote>
<p>顺便提一下 Jellyfin 的解决方案：</p>
<ul>
<li>提高计划任务『扫描媒体库』的频率 —— 这个任务并不吃资源，频繁运行也没事；</li>
<li>通过 API 执行刷新；</li>
</ul>
<h1 id="收获">收获</h1>
<p>这个脚本挺好用的：</p>
<p><img src="./MDImgs/LANraragi-Using-Experience/image-20240220131323937.png" alt="image-20240220131323937"></p>
<p>我的漫画目录结构是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── 作者1</span><br><span class="line">│   ├── 漫画压缩包1</span><br><span class="line">│   └── 漫画压缩包2</span><br><span class="line">└── 作者2</span><br><span class="line">    ├── 漫画压缩包1</span><br><span class="line">    └── 漫画压缩包2</span><br></pre></td></tr></table></figure>
<p>这个脚本可以将对应的漫画划分到某一个作者的 Category 中。尽管我没有给漫画打 tag，以作者作为 Category 却起到了相同效果，让我可以根据作者选择漫画。</p>
<h1 id="参考">参考</h1>
<ul>
<li><a href="https://man7.org/linux/man-pages/man7/inotify.7.html">inotify(7) — Linux manual page</a></li>
<li><a href="https://sugoi.gitbook.io/lanraragi/api-documentation/shinobu-api">LANraragi doc: Shinobu API</a></li>
<li><a href="https://jellyfin.org/docs/general/administration/troubleshooting#real-time-monitoring">Jellyfin doc: Real Time Monitoring</a></li>
<li><a href="https://www.reddit.com/r/jellyfin/comments/ke3cmo/jellyfin_not_picking_up_new_files_on_docker_mount/">Jellyfin not picking up new files on docker mount</a></li>
<li><a href="https://post.smzdm.com/p/a5o645pl/">我的Jellyfin影视库 搭建、信息刮削小记</a></li>
<li><a href="https://vagrant-up.narkive.com/5sdcgSfL/shared-folders-and-inotify-does-it-work-with-vmware-any-way-to-run-vagrant-vmware-in-trial-period">Shared folders and inotify: Does it work with VMWare + Any way to run Vagrant + VMWare in trial period?</a></li>
<li><a href="https://www.reddit.com/r/jellyfin/comments/106qtix/how_does_the_scheduled_task_for_scan_media/">How does the Scheduled Task for Scan Media Library work?</a></li>
</ul>
]]></content>
      <categories>
        <category>tech</category>
        <category>NAS</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>NAS</tag>
        <tag>Docker</tag>
        <tag>Jellyfin</tag>
        <tag>LANraragi</tag>
      </tags>
  </entry>
  <entry>
    <title>LANraragi 漫画服务器</title>
    <url>/2024/01/25/LANraragi-manga-server/</url>
    <content><![CDATA[<h1 id="序言">序言</h1>
<p>最近在研究家庭媒体库，教程大多以 NAS 为主机，实际上大多数软件都跑在 Docker 上。</p>
<p>现在有如下看漫画/同人志的需求：</p>
<ul>
<li>电脑上存有大量的漫画的压缩包，想要各种设备能访问这些资源。—— 服务端软件，能够以 HTTP 的方式传输图片。</li>
<li>漫画的目录管理以我为主，而不能以服务端软件的规则为主。</li>
<li>手机 / pad 浏览漫画时，操作方便易用。—— 客户端好用，或者直接提供 web 端。</li>
<li>客户端有随机选择漫画功能。—— 收集的漫画太多了，出于消磨时间的目的，随便挑一本看最方便。</li>
</ul>
<p>综上，我选择了 <a href="https://github.com/Difegue/LANraragi">LANraragi</a>。尽管 <a href="https://komga.org/">Komga</a>、<a href="https://www.kavitareader.com/#home">Kavita</a> 和 <a href="https://github.com/Suwayomi/Tachidesk-Sorayomi">Tachidesk (Sorayomi)</a> 也都是开源的漫画服务器，但都不尽如人意。</p>
<p>这篇文章是对官方文档的一些摘录，以及我自己使用的一些心得。</p>
<span id="more"></span>
<h1 id="LANraragi">LANraragi</h1>
<p>LANraragi 提供很多功能，但我需要的不多：</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>是否需要</th>
</tr>
</thead>
<tbody>
<tr>
<td>本地上传漫画</td>
<td>✅</td>
</tr>
<tr>
<td>网上下载漫画</td>
<td>❌</td>
</tr>
<tr>
<td>添加元数据（主要是打 tag）</td>
<td>❌</td>
</tr>
</tbody>
</table>
<p>所有漫画都是我自己本地上传的。我只是要看漫画，不需要通过 tag 分类漫画。</p>
<h1 id="安装">安装</h1>
<p>Docker compose:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">lanraragi:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">difegue/lanraragi:v.0.9.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">lanraragi</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">43000</span><span class="string">:3000</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/mnt/hgfs/doujinshiArchives:/home/koyomi/lanraragi/content:ro</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">lanraragi-database:/home/koyomi/lanraragi/database</span></span><br><span class="line">        </span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">lanraragi-database:</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>/home/koyomi/lanraragi/database</code> 是 LANraragi 存放 Redis 数据的目录。创建一个 volume 即可</li>
<li><code>/home/koyomi/lanraragi/content</code> 目录存放：
<ul>
<li>所有漫画压缩包。LANraragi 可以递归地扫描子目录 —— 文件管理以我为主；</li>
<li>漫画的缩略图，默认存放在 <code>/home/koyomi/lanraragi/content/thumb</code> 下；</li>
</ul>
</li>
<li>由于缩略图目录可以改，因此 <code>content</code> 实际只存放我自己的所有资源。我把权限设置为只读，直接映射主机存放漫画压缩包的目录。LANraragi 会自己检测文件变动，我只要像以前一样收集资源即可。</li>
</ul>
<hr>
<ul>
<li>用 Docker compose 是因为可以记录启动命令，方便之后复用。</li>
<li>Portainer 的 Stacks 就是存放 Docker-compose 文件的地方。修改 Docker-compose 后，Portainer  会重新部署，很方便。（本质上就是 <a href="https://docs.docker.com/engine/reference/commandline/compose_down/">down</a> + up，但数据不会丢，因为存放在 volume 里面）</li>
</ul>
<h1 id="配置">配置</h1>
<p>第一次启动，admin 的密码是 <code>kamimamita</code>。登录后进入配置页面，</p>
<p><img src="./MDImgs/LANraragi-manga-server/image-20240125195217045.png" alt="image-20240125195217045"></p>
<p>首先提醒一下，改了配置不要忘记保存：</p>
<p><img src="./MDImgs/LANraragi-manga-server/image-20240125200813922.png" alt="image-20240125200813922"></p>
<p>先修改初始密码：</p>
<p><img src="./MDImgs/LANraragi-manga-server/image-20240125195247264.png" alt="image-20240125195247264"></p>
<p>其他配置如下：</p>
<h2 id="Global-Settings">Global Settings</h2>
<p><img src="./MDImgs/LANraragi-manga-server/image-20240125195357388.png" alt="image-20240125195357388"></p>
<ul>
<li>分页数设置为 20，默认的 100 太多了。</li>
<li>其实不太需要阅读记录功能，就把存储任务放在客户端了，节省服务器资源</li>
</ul>
<h2 id="Archive-Files">Archive Files</h2>
<p>不用改</p>
<p><img src="./MDImgs/LANraragi-manga-server/image-20240125195541509.png" alt="image-20240125195541509"></p>
<h2 id="Tags-and-Thumbnails">Tags and Thumbnails</h2>
<p><img src="./MDImgs/LANraragi-manga-server/image-20240125195742625.png" alt="image-20240125195742625"></p>
<ul>
<li>重点是改缩略图目录。因为 docker 启动时的只读映射，以及默认的缩略图目录在 <code>content</code> 里。</li>
<li>把两个关于 tag 的选项关掉</li>
</ul>
<h2 id="Background-Workers">Background Workers</h2>
<p><img src="./MDImgs/LANraragi-manga-server/image-20240125200521462.png" alt="image-20240125200521462"></p>
<p>这个是用来监听 <code>content</code> 目录中漫画资源变动的。如果没有及时处理新的资源，可以重启。</p>
<h2 id="Plugin-Configuration">Plugin Configuration</h2>
<p><img src="./MDImgs/LANraragi-manga-server/image-20240125200854396.png" alt="image-20240125200854396"></p>
<p>把这个关了，不需要</p>
<p>所有插件默认都是关闭的，问题不大。</p>
<h1 id="使用">使用</h1>
<p>首次挂载自己的漫画资源到 <code>content</code> 时，LANraragi 需要大量资源处理元数据和缩略图。根据 Portainer 的监视数据，使用了 2-3GB 内存，2000% 的 CPU （不太懂这个 CPU 资源是怎么统计的）。</p>
<p>首页的功能：</p>
<ul>
<li>搜索；</li>
<li>每次显示随机加载的漫画；</li>
<li>列表模式 / 缩略图模式</li>
</ul>
<p>阅读器配置：</p>
<p>1️⃣默认是分页模式</p>
<p>2️⃣我更喜欢垂直浏览模式：</p>
<p><img src="./MDImgs/LANraragi-manga-server/image-20240125201748231.png" alt="image-20240125201748231"></p>
<h1 id="设备共享">设备共享</h1>
<p>Docker 运行在 Linux 虚拟机中，由于 Docker 端口映射，本机可以通过虚拟机的 IP 访问 LANraragi 。</p>
<h2 id="虚拟机-NAT-穿透">虚拟机 NAT 穿透</h2>
<p>如果要用其他设备访问 LANraragi，则需要通过 NAT 穿透将虚拟机的端口映射到主机的端口：</p>
<p><img src="./MDImgs/LANraragi-manga-server/image-20240125202125135.png" alt="image-20240125202125135"></p>
<p><img src="./MDImgs/LANraragi-manga-server/image-20240125202155268.png" alt="image-20240125202155268"></p>
<p><img src="./MDImgs/LANraragi-manga-server/image-20240125202344077.png" alt="image-20240125202344077"></p>
<p>如图配置，将 虚拟机的 43000 端口映射到主机的 43000 端口</p>
<h2 id="本机防火墙">本机防火墙</h2>
<p>Windows 的防火墙默认会屏蔽该端口，配置新的规则即可：</p>
<p><img src="./MDImgs/LANraragi-manga-server/image-20240125202513739.png" alt="image-20240125202513739"></p>
<p><img src="./MDImgs/LANraragi-manga-server/image-20240125202536458.png" alt="image-20240125202536458"></p>
<p><img src="./MDImgs/LANraragi-manga-server/image-20240125202641453.png" alt="image-20240125202641453"></p>
<p>在入站规则里新建规则：给专用网络（家庭内网）开放 43000/tcp</p>
<p>之后手机就可以通过 电脑IP:43000 访问 LANraragi 了。</p>
<p>手机端 web 界面的首页不咋地，可以用<a href="https://sugoi.gitbook.io/lanraragi/advanced-usage/external-readers">官方推荐的客户端</a>。但我只要随机阅读，所以问题不大，看漫画的界面好用就行了。</p>
<h1 id="参考资料">参考资料</h1>
<ul>
<li><a href="https://sugoi.gitbook.io/lanraragi/">LANraragi 官方文档</a></li>
</ul>
]]></content>
      <categories>
        <category>tech</category>
        <category>NAS</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>NAS</tag>
        <tag>Docker</tag>
        <tag>LANraragi</tag>
      </tags>
  </entry>
  <entry>
    <title>LocalSend：局域网文件传输利器</title>
    <url>/2023/09/04/LocalSend-A-powerful-tool-for-local-file-transfer/</url>
    <content><![CDATA[<h1 id="序言">序言</h1>
<p>最近准备重装笔记本的系统，因此要备份文件，存到台式机里。我将要备份的文件夹压缩，通过 Windows 自带的文件夹共享（局域网共享），传输这些压缩包。</p>
<p>但是，传输过程却非常艰难。有的压缩包有 10 几个 GB，传了一分钟，网速就没了，之后就开始报超时之类的错误。更离谱的是，有个压缩包在两台电脑上<a href="#%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E6%A0%A1%E9%AA%8C">摘要算法</a>的结果不同。</p>
<p>显然，windows SMB 协议既不能保证速度，也不能保证数据正确性，于是我开始寻找更加好用的局域网传输软件。它，就是本文的主角 —— LocalSend</p>
<span id="more"></span>
<h1 id="LocalSend-介绍">LocalSend 介绍</h1>
<p>LocalSend 是一个<strong>跨平台</strong>的局域网传输软件，支持 Windows, Linux, macOS, Android 和 IOS. 这是它的<a href="https://localsend.org/#/">官网</a>；这是它的 <a href="https://github.com/localsend/localsend">GitHub 仓库</a></p>
<p>作者设计了一个基于 HTTP 的传输协议，在<a href="https://github.com/localsend/protocol">这里</a></p>
<p>LocalSend 基本上是开箱即用，没必要专门写一节 quickstart</p>
<p>但是，由于 Windows 防火墙的默认配置，第一次使用该软件时，同局域网内的设备可能无法发现这台 Windows 设备。下面，我将给出解决方案。</p>
<h1 id="防火墙配置">防火墙配置</h1>
<h2 id="我的方案">我的方案</h2>
<ol>
<li>
<p>将家庭 WIFI 设置为专用网络（不建议在公共网络使用局域网传输文件，无论软件作者做了怎样的加密，我都认为是不安全的。因此，这里不讨论公用网络的情况）<img src="./MDImgs/LocalSend-A-powerful-tool-for-local-file-transfer/image-20230904212558782.png" alt="image-20230904212558782"></p>
</li>
<li>
<p>进入『配置防火墙和安全设置』</p>
<p><img src="./MDImgs/LocalSend-A-powerful-tool-for-local-file-transfer/image-20230904212718315.png" alt="image-20230904212718315"></p>
</li>
<li>
<p>『允许应用通过防火墙』——『更改配置』。找到 <code>localsend_app</code>（其他以<code>localsend</code>开头的也可以这样做），将它之前那的单选框选上。以防万一，确保之后的两个单选框也是选上的（应该是默认开启的）。然后点击『确定』</p>
<p><img src="./MDImgs/LocalSend-A-powerful-tool-for-local-file-transfer/image-20230904212911221.png" alt="image-20230904212911221"></p>
</li>
<li>
<p>重启 LocalSend，等待找到目标主机</p>
</li>
</ol>
<h2 id="网上的方案（未验证）">网上的方案（未验证）</h2>
<p>这里也给出网上其他人的解决方法，虽然我觉得全局操作防火墙<strong>很不安全</strong>。</p>
<ol>
<li>
<p>打开『Windows Defender 防火墙』</p>
<p><img src="./MDImgs/LocalSend-A-powerful-tool-for-local-file-transfer/image-20230904213446263.png" alt="image-20230904213446263"></p>
</li>
<li>
<p>『高级设置』——『Windows 防火墙属性』。在『专用配置文件』一栏，将『入站连接』改为『允许』，然后『应用』</p>
<p><img src="./MDImgs/LocalSend-A-powerful-tool-for-local-file-transfer/image-20230904213728952.png" alt="image-20230904213728952"></p>
</li>
<li>
<p>重启 LocalSend，查看能否找到目标主机。如果不行，再将上述『公用配置文件』一栏的『入站连接』改为『允许』，然后『应用』，再次重启 LocalSend 并检验。</p>
</li>
</ol>
<h1 id="文件传输校验">文件传输校验</h1>
<p>在网络传输文件后，通常要使用摘要算法（MD5、SHA1、SHA256等）对比两份文件是否一致，防止由于网络导致的数据丢失。很多现成的工具提供这样的服务，这里我介绍 3 个。</p>
<h2 id="7-zip">7-zip</h2>
<p>7-zip 虽然是一个开源的压缩软件，但也提供摘要函数。</p>
<p>右键选中要摘要的文件，点击『CRC SHA』，选择摘要算法</p>
<p><img src="./MDImgs/LocalSend-A-powerful-tool-for-local-file-transfer/image-20230904214607556.png" alt="image-20230904214607556"></p>
<p>如果右键菜单没有该选项，在 7-zip 中配置即可：</p>
<p><img src="./MDImgs/LocalSend-A-powerful-tool-for-local-file-transfer/image-20230904214947662.png" alt="image-20230904214947662"></p>
<h2 id="openssl">openssl</h2>
<p>Linux 大多数发行版都会自带的工具。也可以在 git bash 中使用这个命令。语法是：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">openssl 摘要算法名 文件路径</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Gustav@PC MINGW64 ~/Desktop</span><br><span class="line">$ openssl sha256 generate-random-file.cmd</span><br><span class="line">SHA256(generate-random-file.cmd)= 03f9454e4ee7923d08aefa4957282b62a655e7231ea6f4bdd6cdcc4e9a4c1bd9</span><br></pre></td></tr></table></figure>
<h2 id="Certutil">Certutil</h2>
<p>Windows 上的一个用来提供证书服务的工具，也提供了一些摘要算法。语法是：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">certutil <span class="literal">-hashfile</span> 文件路径 摘要算法名</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\Gustav\Desktop&gt; certutil <span class="literal">-hashfile</span> .\generate<span class="literal">-random-file</span>.cmd sha256</span><br><span class="line">SHA256 的 .\generate<span class="literal">-random-file</span>.cmd 哈希:</span><br><span class="line"><span class="number">03</span>f9454e4ee7923d08aefa4957282b62a655e7231ea6f4bdd6cdcc4e9a4c1bd9</span><br><span class="line">CertUtil: <span class="literal">-hashfile</span> 命令成功完成。</span><br></pre></td></tr></table></figure>
<h1 id="总结">总结</h1>
<p>在本文中，我介绍了一款开源好用的局域网传输工具 —— LocalSend。之后，我又给出了 Windows 系统中如何配置防火墙，使得其他设备能发现当前的设备。最后，我介绍了一些常见的对文件进行摘要的工具：从网络下载的文件，理论上都要进行一遍校验，防止数据损坏或丢失。</p>
]]></content>
      <categories>
        <category>softwares</category>
      </categories>
      <tags>
        <tag>LocalSend</tag>
        <tag>settings</tag>
        <tag>Firewall</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown 插入图片时自动拷贝——以 Typora 和  VS Code 为例</title>
    <url>/2023/07/22/Markdown-Automatically-Copy-When-Inserting-Images-Using-Typora-and-VS-Code-as-Examples/</url>
    <content><![CDATA[<h1 id="序言">序言</h1>
<p>随着 Markdown 的普及，使用传统文本编辑器写作的效率显得低下，尤其表现在一些复杂语法，比如插入表格，或者插入图片。</p>
<p>Typora 作为业界知名的 Markdown 编辑器，除了著名的『即时渲染』，也拥有很多方便书写 Markdown 的功能，比如插入图片时的自动保存：往一个 Markdown 文件（文本文件）中粘贴一张图片，该图片便会自动保存到指定路径，并且自动在 Markdown 中建立好引用。</p>
<p>对于经常用 Markdown 记笔记的我来说，<strong>这一功能应该成为业界的标准</strong>。但是，另一款常用的编辑器 —— VS Code —— 对这一功能的支持并不好。当然，我们也不应该苛求这样一款免费、通用的编辑器能够面面俱到。</p>
<h1 id="需求">需求</h1>
<p>对于经常记笔记的用户，截图并插入 Markdown 是一个常见的需求。在这一操作的背后，有两个方面关乎着用户体验：1️⃣ 截图工具 2️⃣Markdown 编辑器。</p>
<p>在截图工具一致的情况下，Markdown 编辑器是决定用户体验的关键因素。下面我将展开介绍 3 种编辑器是如何插入图片的。</p>
<span id="more"></span>
<h1 id="传统文本编辑器">传统文本编辑器</h1>
<p>这种编辑器通常只是支持 Markdown 语法高亮的“记事本”，比如 vim，sublime 等。</p>
<p>当我们截图完毕后，需要先将图片存储到本地，再使用 Markdown 语法手动引用该图片的路径：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">alt text</span>](<span class="link">image.jpg</span>)</span><br></pre></td></tr></table></figure>
<p>出于方便，截图软件往往会将图片都存储到特定路径下。为了单独存放每个 Markdown 文件相关的图片，我们还需要手动地剪切图片的位置。很麻烦！</p>
<h1 id="Typora">Typora</h1>
<h2 id="设置">设置</h2>
<p>Typora 为插入图片提供了多种功能，我最常用的是『复制图片到指定路径』。</p>
<p>这里的『插入图片』，是指鼠标拖动图片到 Typora 中，或者从剪贴板（<code>win + v</code>）中粘贴</p>
<img src="./MDImgs/Markdown-Automatically-Copy-When-Inserting-Images-Using-Typora-and-VS-Code-as-Examples/image-20230722141038783.png" alt="image-20230722141038783" style="zoom:50%;" />
<p>我选择保存到与当前 Markdown 文件同目录下的<code>MarkDownImages</code>文件夹下（没有会自动创建）。当然，更好的做法应该是选择『复制图片到 <code>./$&#123;filename&#125;.assets</code> 文件夹』，这样方便 Markdown 文件的迁移</p>
<img src="./MDImgs/Markdown-Automatically-Copy-When-Inserting-Images-Using-Typora-and-VS-Code-as-Examples/image-20230722141359394.png" alt="image-20230722141359394" style="zoom:50%;" />
<p>『对网络位置的图片应用上述规则』：当我们复制了一个网络图片（的 url ） ，Typora 会自动下载图片到指定路径，并将 url 变为本地文件引用 —— 网络上的图片可能随时消失，本地存储更可靠。</p>
<h2 id="操作">操作</h2>
<p>截图后，在 Typora 中按下 <code>Ctrl + v</code>，则剪贴板中的图片会自动拷贝到<code>MarkDownImages</code>文件夹下，并且<strong>文件名基于时间戳</strong>，不容易重复</p>
<hr>
<img src="./MDImgs/Markdown-Automatically-Copy-When-Inserting-Images-Using-Typora-and-VS-Code-as-Examples/image-20230722142231405.png" alt="image-20230722142231405" style="zoom:67%;" />
<hr>
<img src="./MDImgs/Markdown-Automatically-Copy-When-Inserting-Images-Using-Typora-and-VS-Code-as-Examples/image-20230722142307844.png" alt="image-20230722142307844" style="zoom:67%;" />
<hr>
<img src="./MDImgs/Markdown-Automatically-Copy-When-Inserting-Images-Using-Typora-and-VS-Code-as-Examples/image-20230722142326387.png" alt="image-20230722142326387" style="zoom:67%;" />
<hr>
<p>可以看出，这种插入图片的方式非常优雅、便捷</p>
<h1 id="VS-Code">VS Code</h1>
<h2 id="设置-2">设置</h2>
<p>VS Code 应该是在最近才加入类似 Typora 的功能，不过只提供了『复制图片到指定路径』的选项。</p>
<p>我这里的配置是插入任意文件（<code>**/*</code>）时，将它复制到与当前 Markdown 文件同目录下的 <code>MarkDownImages</code> 文件夹下（没有会自动创建）。文件名叫做 <code>VSCodeCopied-$&#123;fileName&#125;</code>。<code>$&#123;fileName&#125;</code>是原始文件名</p>
<p><img src="./MDImgs/Markdown-Automatically-Copy-When-Inserting-Images-Using-Typora-and-VS-Code-as-Examples/image-20230722142953270.png" alt="image-20230722142953270"></p>
<p>或者可以直接复制以下内容到 <code>settings.json</code> 中：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;markdown.copyFiles.destination&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;**/*&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./MarkDownImages/VSCodeCopied-$&#123;fileName&#125;&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="操作-2">操作</h2>
<p>与 Typora 类似，截图按下 <code>Ctrl + v</code> 即可</p>
<p>为什么保存的图片名要叫做 <code>VSCodeCopied-$&#123;fileName&#125;</code>？因为将截图插入到 VS Code 中时，会被起名为<code>image.png</code></p>
<p><img src="./MDImgs/Markdown-Automatically-Copy-When-Inserting-Images-Using-Typora-and-VS-Code-as-Examples/image-20230722143640371.png" alt="image-20230722143640371"></p>
<p>如果有重复，就在文件名后面添加数字以示区分：</p>
<p><img src="./MDImgs/Markdown-Automatically-Copy-When-Inserting-Images-Using-Typora-and-VS-Code-as-Examples/image-20230722143756389.png" alt="image-20230722143756389"></p>
<p><img src="./MDImgs/Markdown-Automatically-Copy-When-Inserting-Images-Using-Typora-and-VS-Code-as-Examples/image-20230722143813041.png" alt="image-20230722143813041"></p>
<p>这显然不直观，并且在团队合作写文档时容易造成文件名冲突。期待 VS Code 后续的更新中能够解决这一点，并提供更多的插入图片时的选项。</p>
<h1 id="参考文章">参考文章</h1>
<p><a href="https://support.typora.io/Images/#when-insert-images">Images in Typora: when-insert-images</a></p>
<p><a href="https://www.markdownguide.org/cheat-sheet/">Markdown Cheat Sheet</a></p>
]]></content>
      <categories>
        <category>softwares</category>
      </categories>
      <tags>
        <tag>settings</tag>
        <tag>VS Code</tag>
        <tag>Typora</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Metabase 安装和使用</title>
    <url>/2024/05/02/Metabase-install-and-usage/</url>
    <content><![CDATA[<h1 id="序言">序言</h1>
<p>Metabase 是一个开源的数据分析工具，操作简单，可以连接到多种数据源。虽然数据分析能力没有 Excel 强大，Metabase 也足够日常使用了。并且，我更擅长写 SQL，而不是操作 Excel，因此 Metabase 是个很好的选择。</p>
<span id="more"></span>
<h1 id="Docker-compose">Docker compose</h1>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">metabase:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">metabase/metabase:v0.49.5</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">metabase</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">JAVA_TIMEZONE:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">42233</span><span class="string">:3000</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">metabase_data:/metabase.db</span></span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> <span class="string">out=$$(curl</span> <span class="string">localhost:3000/api/health);</span> <span class="string">echo</span> <span class="string">$$out</span> <span class="string">|</span> <span class="string">grep</span> <span class="string">&#x27;&quot;status&quot;:&quot;ok&quot;&#x27;</span> <span class="string">||</span> &#123; <span class="string">echo</span> <span class="string">$$out;</span> <span class="string">exit</span> <span class="number">1</span><span class="string">;</span> &#125;</span><br><span class="line">      <span class="attr">start_period:</span> <span class="string">30s</span></span><br><span class="line">      <span class="attr">interval:</span> <span class="string">2m</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">3s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">metabase_data:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Metabase 默认使用 h2 数据库，存放在 <code>/metabase.db</code> 目录下。在生产环境下，建议使用 MySQL 或者 PostgreSQL（个人使用的话，不需要这一步）。</li>
</ul>
<h1 id="使用">使用</h1>
<p>Metabase 的基本使用可以看<a href="https://www.youtube.com/playlist?list=PL5ZlXxM-0LTF7jb-bn0vLv7IIS3Peg3YK">这个教程</a>，其中介绍了大部分图表的种类，适合没有接触过数据分析的新手。</p>
<hr>
<p>值得一提的是如何删除 question 或 dashboard：</p>
<ul>
<li>
<p>首先 archive 想要删除的 question：</p>
<p><img src="./MDImgs/Metabase-install-and-usage/image-20240502141222546.png" alt="image-20240502141222546"></p>
</li>
<li>
<p>然后进入 Archive 界面（或者从 <code>/archive</code> 进入）：</p>
<p><img src="./MDImgs/Metabase-install-and-usage/image-20240502141306567.png" alt="image-20240502141306567"></p>
</li>
<li>
<p>在这里点击删除：</p>
<p><img src="./MDImgs/Metabase-install-and-usage/image-20240502141533004.png" alt="image-20240502141533004"></p>
</li>
</ul>
<h1 id="参考">参考</h1>
<ul>
<li><a href="https://www.metabase.com/docs/latest/installation-and-operation/running-metabase-on-docker">Metabase doc: Running Metabase on Docker</a></li>
<li><a href="https://discourse.metabase.com/t/how-to-delete-charts-and-dashboards/5835">How to delete charts and dashboards？</a></li>
</ul>
]]></content>
      <categories>
        <category>tech</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Metabase</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis-Plus 实现 MySQL JSON 类型字段的映射</title>
    <url>/2023/07/08/MyBatis-Plus-Mapping-MySQL-JSON-Type/</url>
    <content><![CDATA[<h1 id="序言">序言</h1>
<p>MySQL 支持 JSON 类型的字段。相比字符串类型的字段， JSON 类型有如下好处：</p>
<ul>
<li>自动检查 JSON 语法是否正确</li>
<li>底层支持快速存取 JSON 中的元素。不需要将整个 字符串 全部读取出来，再解析成 JSON 对象</li>
</ul>
<p>在逻辑上，JSON 与 POJO 无异。Spring MVC 已经实现了 Controller 层两者的自动转化，这体现在请求参数和返回值上。那么，Repository 层如何实现两者的自动转换呢？</p>
<p>本文展示了通过使用 MyBatis-Plus，<strong>无侵入式</strong>地实现持久层 JSON 与 POJO 的自动映射（ORM， Object Relational Mapping）</p>
<h1 id="案例演示">案例演示</h1>
<h2 id="数据库表">数据库表</h2>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `person` (</span><br><span class="line">  `id` bigint NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(255) NOT NULL,</span><br><span class="line">  `log` json NOT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure>
<h2 id="依赖">依赖</h2>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="entity">entity</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(value = &quot;person&quot;, autoResultMap = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField(typeHandler = JacksonTypeHandler.class)</span></span><br><span class="line">    <span class="keyword">private</span> PersonLog log;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">PersonLog</span> &#123;</span><br><span class="line">        List&lt;String&gt; hobbies;</span><br><span class="line">        Integer age;</span><br><span class="line">        String address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>PersonLog</code>是重点讨论的对象，我们要实现它与 JSON 的映射。</p>
<p><code>Person</code>类上需要标记两个注解，两者通常一起使用：</p>
<p><code>TableName#autoResultMap</code>：负责在<strong>查询</strong>时候把 JSON 转换为 POJO</p>
<p><code>TableField#typeHandler</code>：负责在<strong>插入</strong>时将 POJO 转换为 JSON。由于 spring-web-starter 已经导入了 jackson 依赖，直接使用 <code>JacksonTypeHandler</code> 即可。</p>
<h2 id="mapper-xml">mapper.xml</h2>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.demo.mapper.PersonMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.example.demo.entity.Person&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;BIGINT&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;log&quot;</span> <span class="attr">property</span>=<span class="string">&quot;log&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;LONGVARCHAR&quot;</span> <span class="attr">typeHandler</span>=<span class="string">&quot;com.baomidou.mybatisplus.extension.handlers.JacksonTypeHandler&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;Base_Column_List&quot;</span>&gt;</span></span><br><span class="line">        id, name, log</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>mapper 文件中需要指出 <code>log</code> 字段的 typeHandler 的全类名</p>
<h2 id="测试">测试</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PersonMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Person&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>省略了 Service 层</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PersonMapper personMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/json&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">testJSON2BeanMap</span><span class="params">(<span class="meta">@RequestBody</span> Person person)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> personMapper.insert(person);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/json/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">getPersonById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> personMapper.selectById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试两个方法，没报错就说明成功，插入时可以再查看一下数据库。</p>
<p>在<a href="#%E5%BA%8F%E8%A8%80">序言</a>中提到的<strong>无侵入式ORM</strong>，是指我们不需要在代码中手动地执行 JSON 与 PersonLog 的转换。</p>
<h1 id="总结">总结</h1>
<p>本文展示了通过使用 MyBatis-Plus<strong>无侵入式</strong>实现持久层 JSON 与 POJO 的自动映射。</p>
<p>我对这一问题的研究源自实习时业务的要求。当我查询网上的资料时，发现帖子的表述都不太完整、直观，于是我记录下了解决方案，写成了这篇文章。</p>
<h1 id="参考文章">参考文章</h1>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/json.html">The JSON Data Type</a></p>
<p><a href="https://blog.csdn.net/qq_33360626/article/details/119836835">mybatis-plus处理mysql中json格式方法</a></p>
]]></content>
      <categories>
        <category>tech</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring Boot</tag>
        <tag>MySQL</tag>
        <tag>MyBatis-Plus</tag>
        <tag>JDBC</tag>
        <tag>Repository</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Docker 中安装 MySQL</title>
    <url>/2024/04/12/MySQL-Docker/</url>
    <content><![CDATA[<p>对于开发者，安装 MySQL 不是什么难事，但是往往步骤比较多。我记录了一个 Docker compose 模板，能直接启动一个配置好的 MySQL 容器，用于开发。</p>
<h1 id="Docker-compose">Docker compose</h1>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">&#x27;123456&#x27;</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">43306</span><span class="string">:3306</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_data:/var/lib/mysql</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">mysqld</span> <span class="string">--character-set-server=utf8</span> <span class="string">--collation-server=utf8_general_ci</span> <span class="string">--character-set-client-handshake=FALSE</span></span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> <span class="string">out=$$(mysqladmin</span> <span class="string">ping</span> <span class="string">-h</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="string">-u</span> <span class="string">root</span> <span class="string">--password=$$MYSQL_ROOT_PASSWORD);</span> <span class="string">echo</span> <span class="string">$$out</span> <span class="string">|</span> <span class="string">grep</span> <span class="string">&#x27;mysqld is alive&#x27;</span> <span class="string">||</span> &#123; <span class="string">echo</span> <span class="string">$$out;</span> <span class="string">exit</span> <span class="number">1</span><span class="string">;</span> &#125;</span><br><span class="line">      <span class="attr">start_period:</span> <span class="string">0s</span></span><br><span class="line">      <span class="attr">interval:</span> <span class="string">5s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">3s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">mysql_data:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h1 id="配置说明">配置说明</h1>
<span id="more"></span>
<h2 id="容器卷">容器卷</h2>
<p>MySQL 有三个存放数据的目录：</p>
<ul>
<li><code>/var/lib/mysql</code>：数据目录</li>
<li><code>/var/log/mysql</code>：日志目录</li>
<li><code>/etc/mysql/conf.d</code>：配置文件目录</li>
</ul>
<p>1️⃣最重要的当然是数据目录。</p>
<p>2️⃣配置文件目录可用可不用，因为可以使用启动参数。如果要用的话，创建一个 <code>my.cnf</code>，内容为</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[client]</span></span><br><span class="line"><span class="attr">default_character_set</span>=utf8</span><br><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">collation_server</span> = utf8_general_ci</span><br><span class="line"><span class="attr">character_set_server</span> = utf8</span><br></pre></td></tr></table></figure>
<p>实际上就是配置了字符集，因此完全可以用启动参数代替。</p>
<p>3️⃣日志目录最不重要。</p>
<h2 id="mysqld-启动参数">mysqld 启动参数</h2>
<p>使用如下命令查看（选项很多，保存到文件中再查看）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -it --<span class="built_in">rm</span> mysql:5.7 --verbose --<span class="built_in">help</span> &gt; mysqld_args.txt</span><br><span class="line">more mysqld_args.txt</span><br></pre></td></tr></table></figure>
<p>配置文件中的大部分选项都可以被启动参数代替，很适合快速创建容器。</p>
<p>启动命令是：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysqld --character-set-server=utf8 --collation-server=utf8_general_ci --character-set-client-handshake=FALSE</span><br></pre></td></tr></table></figure>
<p><code>--character-set-server</code> 和 <code>--collation-server</code> 很容易理解。</p>
<p><code>--character-set-client-handshake</code> 的意思是：</p>
<blockquote>
<p>Don’t ignore client side character set value sent during handshake.</p>
</blockquote>
<p>即优先采用客户端的字符集，默认为 <code>TRUE</code>。我设置为了 <code>FALSE</code>，强制客户端使用服务端的字符集。</p>
<h2 id="healthcheck">healthcheck</h2>
<p>测试命令是：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">out=$$(mysqladmin ping -h 127.0.0.1 -u root --password=$<span class="variable">$MYSQL_ROOT_PASSWORD</span>); <span class="built_in">echo</span> $<span class="variable">$out</span> | grep <span class="string">&#x27;mysqld is alive&#x27;</span> || &#123; <span class="built_in">echo</span> $<span class="variable">$out</span>; <span class="built_in">exit</span> 1; &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>$$</code> 是为了转义 <code>$</code>，因此 shell 命令中的 <code>$</code> 都需要双写；</li>
<li>如果命令的退出码为 0，则代表 healthy；否则，是 unhealthy；</li>
<li>这个命令可以当作一个模板：如果 <code>mysqladmin ping</code> 返回内容包括 <code>mysqld is alive</code>，则正常退出。否则，打印返回内容，并设置退出码为 1；</li>
</ul>
<h1 id="参考">参考</h1>
<ul>
<li><a href="https://hub.docker.com/_/mysql">MySQL Docker doc</a></li>
<li><a href="https://stackoverflow.com/questions/42567475/docker-compose-check-if-mysql-connection-is-ready">Docker-compose check if mysql connection is ready</a></li>
</ul>
]]></content>
      <categories>
        <category>tech</category>
        <category>Docker</category>
        <category>DBMS</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>MySQL</tag>
        <tag>DBMS</tag>
      </tags>
  </entry>
  <entry>
    <title>PotPlayer 启用 Nvidia 超分辨率</title>
    <url>/2023/07/09/PotPlayer-Enable-Nvidia-Super-Resolution/</url>
    <content><![CDATA[<h1 id="序言">序言</h1>
<p>Nvidia VSR (Video Super Resolution) 通过 AI 技术优化视频的画面质量，主要表现在锐化低分辨率的视频上。该技术最初只支持 Chrome 和 Edge 浏览器。</p>
<p>如何在本地视频播放器中体验这项技术？PotPlayer 最近发布了相关更新，支持了该技术。</p>
<p>PotPlayer 是目前数一数二的视频播放器，也是我的主力播放器。趁着这次更新，我来记录一下如何在 PotPlayer 上使用 Nvidia Super Resolution.</p>
<h1 id="浏览器开启-VSR">浏览器开启 VSR</h1>
<p>本小节先介绍一下如何让 Chrome 和 Edge 浏览器使用 Nvidia Super Resolution。</p>
<span id="more"></span>
<h2 id="更新驱动版本">更新驱动版本</h2>
<p>更新驱动版本，至少到 532 版</p>
<img src="./MDImgs/PotPlayer-Enable-Nvidia-Super-Resolution/image-20230709161546792.png" alt="image-20230709161546792" style="zoom: 67%;" />
<h2 id="设置">设置</h2>
<p>在 Nvidia Control Panel 中进入如下配置：</p>
<p>开启『超分辨率』，选择质量。数字越大，增强效果越强，同时对 GPU 压力也越大</p>
<p><img src="./MDImgs/PotPlayer-Enable-Nvidia-Super-Resolution/image-20230709161702760.png" alt="image-20230709161702760"></p>
<h1 id="PotPlayer-开启-VSR">PotPlayer 开启 VSR</h1>
<h2 id="更新版本">更新版本</h2>
<p>在 PotPlayer 近期的更新说明中，提到了：</p>
<blockquote>
<p>添加 GPU 超分辨率功能到内置的 D3D11 视频渲染器</p>
</blockquote>
<img src="./MDImgs/PotPlayer-Enable-Nvidia-Super-Resolution/image-20230709162050531.png" alt="image-20230709162050531" style="zoom: 67%;" />
<p>至少将 PotPlayer 升级到这个版本</p>
<h2 id="设置-2">设置</h2>
<p>确保使用的是『Direct3D 11 视频渲染器』，并打开『超分辨率』（默认是关闭的）</p>
<img src="./MDImgs/PotPlayer-Enable-Nvidia-Super-Resolution/image-20230709162350077.png" alt="image-20230709162350077" style="zoom: 80%;" />
<h2 id="测试">测试</h2>
<p>随便打开一个视频，按 <code>Tab</code> 键。如果『视频渲染器 - 缩放』显示的是『GPU Super Resolution』，则说明配置成功了。播放视频时，也可以在任务管理器中看到 GPU 的负载升高。</p>
<p><img src="./MDImgs/PotPlayer-Enable-Nvidia-Super-Resolution/image-20230709162617479.png" alt="image-20230709162617479"></p>
<h1 id="参考文章">参考文章</h1>
<p><a href="https://blogs.nvidia.com/blog/2023/02/28/rtx-video-super-resolution/">Pixel Perfect: RTX Video Super Resolution Now Available for GeForce RTX 40 and 30 Series GPUs</a></p>
<p><a href="https://potplayer.daum.net/">PotPlayer 官网</a></p>
]]></content>
      <categories>
        <category>softwares</category>
      </categories>
      <tags>
        <tag>settings</tag>
        <tag>PotPlayer</tag>
        <tag>Nvidia</tag>
        <tag>VSR</tag>
      </tags>
  </entry>
  <entry>
    <title>Python venv 使用</title>
    <url>/2023/12/20/Python-venv-use/</url>
    <content><![CDATA[<h1 id="序言">序言</h1>
<p>Python 以其模块丰富而著称。但是，不同于 Java 开发中 Maven 使用 group Id、artifact Id 和 version 来唯一确定一个依赖。在实践中，绝大多数 Python 项目<strong>只</strong>通过模块名来区分模块。<code>pip install &lt;module&gt;</code>，一个模块就装好了。那么模块的版本呢？大部分项目的 requirements 都不会提及版本，造成后来者跑项目时不停地报错。</p>
<p>因此，弱化版本号的概念无疑<strong>弊大于利</strong>。如何解决？使用 venv（虚拟环境）。</p>
<p>如果直接使用 <code>pip install</code> ，那么所有 Python 项目共用这些模块，会产生版本会兼容。venv 将原始的 Python 环境拷贝一份。虚拟环境的运行只依赖于拷贝后的 Python，安装的模块也只会存在于该虚拟环境中。多个虚拟环境间相互隔离。</p>
<h1 id="使用">使用</h1>
<p>1️⃣创建  venv :</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">python <span class="literal">-m</span> venv C:\Users\Gustav\Desktop\test\venv</span><br></pre></td></tr></table></figure>
<p><code>C:\Users\Gustav\Desktop\test\venv</code> 目录就是该虚拟环境</p>
<span id="more"></span>
<p>2️⃣启动：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">venv\Scripts\activate</span><br></pre></td></tr></table></figure>
<p>如果提示符前出现 <code>(venv)</code>，就说明启动成功，在里面可以随便玩了。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">(venv) C:\Users\Gustav\Desktop\test&gt;pip list</span><br></pre></td></tr></table></figure>
<p>3️⃣退出：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">(venv) C:\Users\Gustav\Desktop\test&gt;deactivate</span><br><span class="line">C:\Users\Gustav\Desktop\test&gt;</span><br></pre></td></tr></table></figure>
<h1 id="参考">参考</h1>
<p><a href="https://docs.python.org/3/library/venv.html">venv — Creation of virtual environments</a></p>
]]></content>
      <categories>
        <category>tech</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>venv</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring MVC 使用 Validation 注解实现请求参数自动校验</title>
    <url>/2023/07/05/Spring-MVC-Automatic-Validation-of-Request-Parameters-Using-Validation-Annotations/</url>
    <content><![CDATA[<h1 id="序言">序言</h1>
<p>控制器方法（ handler ）中负责请求参数校验。</p>
<p>传统的写法是在每个方法的开头对所有请求参数进行校验，如果存在参数不满足条件，则抛出异常，或者提前返回错误。</p>
<p>Validation API 提供了一系列的注解，通过将这些注解标记在 entity 类的属性上，Spring MVC 会根据这些注解的语义，自动完成请求参数校验。如果参数不满足条件，则抛出异常。这节省了开发者手动校验请求参数的麻烦。</p>
<p>负责自动参数校验的类实际上是由 Spring Boot 自动装配导入的，因此我们要使用对应的 starter 依赖。</p>
<h1 id="案例演示">案例演示</h1>
<h2 id="依赖">依赖</h2>
<span id="more"></span>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>validation-api 是本次介绍的重点</p>
<img src="./MDImgs/Spring-MVC-Automatic-Validation-of-Request-Parameters-Using-Validation-Annotations/image-20230705200537754.png" alt="image-20230705200537754" style="zoom:80%;" />
<h2 id="项目结构">项目结构</h2>
<p>一个标准的 Spring Initializer 生成的 Spring Boot 项目</p>
<img src="./MDImgs/Spring-MVC-Automatic-Validation-of-Request-Parameters-Using-Validation-Annotations/image-20230705200916180.png" alt="image-20230705200916180" style="zoom: 80%;" />
<h2 id="entity">entity</h2>
<h3 id="User">User</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.gustav.springmvcvalidatordemo.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@NotBlank</span></span><br><span class="line">    <span class="meta">@Size(max = 5, message = &quot;名字不能超过5个字符&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Min(value = 0, message = &quot;年龄不能小于0&quot;)</span></span><br><span class="line">    <span class="meta">@Max(value = 200, message = &quot;年龄不能大于200&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>@NotBlank</code>：用在 <code>CharSequence</code> 类型的属性上，表示该字段非空，且长度至少为 1。简单来说，该字符串必须有内容</p>
<p><code>@Size</code>：用在<code>CharSequence</code>和集合类的属性上，表示该字段的字符数/元素数目。<code>max = 5</code>是数量的上界，不能超过该上界。当属性值不满足条件时，Spring MVC 会抛出异常，如果设置了<code>message</code>属性，则异常内容中会包含 <code>message</code> 的值</p>
<p><code>@NotNull</code>：字面含义，字段非空</p>
<p><code>@Min</code>、<code>@Max</code>：用在数值类型上，对数值的大小进行约束。</p>
<h3 id="Pet">Pet</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.gustav.springmvcvalidatordemo.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotBlank;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line">    <span class="meta">@NotBlank</span></span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="meta">@NotBlank</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="UserAndPet">UserAndPet</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.gustav.springmvcvalidatordemo.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.validation.Valid;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotNull;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserAndPet</span> &#123;</span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Valid</span> <span class="comment">// 这个注解保证了User类内部的字段也能被校验</span></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Valid</span></span><br><span class="line">    <span class="keyword">private</span> Pet pet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@Valid</code>注解告诉 Spring MVC，它标记的类上也有字段需要校验。</p>
<h2 id="controller">controller</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.gustav.springmvcvalidatordemo.Controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.gustav.springmvcvalidatordemo.entity.UserAndPet;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.annotation.Validated;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoController</span> &#123;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> UserAndPet <span class="title function_">test</span><span class="params">(<span class="meta">@Validated</span> <span class="meta">@RequestBody</span> UserAndPet userAndPet)</span> &#123;</span><br><span class="line">        System.out.println(userAndPet);</span><br><span class="line">        <span class="keyword">return</span> userAndPet;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@Validated</code>指示 Spring MVC：当前请求参数需要被校验</p>
<h2 id="使用-Postman-发送请求">使用 Postman 发送请求</h2>
<h3 id="合法请求">合法请求</h3>
<p>请求体如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;user&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;adam&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">15</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;pet&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cat&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;east wind&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<img src="./MDImgs/Spring-MVC-Automatic-Validation-of-Request-Parameters-Using-Validation-Annotations/image-20230705202651511.png" alt="image-20230705202651511" style="zoom:67%;" />
<h3 id="非法请求">非法请求</h3>
<p>故意使<code>user.name</code>超过长度限制。请求体如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;user&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;adam williams&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">15</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;pet&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cat&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;east wind&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>服务器返回了 400 错误</p>
<p><img src="./MDImgs/Spring-MVC-Automatic-Validation-of-Request-Parameters-Using-Validation-Annotations/image-20230705202748075.png" alt="image-20230705202748075"></p>
<p>服务端抛出了<code>MethodArgumentNotValidException</code>的异常。内容是<code>user.name</code>为非法参数，同时展示了我们自己设置的 <code>message</code></p>
<p><img src="./MDImgs/Spring-MVC-Automatic-Validation-of-Request-Parameters-Using-Validation-Annotations/image-20230705202916086.png" alt="image-20230705202916086"></p>
<h1 id="总结">总结</h1>
<p>通过使用 Validation 注解，我们可以便捷地实现请求参数校验，无需写很多代码。</p>
<p>试想，我们使用传统方式校验请求参数，光是校验 <code>user.name</code>，就需要写很多代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> UserAndPet <span class="title function_">test</span><span class="params">(<span class="meta">@Validated</span> <span class="meta">@RequestBody</span> UserAndPet userAndPet)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (userAndPet == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (userAndPet.getUser() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> userAndPet.getUser().getName();</span><br><span class="line">    <span class="keyword">if</span> (!(name != <span class="literal">null</span> &amp;&amp; name.length() &gt;= <span class="number">1</span> &amp;&amp; name.length() &lt;= <span class="number">5</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 校验其他请求参数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 业务逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，方便快捷的 Validation 注解校验建立在 Spring MVC 和 Spring Boot 的基础上。Spring Boot 具体自动装配了哪些类，Spring MVC 又是如何使用这些类完成请求参数校验，就不在本文的讨论范围内了。有兴趣的读者可以自行阅读源码，或者阅读其他文章。</p>
]]></content>
      <categories>
        <category>tech</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring Boot</tag>
        <tag>Spring MVC</tag>
        <tag>Controller</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用数据库存储文件目录结构？</title>
    <url>/2024/07/19/Store-Directory-Structure-In-DB/</url>
    <content><![CDATA[<h1 id="序言">序言</h1>
<p><strong>如果要用数据库保存文件目录的结构，应该使用哪种数据库？</strong> —— 要么 NoSQL，要么 RDBMS。选取 NoSQL，应该选择支持树形结构的；选取 RDBMS，重点在于表的设计和查询操作。</p>
<p>这个问题的关键在于：<strong>我们要对数据库中的目录结构做何种操作？</strong> 显然，这些操作本质上是对文件系统上文件的操作。</p>
<ul>
<li>操作1：单个文件/目录的增删改查，即拷贝、删除、剪切某个文件/目录；</li>
<li>操作2：递归遍历某个目录；</li>
</ul>
<p>只有考虑了这两点，才能设计出高效的方案。本文给出了 NoSQL 和 RDBMS 的方案，重点在于后者。另外，本文还探讨了使用 JSON 的方案。</p>
<span id="more"></span>
<h1 id="NoSQL">NoSQL</h1>
<p>选项如下：</p>
<ul>
<li>使用 HDFS 这种文件系统作为数据库；</li>
<li>使用图数据库，比如 Neo4j；</li>
</ul>
<blockquote>
<p>没有必要为了存储目录结构而引入新的组件。</p>
</blockquote>
<h1 id="RDBMS">RDBMS</h1>
<p>以下的 <code>Item</code> 表都代表目录项，即目录树中的节点。</p>
<h2 id="树形表示">树形表示</h2>
<p>1、保存父节点指针：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Item (</span><br><span class="line">  id <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY, </span><br><span class="line">  name <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;文件名&#x27;</span>, </span><br><span class="line">  type TINYINT <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;0 表示文件，1 表示目录&#x27;</span>, </span><br><span class="line">  parent_id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">-1</span> COMMENT <span class="string">&#x27;父节点 id&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>2、保存子节点指针列表（如何处理 <code>children</code> 字段也是个麻烦事）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Item (</span><br><span class="line">  id <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY, </span><br><span class="line">  name <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;文件名&#x27;</span>,</span><br><span class="line">  type TINYINT <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;0 表示文件，1 表示目录&#x27;</span>, </span><br><span class="line">  children <span class="type">VARCHAR</span>(<span class="number">1023</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> &quot;&quot; COMMENT <span class="string">&#x27;逗号分隔的子节点 id&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这两种表示法本质上都是有向图的邻接表。无论是操作 1 还是操作 2 ，都要遍历一张表多次，<strong>效率极低</strong>。</p>
<h2 id="使用文件路径作为索引">使用文件路径作为索引</h2>
<p>由于文件路径可以唯一定位一个文件，那么文件路径也可以作为唯一索引。</p>
<blockquote>
<p>这种方法被称为 Materialized Paths。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Item (</span><br><span class="line">  id <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY, </span><br><span class="line">  name <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;文件名&#x27;</span>, </span><br><span class="line">  type TINYINT <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;0 表示文件，1 表示目录&#x27;</span>, </span><br><span class="line">  path <span class="type">VARCHAR</span>(<span class="number">1023</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;文件路径&#x27;</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX path_idx <span class="keyword">ON</span> Item(path);</span><br></pre></td></tr></table></figure>
<p>实际使用时，没必要令 <code>path</code> 为唯一索引，因为：（1）唯一索引效率太低；（2）<code>path</code> 太长，不适合作为主键。因此，<code>path</code> 作为一个普通索引即可。</p>
<hr>
<p>对于操作 1：</p>
<ol>
<li>增删查改文件，触发索引，时间复杂度为 $O(\log n)$：</li>
</ol>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Item <span class="keyword">WHERE</span> path <span class="operator">=</span> <span class="string">&#x27;路径&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>新增、查询目录，时间复杂度为 $O(\log n)$，与操作文件相同。</li>
<li>修改目录，即改名操作，时间复杂度为 $O(n)$，因为需要修改所有子目录项的路径。</li>
<li>删除目录，时间复杂度为 $O(n)$，因为需要删除所有子目录项。</li>
</ol>
<p>对于操作 2：只需要遍历一次索引表，而且由于最左前缀原则，不需要全表遍历，效率很高。</p>
<hr>
<p>综上，使用文件路径作为索引的方式<strong>效率很高</strong>。</p>
<h2 id="Nested-Sets">Nested Sets</h2>
<p>这种数据结构适合静态数据 —— 只是为了高效查询设计的，不适合修改。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Item (</span><br><span class="line">  id <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY, </span><br><span class="line">  name <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;文件名&#x27;</span>, </span><br><span class="line">  type TINYINT <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;0 表示文件，1 表示目录&#x27;</span>, </span><br><span class="line">  lft <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  rgt <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>Nested Sets 有如下特点：</p>
<ul>
<li>
<p>每一个节点有 <code>lft</code> 和 <code>rgt</code> 属性，记录区间左端点和右端点。比如 id 为 1 的节点的区间是 <code>(1, 22)</code>；</p>
</li>
<li>
<p>每一个节点的所有子节点的区间，都是它的区间的子区间。因此，一个区间对应一棵子树。比如 id 为 1 的节点的所有子节点的区间，一定是 <code>(1, 22)</code> 的子区间；</p>
</li>
<li>
<p>同层节点的区间不相交。比如第二层的区间为 <code>(2, 9)</code>、 <code>(10, 15)</code>、 <code>(16, 21)</code>；</p>
</li>
</ul>
<img src="./MDImgs/Store-Directory-Structure-In-DB/486af035-9d1a-43a6-861f-bce47cc010cb.jpeg" alt="img" style="zoom: 67%;" />
<p>这种设计的优点在于操作 2 是高效的，考虑递归遍历 id 为 1 的子树：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Item <span class="keyword">WHERE</span> lft <span class="operator">&gt;</span> <span class="number">1</span> <span class="keyword">AND</span> rgt <span class="operator">&lt;</span> <span class="number">22</span>;</span><br></pre></td></tr></table></figure>
<p>对于静态结构，所有节点的 <code>lft</code> 和 <code>rgt</code> 都是事先计算好的，直接批量插入数据库即可。但是要执行操作 1，即动态地修改有关节点的 <code>lft</code> 和 <code>rgt</code> ，其代价可想而知。</p>
<h1 id="JSON">JSON</h1>
<p>目录是一种结构化对象，并且是递归定义的。JSON 同理。因此，可以用 JSON 表示目录。</p>
<p>JSON 本质上是字符串，因此用任何数据库都可以存储，直接存在文件中亦可。</p>
<p>在这种情形下，对于目录结构的两种操作和文件系统的操作一致，因此操作的时间复杂度不高。而且操作都是在内存中进行的，故性能不错。</p>
<p>这种情况的缺点在于，当目录树很大时，（1）字符串和对象的转换时间增加；（2）内存占用增加；（3）客户端和服务器、服务器和数据库之间的网络开销过大。</p>
<p>第三点原因是 C/S 架构中 JSON 方案主要的弊端，因为它不如 RDBMS 方案：</p>
<ul>
<li>如果目录树很小，那么使用 RDBMS 和 JSON 都可以；</li>
<li>如果目录树很大，且查询多、修改少，那么 RDBMS 更好；</li>
<li>如果目录树很大，且修改频繁，尽管 JSON 在内存中操作速度更快，但网络通信频繁，且每个网络包都很大，导致带宽占用大，总体效果不一定优于 RDBMS。</li>
</ul>
<p>但是，如果是一个程序的本地数据库，JSON 无疑是最好的选择。</p>
<h1 id="总结">总结</h1>
<p>如何用 RDBMS 存储树形数据（比如文件目录）这一问题，实际上在 2005 到 2010 间就讨论过了，并且得出了完善的结论。从今天的角度看，NoSQL 的兴起似乎掩盖了本文探讨的问题的本质，让我对于该问题的探索走了弯路。</p>
<p>同时，数据库也是一个组件。正如我们不会为了存储目录结构而引入一个新的 NoSQL 数据库，如果只是要存储目录结构，我们甚至没必要引入数据库，直接使用 JSON 文件即可。</p>
<h1 id="参考">参考</h1>
<ul>
<li><a href="https://stackoverflow.com/questions/144344/how-to-store-directory-hierarchy-tree-structure-in-the-database">How to store directory / hierarchy / tree structure in the database?</a></li>
<li><a href="https://troels.arvin.dk/db/rdbms/links/#hierarchical">Hierarchical data in RDBMSs</a></li>
<li><a href="http://www.dbazine.com/oracle/or-articles/tropashko4/">Trees in SQL: Nested Sets and Materialized Path</a></li>
<li><a href="https://web.archive.org/web/20070210003309/http://www.intelligententerprise.com/001020/celko.jhtml?_requestid=697912">Trees in SQL (Internet Archive)</a></li>
<li><a href="https://web.archive.org/web/20050507133249/http://www.developerfusion.com:80/show/4633/2/">Tree structures in ASP.NET and SQL Server - Storing Trees in SQL Server  (Internet Archive)</a></li>
<li><a href="https://stackoverflow.com/questions/4048151/what-are-the-options-for-storing-hierarchical-data-in-a-relational-database">What are the options for storing hierarchical data in a relational database?</a></li>
<li><a href="https://vadimtropashko.wordpress.com/2008/08/09/one-more-nested-intervals-vs-adjacency-list-comparison/">One more Nested Intervals vs. Adjacency List comparison</a></li>
<li><a href="https://www.mongodb.com/docs/manual/applications/data-models-tree-structures/">MongoDB Manual: Model Tree Structures</a></li>
<li><a href="https://www.cnblogs.com/lvyahui/p/6439287.html">多级目录树（森林）的三种数据库存储结构介绍</a></li>
<li><a href="https://blog.uniauth.com/nested-set-model">Using Nested Set Model to Build Hierarchical Data</a></li>
</ul>
]]></content>
      <categories>
        <category>tech</category>
        <category>DBMS</category>
      </categories>
      <tags>
        <tag>DBMS</tag>
      </tags>
  </entry>
  <entry>
    <title>VS Code Remote SSH 密钥登录</title>
    <url>/2024/01/01/VS-Code-Remote-SSH-Login-By-Key/</url>
    <content><![CDATA[<h1 id="序言">序言</h1>
<p>VS Code 的 Remote SSH 插件提供了远程连接其他主机的功能。连接就需要用户名和密码，而密钥可以在每次登录时不输入密码、直接登录。</p>
<p>但是，VS Code 实际上只是提供了 GUI，而 SSH 如何使用密钥登录，则是另一码事。两者不应该混为一谈。</p>
<p>本文将主要讲解 SSH 密钥在本机和远程机器上如何配置。之后，讲解 VS Code Remote SSH 插件的使用。</p>
<span id="more"></span>
<h1 id="环境">环境</h1>
<ul>
<li>本机：Windows 10</li>
<li>远程机器：本地虚拟机 CentOS 8，root 用户</li>
</ul>
<h1 id="本机-SSH-配置">本机 SSH 配置</h1>
<p>使用 <code>ssh-keygen</code> 命令，会在 <code>C:\users\&lt;user&gt;\.ssh</code> 目录下创建<strong>本机</strong>的 RSA 公私钥：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\Gustav\.ssh&gt; <span class="built_in">dir</span></span><br><span class="line">    目录: C:\Users\Gustav\.ssh</span><br><span class="line">Mode                 LastWriteTime         Length Name</span><br><span class="line"><span class="literal">----</span>                 <span class="literal">-------------</span>         <span class="literal">------</span> <span class="literal">----</span></span><br><span class="line"><span class="literal">-a----</span>          <span class="number">2024</span>/<span class="number">1</span>/<span class="number">1</span>     <span class="number">12</span>:<span class="number">26</span>             <span class="number">91</span> config</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2023</span>/<span class="number">9</span>/<span class="number">30</span>     <span class="number">18</span>:<span class="number">03</span>           <span class="number">2610</span> id_rsa</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2023</span>/<span class="number">9</span>/<span class="number">30</span>     <span class="number">18</span>:<span class="number">03</span>            <span class="number">576</span> id_rsa.pub</span><br><span class="line"><span class="literal">-a----</span>        <span class="number">2023</span>/<span class="number">12</span>/<span class="number">18</span>     <span class="number">20</span>:<span class="number">42</span>           <span class="number">1398</span> known_hosts</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2023</span>/<span class="number">9</span>/<span class="number">30</span>     <span class="number">18</span>:<span class="number">03</span>             <span class="number">92</span> known_hosts.old</span><br></pre></td></tr></table></figure>
<p><code>id_rsa</code> 是私钥，<code>id_rsa.pub</code> 是公钥</p>
<h1 id="远程主机-SSH-配置">远程主机 SSH 配置</h1>
<p>将<strong>本机</strong>的 <code>id_rsa.pub</code> 上传到 Linux 远程主机的 <code>~/ssh</code> 目录，并改名为 <code>authorized_keys</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@CentOS100 .ssh]<span class="comment"># ll</span></span><br><span class="line">total 16</span><br><span class="line">-rw-r--r--. 1 root root 576 Jan  1 11:50 authorized_keys</span><br><span class="line">-rw-------. 1 root root 411 Jul  1  2023 id_ed25519</span><br><span class="line">-rw-r--r--. 1 root root  96 Jul  1  2023 id_ed25519.pub</span><br><span class="line">-rw-r--r--. 1 root root 880 Dec 18 21:07 known_hosts</span><br></pre></td></tr></table></figure>
<h1 id="测试">测试</h1>
<p>以上步骤，就是 SSH 密钥登录的全部配置。</p>
<p>打开本机的PowerShell，使用 <code>ssh &lt;user&gt;@&lt;ip&gt;</code> 测试连接。应该能够直接登录，不需要输入密码。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\Gustav&gt; ssh root@CentOS100</span><br><span class="line">Activate the web console with: systemctl enable <span class="literal">--now</span> cockpit.socket</span><br><span class="line"></span><br><span class="line">Last login: Mon Jan  <span class="number">1</span> <span class="number">12</span>:<span class="number">26</span>:<span class="number">15</span> <span class="number">2024</span> from &lt;ip&gt;</span><br><span class="line">[<span class="type">root</span>@<span class="type">CentOS100</span> ~]<span class="comment"># pwd</span></span><br><span class="line">/root</span><br></pre></td></tr></table></figure>
<h1 id="VS-Code-配置">VS Code 配置</h1>
<ol>
<li>
<p>安装 <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-ssh">Remote - SSH</a> 插件：</p>
<p><img src="./MDImgs/VS-Code-Remote-SSH-Login-By-Key/image-20240101130622357.png" alt="image-20240101130622357"></p>
</li>
<li>
<p>依次点击这3个按钮，进入配置文件：</p>
<p><img src="./MDImgs/VS-Code-Remote-SSH-Login-By-Key/image-20240101130733756.png" alt="image-20240101130733756"></p>
</li>
<li>
<p>填写配置文件（这个文件其实是主机的 SSH 配置）：</p>
<p><img src="./MDImgs/VS-Code-Remote-SSH-Login-By-Key/image-20240101130804525.png" alt="image-20240101130804525"></p>
<ul>
<li><code>Host</code>：识别这个远程连接的 Id，可以随便起个名字；</li>
<li><code>HostName</code>：远程主机的域名或 IP；</li>
<li><code>User</code>：登录远程主机的用户；</li>
<li><code>IdentityFile</code>：对应 <code>authorized_keys</code> 的<strong>私钥</strong>的存放位置；</li>
</ul>
</li>
</ol>
<p>关于配置文件的几点说明：</p>
<ul>
<li>如果没有在远程主机配置 <code>authorized_keys</code> ，那么 <code>IdentityFile</code> 属性不会起作用。登录时会要求输入密码；</li>
<li>在这个案例中，<code>IdentityFile</code> 其实没必要配置。因为 <code>authorized_keys</code> 就是本机的公钥，而 SSH 默认使用本机的私钥尝试连接；</li>
<li>一般情况下，<code>authorized_keys</code> 不会是本机的公钥，此时 <code>IdentityFile</code> 必须要配置，否则就要输入密码；</li>
</ul>
<h1 id="参考">参考</h1>
<ul>
<li><a href="https://medium.com/@sean4deepak/using-ssh-key-authentication-in-visual-studio-codes-remote-ssh-extension-4e5b922448e7">Using SSH Key Authentication in Visual Studio Code’ s Remote SSH Extension</a></li>
<li><a href="https://adamtheautomator.com/add-ssh-key-to-vs-code/">Add SSH Key to VS Code and Connect to a Host</a></li>
<li><a href="https://stackoverflow.com/questions/48328446/id-rsa-pub-file-ssh-error-invalid-format">id_rsa.pub file SSH Error: invalid format</a></li>
</ul>
]]></content>
      <categories>
        <category>softwares</category>
      </categories>
      <tags>
        <tag>settings</tag>
        <tag>VS Code</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title>对话 LLM：JWT 原理</title>
    <url>/2025/03/31/chat-with-LLM-JWT/</url>
    <content><![CDATA[<h1 id="序言">序言</h1>
<blockquote>
<p>『对话 LLM』是指在与 LLM 聊天工具（如 DeepSeek、ChatGPT）的对话中学习知识。通过 Q&amp;A 的方式学习，效率更高。『对话 LLM』的博文内容主要源自于我与 LLM 聊天工具的对话。</p>
</blockquote>
<p>本文讲述了 JWT 的原理、工作流程、优缺点。</p>
<span id="more"></span>
<h1 id="Q1-JWT-原理">Q1. JWT 原理</h1>
<p>Q:</p>
<p>介绍一下 JWT 的原理</p>
<p>A:</p>
<p>JSON Web Token（JWT）是一种开放标准（RFC 7519），用于在网络应用间安全地传输信息。其核心原理是通过数字签名或加密确保信息的完整性和可信性，常用于身份验证和授权。以下是JWT的详细原理和工作流程：</p>
<hr>
<p><strong>1. JWT的结构</strong>
JWT由三部分组成，用点（<code>.</code>）分隔，形式为：<code>Header.Payload.Signature</code> 。示例：<code>xxxxx.yyyyy.zzzzz</code></p>
<p><strong>1.1 Header（头部）</strong></p>
<ul>
<li><strong>作用</strong>：声明令牌类型（JWT）和签名算法（如HMAC SHA256或RSA）。</li>
<li><strong>格式</strong>：JSON对象经过Base64Url编码。</li>
<li>示例：<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span>  <span class="comment">// 签名算法</span></span><br><span class="line">  <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span>     <span class="comment">// 令牌类型</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>1.2 Payload（负载）</strong></p>
<ul>
<li><strong>作用</strong>：携带实际需要传递的数据（称为“声明”，Claims）。</li>
<li><strong>格式</strong>：JSON对象经过Base64Url编码。</li>
<li><strong>声明类型</strong>：
<ul>
<li><strong>预注册声明</strong>（Registered Claims）：标准字段，如<code>iss</code>（签发者）、<code>exp</code>（过期时间）、<code>sub</code>（主题）等。</li>
<li><strong>公共声明</strong>（Public Claims）：可自定义，但需避免冲突。</li>
<li><strong>私有声明</strong>（Private Claims）：双方协商的字段。</li>
</ul>
</li>
<li>示例：<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;user123&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Alice&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;exp&quot;</span><span class="punctuation">:</span> <span class="number">1620000000</span>  <span class="comment">// 过期时间戳</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>1.3 Signature（签名）</strong></p>
<ul>
<li><strong>作用</strong>：验证消息未被篡改，确保发送方的可信性。</li>
<li><strong>生成方式</strong>：将Base64Url编码后的Header和Payload用<code>.</code>拼接，再通过Header中指定的算法和密钥（Secret）生成签名。</li>
<li><strong>示例</strong>（使用HS256算法）：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">HMACSHA256</span>(</span><br><span class="line">  <span class="title function_">base64UrlEncode</span>(header) + <span class="string">&quot;.&quot;</span> + <span class="title function_">base64UrlEncode</span>(payload),</span><br><span class="line">  secretKey</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<p><strong>2. JWT的工作流程</strong></p>
<ol>
<li>
<p><strong>用户登录</strong>：客户端提交身份信息（如用户名密码）到服务器。</p>
</li>
<li>
<p><strong>生成JWT</strong>：服务器验证身份后，生成JWT：</p>
<ul>
<li>构造Header和Payload。</li>
<li>用密钥生成签名，组合三者形成完整的JWT。</li>
</ul>
</li>
<li>
<p><strong>返回JWT给客户端</strong>：客户端将JWT存储在本地（如LocalStorage或Cookie）。</p>
</li>
<li>
<p><strong>客户端携带JWT请求资源</strong> ：后续请求在<code>Authorization</code>头中以<code>Bearer</code>模式携带JWT：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Authorization: Bearer &lt;JWT&gt;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>服务器验证JWT</strong></p>
<ul>
<li>解码Header和Payload，检查签名是否有效（防止篡改）。</li>
<li>验证声明（如<code>exp</code>是否过期、<code>iss</code>是否合法）。</li>
<li>验证通过后，返回请求的资源。</li>
</ul>
</li>
</ol>
<hr>
<p><strong>3. JWT的安全性</strong></p>
<ul>
<li><strong>信息暴露</strong>：Header和Payload仅经过Base64编码，<strong>未加密</strong>，敏感信息（如密码）不应放入。</li>
<li><strong>传输安全</strong>：必须通过HTTPS传输，防止中间人攻击。</li>
<li><strong>密钥管理</strong>：
<ul>
<li>对称算法（如HS256）：需严格保护密钥。</li>
<li>非对称算法（如RS256）：用私钥签名，公钥验证，更安全。</li>
</ul>
</li>
<li><strong>防篡改</strong>：签名确保数据完整性，但需防止密钥泄露。</li>
</ul>
<hr>
<p><strong>4. JWT的优缺点</strong></p>
<p><strong>优点</strong></p>
<ul>
<li><strong>无状态</strong>：服务端无需存储会话信息，适合分布式系统。</li>
<li><strong>跨域支持</strong>：可轻松用于跨域场景（如微服务、单点登录）。</li>
<li><strong>灵活性</strong>：Payload可自定义扩展数据。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li><strong>无法废止</strong>：签发后有效期结束前无法强制失效（需结合Token黑名单或短有效期）。</li>
<li><strong>存储风险</strong>：客户端存储可能被XSS攻击窃取（建议用HttpOnly Cookie）。</li>
</ul>
<hr>
<p><strong>5. 典型应用场景</strong></p>
<ol>
<li>用户身份认证（如OAuth 2.0的Bearer Token）。</li>
<li>服务间API鉴权（微服务架构）。</li>
<li>单点登录（SSO）。</li>
</ol>
<hr>
<p>通过上述原理，JWT以紧凑、自包含的方式实现了安全的信息传输，成为现代Web开发中广泛使用的身份验证方案。</p>
<h1 id="Q2-哪些部分是明文？">Q2. 哪些部分是明文？</h1>
<p>Q:</p>
<p>三部分中哪些部分对于用户来说相当于是明文？</p>
<p>A:</p>
<p>在 JWT 的三部分（Header、Payload、Signature）中，<strong>Header 和 Payload 对用户来说是明文</strong>，而 Signature 是加密签名，无法直接解读。以下是详细解释：</p>
<hr>
<p><strong>1. Header 和 Payload 是明文</strong></p>
<ul>
<li>
<p><strong>原因</strong>：Header 和 Payload 仅经过 <strong>Base64Url 编码</strong>（一种 URL 安全的编码方式），<strong>并未加密</strong>。</p>
</li>
<li>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>可逆性</strong>：任何人均可通过 Base64Url 解码工具（如 <a href="https://jwt.io">jwt.io</a>）直接解码，得到原始的 JSON 数据。</li>
<li><strong>透明性</strong>：解码后的内容可被直接查看，例如：<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Header 解码后：</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Payload 解码后：</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;user123&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Alice&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;exp&quot;</span><span class="punctuation">:</span> <span class="number">1620000000</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>风险</strong>：</p>
<ul>
<li><strong>敏感信息泄露</strong>：如果在 Payload 中存储了敏感数据（如用户 ID、邮箱、权限），攻击者可轻易读取。</li>
<li><strong>篡改风险</strong>：虽然可被解码和修改，但无法伪造有效签名（需依赖密钥）。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>2. Signature 是密文</strong></p>
<ul>
<li><strong>原因</strong>：Signature 是 Header 和 Payload 的<strong>加密签名</strong>，由密钥和指定算法（如 HS256、RS256）生成。</li>
<li><strong>特点</strong>：
<ul>
<li><strong>不可逆性</strong>：无法通过解码直接获取原始信息，其本质是哈希值或加密后的二进制数据。</li>
<li><strong>防篡改作用</strong>：服务器通过验证 Signature 确保 Header 和 Payload 未被篡改。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>3. 用户视角的示例</strong></p>
<p>假设一个 JWT 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyMTIzIiwibmFtZSI6IkFsaWNlIiwiZXhwIjoxNjIwMDAwMDAwfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><strong>Header</strong>：<code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</code> 。解码后：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>Payload</strong>：<code>eyJzdWIiOiJ1c2VyMTIzIiwibmFtZSI6IkFsaWNlIiwiZXhwIjoxNjIwMDAwMDAwfQ</code> 。解码后：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;user123&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Alice&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;exp&quot;</span><span class="punctuation">:</span> <span class="number">1620000000</span> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>Signature</strong>：<code>SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</code> 。无法直接解码，需用密钥验证。</p>
</li>
</ul>
<hr>
<p><strong>4. 安全建议</strong></p>
<ol>
<li><strong>避免敏感数据</strong>：不要在 Header 或 Payload 中存储密码、密钥等敏感信息。</li>
<li><strong>使用 HTTPS</strong>：防止 JWT 在传输中被窃取。</li>
<li><strong>短有效期</strong>：通过 <code>exp</code> 字段设置合理过期时间，减少泄露风险。</li>
<li><strong>加密敏感字段</strong>：如需存储敏感数据，可对 Payload 进行额外加密（如 JWE）。</li>
</ol>
<hr>
<p><strong>总结</strong></p>
<ul>
<li><strong>明文部分</strong>：Header 和 Payload（Base64Url 编码，可逆）。</li>
<li><strong>密文部分</strong>：Signature（加密签名，不可逆）。</li>
<li><strong>核心安全机制</strong>：依赖 Signature 防止数据篡改，而非隐藏数据本身。</li>
</ul>
<h1 id="Q3-哈希与加密">Q3. 哈希与加密</h1>
<p>Q:</p>
<p>所以 Signature 会将 Header + Payload先哈希，再对哈希值进行加密？
服务端收到 Signature 后，先解密，再验证哈希值是否正确？</p>
<p>A:</p>
<p>你的问题涉及 JWT 签名生成和验证的核心机制，但需要明确区分 <strong>哈希（Hash）</strong> 和 <strong>加密（Encryption）</strong> 的概念。不同签名算法（如 <code>HS256</code> 和 <code>RS256</code>）的实现方式不同，具体流程如下：</p>
<hr>
<p><strong>1. JWT 签名的生成过程</strong></p>
<p><strong>(1) HMAC 算法（如 HS256）</strong></p>
<ul>
<li><strong>核心机制</strong>：基于密钥的哈希（<strong>无需加密</strong>）。</li>
<li><strong>步骤</strong>：
<ol>
<li>将 Header 和 Payload 进行 Base64Url 编码，并用 <code>.</code> 拼接（得到 <code>header_b64.payload_b64</code>）。</li>
<li><strong>对拼接后的字符串计算哈希</strong>：使用 HMAC + 哈希算法（如 SHA256）和密钥生成消息认证码（MAC）。</li>
<li><strong>生成签名</strong>：将哈希结果进行 Base64Url 编码，得到 Signature。</li>
</ol>
</li>
<li><strong>公式</strong>：<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Signature = Base64UrlEncode(HMAC_SHA256(header_b64.payload_b64, secret_key))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>(2) RSA 算法（如 RS256）</strong></p>
<ul>
<li><strong>核心机制</strong>：基于非对称加密的签名（<strong>涉及加密</strong>）。</li>
<li><strong>步骤</strong>：
<ol>
<li>将 Header 和 Payload 进行 Base64Url 编码并拼接（<code>header_b64.payload_b64</code>）。</li>
<li><strong>对拼接后的字符串计算哈希</strong>：使用哈希算法（如 SHA256）生成哈希值。</li>
<li><strong>加密哈希值</strong>：用私钥对哈希值进行加密（即数字签名）。</li>
<li><strong>生成签名</strong>：将加密后的结果进行 Base64Url 编码，得到 Signature。</li>
</ol>
</li>
<li><strong>公式</strong>：<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Signature = Base64UrlEncode(RSA_Encrypt(SHA256(header_b64.payload_b64), private_key))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<p><strong>2. 服务端的验证过程</strong></p>
<p>服务端收到 JWT 后，验证签名的逻辑如下：</p>
<p><strong>(1) HMAC 算法（HS256）</strong></p>
<ul>
<li><strong>无需解密</strong>：因为 HMAC 是密钥哈希，不是加密。</li>
<li><strong>验证步骤</strong>：
<ol>
<li>重新计算 <code>header_b64.payload_b64</code> 的 HMAC 哈希（使用相同的密钥）。</li>
<li>将计算结果与客户端传来的 Signature 解码后的值对比。</li>
<li>若一致，则数据未被篡改。</li>
</ol>
</li>
</ul>
<p><strong>(2) RSA 算法（RS256）</strong></p>
<ul>
<li><strong>需要“解密”</strong>：这里的“解密”实质是验证签名。</li>
<li><strong>验证步骤</strong>：
<ol>
<li>用公钥对 Signature 解码后的密文进行解密，得到原始哈希值。</li>
<li>重新计算 <code>header_b64.payload_b64</code> 的哈希值（如 SHA256）。</li>
<li>对比解密后的哈希值与重新计算的哈希值。</li>
<li>若一致，则数据未被篡改。</li>
</ol>
</li>
</ul>
<hr>
<p><strong>3. 关键区别总结</strong></p>
<table>
<thead>
<tr>
<th><strong>算法类型</strong></th>
<th>哈希（HMAC）</th>
<th>非对称加密（RSA）</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>签名生成</strong></td>
<td>基于密钥的哈希，无需加密</td>
<td>私钥加密哈希值</td>
</tr>
<tr>
<td><strong>签名验证</strong></td>
<td>重新计算哈希对比</td>
<td>公钥解密签名，对比哈希值</td>
</tr>
<tr>
<td><strong>密钥管理</strong></td>
<td>对称密钥（服务端保管）</td>
<td>非对称密钥（私钥签名，公钥验证）</td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td>依赖密钥保密性</td>
<td>依赖私钥安全性</td>
</tr>
</tbody>
</table>
<hr>
<p><strong>4. 回答你的问题</strong></p>
<ul>
<li>
<p><strong>问题 1</strong>：<em>“Signature 会将 Header + Payload 先哈希，再对哈希值进行加密？”</em></p>
<ul>
<li><strong>答案</strong>：
<ul>
<li>对于 <strong>HMAC（如 HS256）</strong>：<strong>仅哈希，不加密</strong>（但哈希过程依赖密钥）。</li>
<li>对于 <strong>RSA（如 RS256）</strong>：<strong>先哈希，再加密哈希值</strong>（用私钥加密）。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>问题 2</strong>：<em>“服务端收到 Signature 后，先解密，再验证哈希值是否正确？”</em></p>
<ul>
<li><strong>答案</strong>：
<ul>
<li>对于 <strong>HMAC</strong>：<strong>无需解密</strong>，直接重新计算哈希对比。</li>
<li>对于 <strong>RSA</strong>：<strong>需要解密</strong>（用公钥解密签名，得到哈希值后再对比）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<p><strong>5. 技术误区澄清</strong></p>
<ul>
<li><strong>哈希 ≠ 加密</strong>：
<ul>
<li>哈希是单向不可逆的（如 SHA256），用于确保数据完整性。</li>
<li>加密是双向可逆的（如 RSA），用于保护数据机密性。</li>
</ul>
</li>
<li><strong>JWT 签名的本质</strong>：
<ul>
<li>HMAC 是 <strong>密钥化哈希</strong>（完整性 + 身份验证）。</li>
<li>RSA 是 <strong>加密哈希值</strong>（完整性 + 非抵赖性）。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>6. 实际代码示例（伪代码）</strong></p>
<p><strong>HS256 签名验证</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">verify_hmac</span>(<span class="params">jwt, secret_key</span>):</span><br><span class="line">    header_b64, payload_b64, signature_b64 = jwt.split(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">    data = header_b64 + <span class="string">&quot;.&quot;</span> + payload_b64</span><br><span class="line">    expected_signature = HMAC_SHA256(data, secret_key)</span><br><span class="line">    <span class="keyword">return</span> expected_signature == base64url_decode(signature_b64)</span><br></pre></td></tr></table></figure>
<p><strong>RS256 签名验证</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">verify_rsa</span>(<span class="params">jwt, public_key</span>):</span><br><span class="line">    header_b64, payload_b64, signature_b64 = jwt.split(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">    data = header_b64 + <span class="string">&quot;.&quot;</span> + payload_b64</span><br><span class="line">    decoded_signature = base64url_decode(signature_b64)</span><br><span class="line">    decrypted_hash = RSA_Decrypt(decoded_signature, public_key)  <span class="comment"># 用公钥“解密”</span></span><br><span class="line">    actual_hash = SHA256(data)</span><br><span class="line">    <span class="keyword">return</span> decrypted_hash == actual_hash</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>总结</strong></p>
<ul>
<li>JWT 的签名机制根据算法不同，流程有所差异：
<ul>
<li><strong>HMAC</strong>：依赖密钥哈希，验证时直接对比哈希值。</li>
<li><strong>RSA</strong>：用私钥加密哈希值，验证时用公钥解密并对比。</li>
</ul>
</li>
<li><strong>核心目标</strong>：确保 Header 和 Payload 未被篡改，而非加密数据本身。</li>
<li><strong>安全建议</strong>：根据场景选择算法（HS256 简单高效，RS256 更适合分布式系统）。</li>
</ul>
<h1 id="Q4-前向保密">Q4. 前向保密</h1>
<p>Q:</p>
<p>按照你的说法，无论 HMAC 或是 RSA，JWT 都不支持前向保密</p>
<p>A:</p>
<p>是的，你的理解是正确的。<strong>JWT（无论是使用 HMAC 还是 RSA 签名算法）本身并不支持前向保密（Forward Secrecy, FS）</strong>。以下是详细解释：</p>
<hr>
<p><strong>1. 前向保密（Forward Secrecy）的核心概念</strong></p>
<p>前向保密是一种安全特性，要求即使长期密钥（如服务器的私钥或 HMAC 的共享密钥）在未来被泄露，攻击者也无法解密过去的通信数据或伪造历史会话。<br>
<strong>实现前向保密的关键</strong>：每次会话使用临时生成的密钥（如 TLS 中的 ECDHE 密钥交换），会话结束后密钥立即销毁，不依赖长期密钥。</p>
<hr>
<p><strong>2. JWT 的签名机制为何不支持前向保密</strong></p>
<p><strong>(1) HMAC（对称签名算法，如 HS256）</strong></p>
<ul>
<li><strong>依赖长期密钥</strong>：HMAC 的签名和验证使用同一个共享密钥（<code>secret_key</code>），且该密钥通常长期有效。</li>
<li><strong>风险</strong>：一旦 <code>secret_key</code> 泄露，攻击者可伪造任意历史或未来的 JWT。</li>
<li><strong>无临时密钥机制</strong>：HMAC 的密钥不随会话变化，无法实现前向保密。</li>
</ul>
<p><strong>(2) RSA（非对称签名算法，如 RS256）</strong></p>
<ul>
<li><strong>依赖长期私钥</strong>：签名使用固定的私钥，公钥用于验证。</li>
<li><strong>风险</strong>：私钥泄露后，攻击者可伪造历史或未来的 JWT。</li>
<li><strong>密钥固定性</strong>：RSA 私钥通常长期不变，签名过程不涉及临时密钥。</li>
</ul>
<hr>
<p><strong>3. 为什么 JWT 不原生支持前向保密？</strong></p>
<ul>
<li><strong>设计目标不同</strong>：JWT 的核心目标是实现无状态、自包含的令牌机制，而非动态会话管理。</li>
<li><strong>静态令牌特性</strong>：JWT 一旦签发，其有效性完全依赖签名和声明（如 <code>exp</code>），无法动态更新密钥。</li>
<li><strong>场景限制</strong>：JWT 常用于身份认证和授权，而非端到端加密通信，因此未引入复杂的密钥协商机制。</li>
</ul>
<hr>
<p><strong>4. 如何缓解 JWT 缺乏前向保密的风险？</strong></p>
<p>虽然 JWT 本身不支持前向保密，但可通过以下策略降低风险：</p>
<p><strong>(1) 短期令牌有效期</strong></p>
<ul>
<li>设置较短的 <code>exp</code>（过期时间），例如 15 分钟到 1 小时，减少密钥泄露后的攻击窗口。</li>
<li>配合刷新令牌（Refresh Token）机制，动态更新访问令牌。</li>
</ul>
<p><strong>(2) 密钥轮换（Key Rotation）</strong></p>
<ul>
<li>定期更换 HMAC 的共享密钥或 RSA 的私钥。</li>
<li>对于已签发的 JWT，需在密钥轮换后强制失效（例如结合黑名单或短有效期）。</li>
</ul>
<p><strong>(3) 结合 TLS 的前向保密</strong></p>
<ul>
<li>在传输层使用 TLS 1.3，启用支持前向保密的密码套件（如 <code>ECDHE-ECDSA-AES128-GCM-SHA256</code>）。</li>
<li>确保 JWT 在传输过程中通过安全通道（HTTPS），防止窃听和中间人攻击。</li>
</ul>
<p><strong>(4) 使用无状态短期令牌</strong></p>
<ul>
<li>例如 OAuth 2.0 的 <code>access_token</code>（通常为 JWT）设计为短期有效，结合服务端状态管理（如数据库记录令牌状态）。</li>
</ul>
<p><strong>(5) 敏感数据加密</strong></p>
<ul>
<li>对 JWT 的 Payload 敏感字段额外加密（如使用 JWE）。</li>
<li>使用混合方案：JWT 签名确保完整性，加密确保机密性。</li>
</ul>
<hr>
<p><strong>5. 替代方案：支持前向保密的令牌机制</strong></p>
<p>如果业务场景对前向保密有严格要求，可考虑其他方案：</p>
<ul>
<li><strong>动态会话密钥</strong>：在服务端为每个会话生成临时密钥，签名后传递给客户端（但违背 JWT 无状态的设计理念）。</li>
<li><strong>基于会话的令牌</strong>：改用有状态的会话 Cookie，结合服务端存储的临时密钥（牺牲无状态性，换取前向保密）。</li>
<li><strong>端到端加密协议</strong>：在应用层实现前向保密（如 Signal 协议），但复杂度较高。</li>
</ul>
<hr>
<p><strong>6. 总结</strong></p>
<ul>
<li><strong>JWT 不支持前向保密</strong>：因其依赖长期有效的密钥（HMAC 的共享密钥或 RSA 的私钥）。</li>
<li><strong>缓解措施</strong>：通过短期令牌、密钥轮换、TLS 前向保密等方式降低风险。</li>
<li><strong>权衡设计</strong>：JWT 的简洁性和无状态特性与安全性需结合业务场景权衡。</li>
</ul>
<hr>
<p>若业务对前向保密有强需求，建议在传输层（TLS）或应用层协议（如 OAuth 2.0 的短期令牌）中实现，而非依赖 JWT 自身机制。</p>
<h1 id="Q5-JWT-的另一种表述">Q5. JWT 的另一种表述</h1>
<p>Q:</p>
<p>在登录场景中，我是否可以将 JWT 技术理解为：服务端不使用 session，完全使用 cookie 存放一些用户相关的信息，同时该 cookie 无法被用户篡改。</p>
<p>A:</p>
<p>在登录场景中，你的理解基本正确。</p>
<h1 id="Q6-JWT-头部的作用">Q6. JWT 头部的作用</h1>
<p>Q:</p>
<p>为啥要在 Header（头部）中声明令牌类型（JWT）和签名算法（如HMAC SHA256或RSA）？</p>
<p>验证 payload 是否被篡改完全是服务端的工作，我的理解正确吗？那这样的话，为什么要把这个信息在客户端、服务端之间传输呢？</p>
<p>这是为了让服务端兼容多种验证方式吗？</p>
<p>A:</p>
<p><strong>1. Header 中声明令牌类型和算法的原因</strong></p>
<p>JWT 的 Header 中必须包含 <code>alg</code>（签名算法）和 <code>typ</code>（令牌类型）字段，这是由 <strong>JWT 标准（RFC 7519）</strong> 明确规定的。其必要性体现在以下几个方面：</p>
<hr>
<p><strong>(1) 服务端需要动态选择验证方式</strong></p>
<ul>
<li><strong>场景</strong>：服务端可能支持多种签名算法（如同时兼容 <code>HS256</code> 和 <code>RS256</code>）。</li>
<li><strong>问题</strong>：如果 Header 不声明算法，服务端无法知道该用哪种算法和密钥去验证签名。</li>
<li><strong>示例</strong>：<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Header</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;RS256&quot;</span><span class="punctuation">,</span>  <span class="comment">// 服务端看到此字段后，选择公钥验证 RSA 签名</span></span><br><span class="line">  <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<p><strong>(2) 防止算法混淆攻击（Algorithm Confusion Attack）</strong></p>
<ul>
<li><strong>背景</strong>：攻击者可能篡改 Header 中的 <code>alg</code> 字段，诱导服务端使用错误的算法验证签名（例如将 <code>RS256</code> 改为 <code>HS256</code>）。</li>
<li><strong>防御措施</strong>：
<ul>
<li>服务端应严格校验 <code>alg</code> 字段是否为预期值（如只允许 <code>RS256</code>）。</li>
<li><strong>绝不依赖客户端声明的算法</strong>，而是通过配置固定服务端支持的算法。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>(3) 明确令牌类型</strong></p>
<ul>
<li><strong>作用</strong>：<code>typ: &quot;JWT&quot;</code> 表明这是一个标准的 JWT 令牌，避免与其他类型令牌（如加密的 JWE）混淆。</li>
<li><strong>扩展性</strong>：如果未来需要支持新类型的令牌（如 <code>JWT+XML</code>），可通过此字段区分。</li>
</ul>
<hr>
<p><strong>2. 为什么需要将 Header 传输到客户端？</strong></p>
<ul>
<li><strong>核心逻辑</strong>：JWT 是 <strong>自包含的令牌</strong>，服务端无需存储额外信息即可验证它。
<ul>
<li><strong>验证签名</strong>：服务端需要 Header 中的 <code>alg</code> 字段知道如何验证签名。</li>
<li><strong>解码 Payload</strong>：服务端需要 Header 中的声明（如 <code>cty</code> 自定义内容类型）来正确解析 Payload。</li>
</ul>
</li>
<li><strong>无状态设计</strong>：若 Header 不包含算法信息，服务端需额外存储每个令牌的元数据，违背 JWT 的无状态原则。</li>
</ul>
<hr>
<p><strong>3. 验证篡改是否完全是服务端的工作？</strong></p>
<ul>
<li><strong>正确性</strong>：是的，客户端无法验证 JWT 的合法性，这是服务端的职责。</li>
<li><strong>客户端角色</strong>：
<ul>
<li>仅存储和传输 JWT（如通过 Cookie）。</li>
<li><strong>不参与签名验证</strong>（即使客户端解码 Header/Payload，也无法确保签名有效）。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>4. 为什么 Header 信息需要传输？</strong></p>
<p><strong>(1) 技术必要性</strong></p>
<ul>
<li><strong>签名验证依赖 Header</strong>：签名的生成基于完整的 Header 和 Payload，服务端必须获取原始的 Header 和 Payload 才能重新计算签名进行对比。</li>
</ul>
<p><strong>(2) 安全风险与误区</strong></p>
<ul>
<li><strong>误区</strong>：“Header 传输算法信息会导致安全隐患”。
<ul>
<li><strong>事实</strong>：攻击者无法通过篡改 <code>alg</code> 字段绕过验证，因为服务端会强制校验签名是否与声明的算法一致。</li>
<li><strong>安全实践</strong>：服务端应配置允许的算法白名单（如只允许 <code>RS256</code>），忽略客户端声明的其他算法。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>5. 是否为了兼容多种验证方式？</strong></p>
<ul>
<li><strong>部分正确</strong>：Header 中的 <code>alg</code> 允许服务端支持多算法，但这不是主要目的。</li>
<li><strong>核心目的</strong>：
<ol>
<li><strong>无状态验证</strong>：服务端无需预先知道令牌的签名方式。</li>
<li><strong>算法声明</strong>：确保签名生成和验证过程的一致性。</li>
<li><strong>防止算法混淆</strong>：明确约束签名机制。</li>
</ol>
</li>
</ul>
<hr>
<p><strong>6. 实际场景示例</strong></p>
<p><strong>(1) 多租户系统</strong></p>
<ul>
<li>不同租户使用不同签名算法（如租户 A 用 <code>HS256</code>，租户 B 用 <code>RS256</code>）。</li>
<li>服务端根据 Header 中的 <code>alg</code> 动态选择对应的验证方式。</li>
</ul>
<p><strong>(2) 算法升级</strong></p>
<ul>
<li>旧系统使用 <code>HS256</code>，新系统升级到 <code>RS256</code>。</li>
<li>服务端通过 Header 中的 <code>alg</code> 兼容新旧令牌，逐步淘汰旧算法。</li>
</ul>
<hr>
<p><strong>总结</strong></p>
<ul>
<li><strong>Header 中的 <code>alg</code> 和 <code>typ</code> 是必要的</strong>：服务端需要这些信息正确验证签名和解析令牌。</li>
<li><strong>安全责任在服务端</strong>：必须严格校验算法、签名和声明，而非依赖客户端传递的信息。</li>
<li><strong>传输 Header 无额外风险</strong>：攻击者无法通过篡改 Header 绕过验证（只要服务端实现正确）。</li>
</ul>
<h1 id="Q7-可以去掉-JWT-头部吗？">Q7. 可以去掉 JWT 头部吗？</h1>
<p>Q:</p>
<p>如果服务端只支持 JWT，且只有一种加密算法。不考虑 JWT 规范，我们是否可以不要传递 header？</p>
<p>A:</p>
<p><strong>分步解析与建议</strong></p>
<p><strong>1. 技术可行性分析</strong></p>
<p>如果服务端<strong>仅支持一种固定算法</strong>（如 <code>HS256</code>）且<strong>不遵循 JWT 标准</strong>，理论上可以移除 Header 字段，但需重新设计令牌结构。以下是两种方案的对比：</p>
<table>
<thead>
<tr>
<th><strong>方案</strong></th>
<th>标准 JWT（带 Header）</th>
<th>无 Header 的自定义令牌</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>结构</strong></td>
<td><code>Header.Payload.Signature</code></td>
<td><code>Payload.Signature</code></td>
</tr>
<tr>
<td><strong>签名生成方式</strong></td>
<td><code>HMAC(Header_b64.Payload_b64)</code></td>
<td><code>HMAC(Payload_b64)</code></td>
</tr>
<tr>
<td><strong>服务端验证</strong></td>
<td>读取 Header 中的算法，动态验证</td>
<td>固定算法（如 <code>HS256</code>）直接验证</td>
</tr>
<tr>
<td><strong>兼容性</strong></td>
<td>兼容 JWT 生态工具（如库、调试器）</td>
<td>需完全自定义实现</td>
</tr>
</tbody>
</table>
<hr>
<p><strong>2. 潜在风险与限制</strong></p>
<table>
<thead>
<tr>
<th><strong>风险/限制</strong></th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>签名范围不一致</strong></td>
<td>签名未包含 Header，若未来需扩展元数据（如令牌版本），需重新设计签名逻辑，可能导致兼容性问题。</td>
</tr>
<tr>
<td><strong>算法升级困难</strong></td>
<td>硬编码算法后，若需更换算法（如迁移到 <code>RS256</code>），需强制所有客户端升级，无法平滑过渡。</td>
</tr>
<tr>
<td><strong>生态工具不兼容</strong></td>
<td>无法使用标准 JWT 库（如 <code>jsonwebtoken</code>），需自行实现编解码和签名验证，增加开发成本。</td>
</tr>
<tr>
<td><strong>安全审计复杂性</strong></td>
<td>自定义方案需独立安全评估，而标准 JWT 的安全性已被广泛验证。</td>
</tr>
</tbody>
</table>
<hr>
<p><strong>总结</strong></p>
<ul>
<li><strong>可以移除 Header</strong>：在服务端严格固定算法的场景下，技术上可行。</li>
<li><strong>代价</strong>：牺牲标准化、灵活性和工具兼容性，需自行承担安全风险。</li>
<li><strong>推荐场景</strong>：仅适用于封闭、小规模系统，且需长期维护自定义实现。</li>
</ul>
<h1 id="其他">其他</h1>
<p>常见的两种解决集群部署 web 服务器时 session 共享问题的方案：</p>
<ul>
<li>一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。</li>
<li>另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。</li>
</ul>
<h1 id="参考">参考</h1>
<ul>
<li><a href="https://xiaolincoding.com/interview/network.html#%E5%89%8D%E7%AB%AF%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8jwt%E7%9A%84">小林 coding：前端是如何存储JWT的？</a></li>
</ul>
]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>对话 LLM</tag>
        <tag>JWT</tag>
      </tags>
  </entry>
  <entry>
    <title>Jellyfin 显示原始文件名</title>
    <url>/2024/02/17/jellyfin-original-filename/</url>
    <content><![CDATA[<h1 id="序言">序言</h1>
<p>Jellyfin 的设计理念是用户按照其媒体规则，创建对应层级的文件夹，放入媒体文件，再根据网络刮削器得到的元数据修改文件标题。但是这种规则过分强制了，以至于<strong>使用原始文件名作为标题</strong>的功能都没有。我们当然可以手动修改媒体标题，但这样太麻烦了。</p>
<p>基于这种需求，我使用 <a href="https://github.com/jellyfin/jellyfin-apiclient-python">jellyfin-apiclient-python</a> 写了一个脚本，来批量重命名某个媒体库下的所有媒体。同时，本文也列举了以往的一些方案。在我看来，以前的方案都不尽人意。</p>
<span id="more"></span>
<h1 id="已有方案-1">已有方案 1</h1>
<p>创建媒体库时选择『音乐视频』，同时选择『优先使用内置的标题而不是文件名』。</p>
<p>这个“内置标题”是什么？—— 打开一个视频的『属性』，进入『详细信息』。</p>
<p><img src="./MDImgs/jellyfin-original-filename/image-20240217135326419.png" alt="image-20240217135326419"></p>
<p>在『标题』一栏填写的任何内容，都会如实地作为媒体标题显示在 Jellyfin 客户端上，不会有任何修改。</p>
<p>这种做法有两个问题：</p>
<p>1️⃣几乎所有的动漫搬运组在发布时，都会填入『标题』属性。如上图，『标题』里只有番名，没有剧集号。</p>
<p>这个问题其实很好解决，我们可以把文件名复制到『标题』中，也可以把『标题』清空。无论哪种方法，最终都会显示原始文件名。Python 的话可以使用 <a href="https://github.com/quodlibet/mutagen">mutagen</a> 模块自动化处理。</p>
<p>2️⃣『音乐视频』这种类型的媒体库无法显示文件夹结构。事实上，只有『混合电影和电视剧』才会以纯文件夹的形式展示。这一点我无法接受。</p>
<h1 id="已有方案-2">已有方案 2</h1>
<p>直接修改数据库，参考<a href="https://www.cnblogs.com/toumingbai/p/15514526.html">『jellyfin手动修正标题为文件（夹）名』</a>。</p>
<p>绕过 Service 层直接操作数据库，太危险了，完全不考虑这种方案。</p>
<h1 id="我的方案">我的方案</h1>
<p>既然方案 2 直接操作数据库不好，我们为何不使用 Jellyfin API？</p>
<p>首先要确定哪个功能用哪个 API。不要先看官网的文档，而是直接浏览器 F12 抓包，然后再回查文档。不过大部分情况下文档依旧没用，因为基本没有描述。此时我们基本只能靠猜测和实验了。</p>
<p>万幸，<a href="https://github.com/jellyfin/jellyfin-apiclient-python">jellyfin-apiclient-python</a> 提供了现成的 API，不需要从 <code>requests</code> 开始写。我很快写好了脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> jellyfin_apiclient_python <span class="keyword">import</span> JellyfinClient</span><br><span class="line"><span class="keyword">from</span> jellyfin_apiclient_python.api <span class="keyword">import</span> API</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rename_to_filename</span>(<span class="params">jellyfin: API, item_id: <span class="built_in">str</span></span>):</span><br><span class="line">    metadata: <span class="built_in">dict</span> = jellyfin.get_item(item_id)</span><br><span class="line">    <span class="keyword">assert</span> metadata[<span class="string">&#x27;Id&#x27;</span>] == item_id</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(metadata[<span class="string">&#x27;MediaSources&#x27;</span>]) == <span class="number">1</span></span><br><span class="line">    path: <span class="built_in">str</span> = metadata[<span class="string">&#x27;MediaSources&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;Path&#x27;</span>]</span><br><span class="line">    filename = path.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 只修改 Name，其他信息不变</span></span><br><span class="line">    metadata.update(&#123;<span class="string">&#x27;Name&#x27;</span>: filename&#125;)</span><br><span class="line">    <span class="keyword">return</span> jellyfin.items(<span class="string">&#x27;/&#x27;</span> + item_id, action=<span class="string">&#x27;POST&#x27;</span>, params=<span class="literal">None</span>, json=metadata)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rename_items_in_library</span>(<span class="params">jellyfin: API, library_id: <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="comment"># get_items_by_letter 会递归地查所有子文件夹中的元素</span></span><br><span class="line">    res = jellyfin.get_items_by_letter(parent_id=library_id)</span><br><span class="line">    res = res[<span class="string">&#x27;Items&#x27;</span>]</span><br><span class="line">    item_count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> res:</span><br><span class="line">        <span class="keyword">if</span> r[<span class="string">&#x27;Type&#x27;</span>] == <span class="string">&#x27;Folder&#x27;</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        rename_to_filename(jellyfin, r[<span class="string">&#x27;Id&#x27;</span>])</span><br><span class="line">        item_count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;total renamed item count: <span class="subst">&#123;item_count&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">client = JellyfinClient()</span><br><span class="line"><span class="comment"># 这些客户端信息可以改成你自己的，不过没影响</span></span><br><span class="line">client.config.app(<span class="string">&#x27;pycharm&#x27;</span>, <span class="string">&#x27;0.0.1&#x27;</span>, <span class="string">&#x27;pycharm&#x27;</span>, <span class="string">&#x27;kufhskdf&#x27;</span>)</span><br><span class="line">client.config.data[<span class="string">&quot;auth.ssl&quot;</span>] = <span class="literal">True</span></span><br><span class="line">client.authenticate(&#123;<span class="string">&quot;Servers&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;AccessToken&quot;</span>: <span class="string">&quot;xxx&quot;</span>,  <span class="comment"># 去『控制台 | API 密钥』创建一个</span></span><br><span class="line">        <span class="string">&quot;address&quot;</span>: <span class="string">&quot;zzz&quot;</span>, <span class="comment"># Jellyfin 服务器的地址</span></span><br><span class="line">        <span class="string">&quot;DateLastAccessed&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">&quot;UserId&quot;</span>: <span class="string">&quot;yyy&quot;</span>  <span class="comment"># 这个用户需要有管理媒体库的权限</span></span><br><span class="line">    &#125;</span><br><span class="line">]&#125;, discover=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(client.logged_in)</span><br><span class="line"></span><br><span class="line">rename_items_in_library(client.jellyfin, <span class="string">&#x27;uuu&#x27;</span>)  <span class="comment"># 填入媒体库的 id</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>话说回来，这个模块的文档写得也不咋地，我从 Issues 中才知道怎么连接服务器。</p>
</blockquote>
<p>我的 Jellyfin 服务器的证书是自己搞的，Python 的 SSL 好像没办法使用操作系统安装的证书。可以设置环境变量 <code>REQUESTS_CA_BUNDLE=证书地址</code> 来解决。</p>
<p>使用我的方案，就完美地解决了上述两种方案的缺点。</p>
<h1 id="参考">参考</h1>
<ul>
<li><a href="https://www.reddit.com/r/jellyfin/comments/pcptfz/possible_to_use_original_filenames_only/?utm_source=share&amp;utm_medium=web2x&amp;context=3">Possible to use original filenames only?</a></li>
<li><a href="https://www.cnblogs.com/toumingbai/p/15514526.html">jellyfin手动修正标题为文件（夹）名</a></li>
<li><a href="https://github.com/jellyfin/jellyfin-apiclient-python">jellyfin-apiclient-python</a></li>
</ul>
]]></content>
      <categories>
        <category>tech</category>
        <category>NAS</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>NAS</tag>
        <tag>Jellyfin</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 369 周赛总结</title>
    <url>/2023/10/29/leetcode-369-weekly-contest-summary/</url>
    <content><![CDATA[<h1 id="概要">概要</h1>
<blockquote>
<p><a href="https://leetcode.cn/contest/weekly-contest-369/">力扣第 369 场周赛</a></p>
</blockquote>
<blockquote>
<p>本文只是周赛的总结，我不准备详细地讨论每一道题，只会给出大致思路。重点还是在于自己的总结、反思和提高。</p>
</blockquote>
<p>赛后来看，这场比赛难度不大。做题情况简要描述：</p>
<ul>
<li>第一题：简单模拟，送分题；</li>
<li>第二题：难度不大，但要考虑多种情况，我没有静下心来细想，造成了 3 个 WA 😒；</li>
<li>第三题：难度中等的 DP，一开始没有想出来，转而去做最终没做出来的第四题，浪费了时间。好在后来很快做出来了😋；</li>
<li>第四题：虽然是困难题，并且没有做出来，但比赛的代码最终也只是超时，赛后我也自己想出来了优化的方法——不难。值得注意的是，写代码时的逻辑混乱还是造成了 2 个 WA 😒；</li>
</ul>
<span id="more"></span>
<h1 id="一、找出数组中的-K-or-值">一、<a href="https://leetcode.cn/problems/find-the-k-or-of-an-array/">找出数组中的 K-or 值</a></h1>
<p><img src="./MDImgs/leetcode-369-weekly-contest-summary/image-20231029195438014.png" alt="image-20231029195438014"></p>
<p><img src="./MDImgs/leetcode-369-weekly-contest-summary/image-20231029195448237.png" alt="image-20231029195448237"></p>
<p><img src="./MDImgs/leetcode-369-weekly-contest-summary/image-20231029195455078.png" alt="image-20231029195455078"></p>
<p>题目描述有点难懂，比赛时需要结合示例才能快速读懂</p>
<p>逐比特模拟：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKOr</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((num &amp; val) &gt; <span class="number">0</span>) count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count &gt;= k)  &#123;</span><br><span class="line">                ans |= val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：$O(n)$</p>
<h1 id="二、数组的最小相等和">二、<a href="https://leetcode.cn/problems/minimum-equal-sum-of-two-arrays-after-replacing-zeros/">数组的最小相等和</a></h1>
<p><img src="./MDImgs/leetcode-369-weekly-contest-summary/image-20231029195518874.png" alt="image-20231029195518874"></p>
<p><img src="./MDImgs/leetcode-369-weekly-contest-summary/image-20231029195534194.png" alt="image-20231029195534194"></p>
<ul>
<li>如果 <code>nums1</code> 中有 <code>k</code> 个 <code>0</code>，那么它的和在替换后必须要增加至少 <code>k</code></li>
<li>如果 <code>nums1</code> 中至少有一个 <code>0</code>，那么它在替换后的和可以等于任意大于 <code>sum(nums1)</code> 的值</li>
<li><code>nums2</code> 同理</li>
</ul>
<p>函数的返回类型为 <code>long</code>；数组长度最大为 $10^5$，元素最大为 $10^6$，数组和最大为 $10^{11}$，超过 32-bit int 的上限。这提醒我们中间步骤的计算结果需要用 <code>long</code> 存储。事实上，算法题应该都用 <code>long </code> 代替 <code>int</code>，避免整数溢出，并且开销也不大。</p>
<p>重点在于判断无法相等的条件，在这上面的失误造成了 3 个 WA：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">minSum</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">sum1</span> <span class="operator">=</span> Arrays.stream(nums1).mapToLong(i -&gt; i).sum();</span><br><span class="line">        <span class="type">long</span> <span class="variable">sum2</span> <span class="operator">=</span> Arrays.stream(nums2).mapToLong(i -&gt; i).sum();</span><br><span class="line">        <span class="type">long</span> <span class="variable">c1</span> <span class="operator">=</span> Arrays.stream(nums1).filter(i -&gt; i == <span class="number">0</span>).count();</span><br><span class="line">        <span class="type">long</span> <span class="variable">c2</span> <span class="operator">=</span> Arrays.stream(nums2).filter(i -&gt; i == <span class="number">0</span>).count();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断无法相等的情况</span></span><br><span class="line">        <span class="keyword">if</span> (sum1 &gt; sum2) &#123;</span><br><span class="line">            <span class="comment">// sum2 无法增加</span></span><br><span class="line">            <span class="keyword">if</span> (c2 == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// sum1 无法增加，sum2 有 c2 个 0，至少会增加 c2</span></span><br><span class="line">            <span class="keyword">if</span> (c1 == <span class="number">0</span> &amp;&amp; c2 + sum2 &gt; sum1) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum1 == sum2) &#123;</span><br><span class="line">            <span class="comment">// sum1 或 sum2 一方必须增加，但另一方不会变</span></span><br><span class="line">            <span class="keyword">if</span> (c1 == <span class="number">0</span> &amp;&amp; c2 != <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (c1 != <span class="number">0</span> &amp;&amp; c2 == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 和 sum1 &gt; sum2 的代码逻辑一致</span></span><br><span class="line">            <span class="keyword">if</span> (c1 == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (c2 == <span class="number">0</span> &amp;&amp; c1 + sum1 &gt; sum2) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(sum1 + c1, sum2 + c2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三、使数组变美的最小增量运算数">三、<a href="https://leetcode.cn/problems/minimum-increment-operations-to-make-array-beautiful/">使数组变美的最小增量运算数</a></h1>
<p><img src="./MDImgs/leetcode-369-weekly-contest-summary/image-20231029195556639.png" alt="image-20231029195556639"></p>
<p><img src="./MDImgs/leetcode-369-weekly-contest-summary/image-20231029195611424.png" alt="image-20231029195611424"></p>
<p><img src="./MDImgs/leetcode-369-weekly-contest-summary/image-20231029195617587.png" alt="image-20231029195617587"></p>
<blockquote>
<p>如果数组中任何长度 <strong>大于或等于 3</strong> 的子数组，其 <strong>最大</strong> 元素都大于或等于 <code>k</code> ，则认为数组是一个 <strong>美丽数组</strong> 。</p>
</blockquote>
<p>上述条件等价于 <strong>每个长度为 3 的子数组</strong> 中的最大元素都 $\ge k$</p>
<p>很明显，我们应该尽量地使每 3 个连续元素中，有一个元素 $\ge k$。但是应该使哪些元素增加到 $k$ 呢？不清楚，那就用 DP —— 局部暴力解</p>
<p>1️⃣DP定义：<code>dp[i]</code>：使得 <strong><code>nums[0:i]</code></strong> 为美丽数组，并且 <strong><code>nums[i]</code></strong> $\ge k$ 的<strong>最小</strong>递增运算数。—— 这里有 3 个加粗的重点</p>
<p><code>nums[i]</code> $\ge k$，那么 <code>nums[i - 2 : i]</code> 这个长度为 3 的子数组肯定能被覆盖，满足美丽数组的条件。这一覆盖同时表明，我们至少需要保证<code>nums[0:(i-3)]</code> 是美丽数组，才能使得 <code>nums[0:i]</code> 成为美丽数组。<code>dp[i - 3]</code>、<code>dp[i - 2]</code>、<code>dp[i - 1]</code> 的结果都可以满足这一点，取最小值值即可：</p>
<p>2️⃣递归式：$dp[i] = \max\set{0,k-nums[i]} + \min\set{dp[i - 1], dp[i - 2], dp[i - 3]}$</p>
<p>3️⃣答案：<code>dp[n - 3]</code>、<code>dp[n - 2]</code> 和 <code>dp[n - 1]</code> 按照定义都可以使 <code>nums</code> 成为美丽数组，取三者最小值即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">minIncrementOperations</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">long</span>[] dp = <span class="keyword">new</span> <span class="title class_">long</span>[n];</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        Arrays.fill(dp, Long.MAX_VALUE);</span><br><span class="line">        <span class="comment">// n &gt;= 3 保证了初始条件不需要根据 n 判断元素是否存在</span></span><br><span class="line">        dp[<span class="number">0</span>] = Math.max(<span class="number">0</span>, k - nums[<span class="number">0</span>]);</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(<span class="number">0</span>, k - nums[<span class="number">1</span>]);</span><br><span class="line">        dp[<span class="number">2</span>] = Math.max(<span class="number">0</span>, k - nums[<span class="number">2</span>]);</span><br><span class="line">        <span class="comment">// recursively</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">v</span> <span class="operator">=</span> Math.max(<span class="number">0</span>, k - nums[i]);</span><br><span class="line">            dp[i] = Math.min(dp[i], dp[i - <span class="number">1</span>] + v);</span><br><span class="line">            dp[i] = Math.min(dp[i], dp[i - <span class="number">2</span>] + v);</span><br><span class="line">            dp[i] = Math.min(dp[i], dp[i - <span class="number">3</span>] + v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// answer</span></span><br><span class="line">        <span class="keyword">return</span> Math.min(dp[n - <span class="number">1</span>], Math.min(dp[n - <span class="number">2</span>], dp[n - <span class="number">3</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="四、收集所有金币可获得的最大积分">四、<a href="https://leetcode.cn/problems/maximum-points-after-collecting-coins-from-all-nodes/">收集所有金币可获得的最大积分</a></h1>
<p><img src="./MDImgs/leetcode-369-weekly-contest-summary/image-20231029195640792.png" alt="image-20231029195640792"></p>
<p><img src="./MDImgs/leetcode-369-weekly-contest-summary/image-20231029195650693.png" alt="image-20231029195650693"></p>
<p><img src="./MDImgs/leetcode-369-weekly-contest-summary/image-20231029195700814.png" alt="image-20231029195700814"></p>
<p>1️⃣建树。其实是建图，只是我们要从节点 0 开始 dfs，模拟树遍历的过程</p>
<p>2️⃣收集金币的两个方案（题目故意写得复杂，需要化简）：</p>
<ul>
<li>方案 1：当前收集到的金币加上 <code>coins[i] - k</code> （无论正负）</li>
<li>方案 2：<code>floor(coins[i] / 2)</code> 就是整数除法，需要用位运算优化，即 <code>coins[i] &gt;&gt; 1</code>。位运算还有一个好处，假设当前节点有 $k$ 个祖先节点选择了方案 2，那么该节点的金币数就是 <code>coins[i] &gt;&gt; k</code>，免去了计算和除以 $2^k$ 的开销。</li>
</ul>
<p>根据这两个方案，我们可以写出一个前序遍历的递归函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前序遍历，收集金币</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 子树的根节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> half 子树的祖先节点选择过多少次方案 2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 该子树能够收集的最大金币数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="title function_">recur</span><span class="params">(Node root, <span class="type">long</span> half)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// node 是图中的节点，遍历需要 visited 数组辅助</span></span><br><span class="line">    <span class="comment">// 前序遍历本质上是 dfs</span></span><br><span class="line">    visited[root.index] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 方案一</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">res1</span> <span class="operator">=</span> (root.val &gt;&gt; half) - k;</span><br><span class="line">    <span class="keyword">for</span> (Node child : root.children) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[child.index]) <span class="keyword">continue</span>;</span><br><span class="line">        res1 += recur(child, half);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方案二</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">res2</span> <span class="operator">=</span> (root.val &gt;&gt; (<span class="number">1</span> + half));</span><br><span class="line">    <span class="keyword">for</span> (Node child : root.children) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[child.index]) <span class="keyword">continue</span>;</span><br><span class="line">        res2 += recur(child, half + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    visited[root.index] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.max(res1, res2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这一步为止，我在比赛中都写了出来，但还是超时了。之后，我又想到了如下的优化思路：</p>
<p>3️⃣ $\forall i, coins[i] \le 10^4$ ，并且 $\log_2(10^4) \approx 13.8$ ，因此，只要当前子树的祖先节点选择了至少 14 次方案 2，该子树中的所有节点的金币数都会不断减半至 0</p>
<p>这相当于一个剪枝，在 <code>recur</code> 函数开始处判断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (half &gt;= <span class="number">14</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>4️⃣说到递归，就想到分治算法范式，又会联想到 DP 算法范式。两者的区别是什么？—— DP 会复用子问题的结果，因此效率更高。</p>
<p>尽管遍历树的过程没法写成迭代，但我们可以用 map 来缓存子问题的结果：key 是 <code>(nodes[i], half)</code>，value 是收集到的金币数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;Node, HashMap&lt;Long, Long&gt;&gt; dpMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="title function_">recur</span><span class="params">(Node root, <span class="type">long</span> half)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 查询缓存，查到就直接返回</span></span><br><span class="line">    HashMap&lt;Long, Long&gt; mp = dpMap.get(root);</span><br><span class="line">    <span class="keyword">if</span> (mp != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">ans</span> <span class="operator">=</span> mp.get(half);</span><br><span class="line">        <span class="keyword">if</span> (ans != <span class="literal">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方案 1 和方案 2 的代码......</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入缓存</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> Math.max(res1, res2);</span><br><span class="line">    dpMap.putIfAbsent(root, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;());</span><br><span class="line">    dpMap.get(root).put(half, ans);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加上了这两步优化，成功 AC 了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        List&lt;Node&gt; children = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> val, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">            <span class="built_in">this</span>.index = index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> k;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[] visited;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumPoints</span><span class="params">(<span class="type">int</span>[][] edges, <span class="type">int</span>[] coins, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> coins.length;</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        Node[] nodes = IntStream.range(<span class="number">0</span>, n).mapToObj(i -&gt; <span class="keyword">new</span> <span class="title class_">Node</span>(coins[i], i)).toArray(Node[]::<span class="keyword">new</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] e : edges) &#123;</span><br><span class="line">            nodes[e[<span class="number">0</span>]].children.add(nodes[e[<span class="number">1</span>]]);</span><br><span class="line">            nodes[e[<span class="number">1</span>]].children.add(nodes[e[<span class="number">0</span>]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) recur(nodes[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归结果缓存，通过缓存将分治算法晋升为DP算法，提升效率</span></span><br><span class="line"><span class="comment">     * &lt;node, &lt;half, result&gt;&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;Node, HashMap&lt;Long, Long&gt;&gt; dpMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前序遍历，收集金币</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 子树的根节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> half 子树的祖先节点选择过多少次方案 2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 该子树能够收集的最大金币数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">recur</span><span class="params">(Node root, <span class="type">long</span> half)</span> &#123;</span><br><span class="line">        <span class="comment">// coins[i] &lt;= 10^4 -&gt; log_2 (10^4) &lt; 14</span></span><br><span class="line">        <span class="keyword">if</span> (half &gt;= <span class="number">14</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 查询缓存，查到就直接返回</span></span><br><span class="line">        HashMap&lt;Long, Long&gt; mp = dpMap.get(root);</span><br><span class="line">        <span class="keyword">if</span> (mp != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">ans</span> <span class="operator">=</span> mp.get(half);</span><br><span class="line">            <span class="keyword">if</span> (ans != <span class="literal">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// node 是图中的节点，遍历需要 visited 数组辅助</span></span><br><span class="line">        <span class="comment">// 前序遍历本质上是 dfs</span></span><br><span class="line">        visited[root.index] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 方案一</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">res1</span> <span class="operator">=</span> (root.val &gt;&gt; half) - k;</span><br><span class="line">        <span class="keyword">for</span> (Node child : root.children) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[child.index]) <span class="keyword">continue</span>;</span><br><span class="line">            res1 += recur(child, half);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方案二</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">res2</span> <span class="operator">=</span> (root.val &gt;&gt; (<span class="number">1</span> + half));</span><br><span class="line">        <span class="keyword">for</span> (Node child : root.children) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[child.index]) <span class="keyword">continue</span>;</span><br><span class="line">            res2 += recur(child, half + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        visited[root.index] = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 插入缓存</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> Math.max(res1, res2);</span><br><span class="line">        dpMap.putIfAbsent(root, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;());</span><br><span class="line">        dpMap.get(root).put(half, ans);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>动态规划</tag>
        <tag>树</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 370 周赛总结</title>
    <url>/2023/11/05/leetcode-370-weekly-contest-summary/</url>
    <content><![CDATA[<h1 id="概要">概要</h1>
<blockquote>
<p><a href="https://leetcode.cn/contest/weekly-contest-370/">力扣第 370 场周赛</a></p>
</blockquote>
<blockquote>
<p>本文只是周赛的总结，我不准备详细地讨论每一道题，有些题只会给出大致思路。重点还是在于自己的总结、反思和提高。</p>
</blockquote>
<p>23 分钟 AC 前三题，使得排名在三百左右 —— 典型的比手速策略。做题情况简要描述：</p>
<ul>
<li>第一题：送分题，但是有点卡住了，花了 5 分钟😒；</li>
<li>第二题：背景和第一题一样，同样是送分题，做得反而更快😋；</li>
<li>第三题：一道符合难度的中等题，需要稍微想一下，15 分钟做出来，不错😋；</li>
<li>第四题：没做出来。如果数据规模小的话是一道简单 dp，但没有优化思路 😒；</li>
</ul>
<span id="more"></span>
<h1 id="一、找到冠军-I">一、<a href="https://leetcode.cn/problems/find-champion-i/">找到冠军 I</a></h1>
<p><img src="./MDImgs/leetcode-370-weekly-contest-summary/image-20231105132950645.png" alt="image-20231105132950645"></p>
<p><img src="./MDImgs/leetcode-370-weekly-contest-summary/image-20231105132958733.png" alt="image-20231105132958733"></p>
<p>“如果不存在某支强于 <code>a</code> 队的队伍，则认为 <code>a</code> 队将会是 <strong>冠军</strong> ”，因此使用 <code>count[i]</code> 表示比 <code>i</code> 强的队伍数量。使得 $count[i] = 0$ 的 $i$ 即为答案</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findChampion</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == j) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) count[j]++;</span><br><span class="line">                <span class="keyword">else</span> count[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count[i] == <span class="number">0</span>) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二、找到冠军-II">二、<a href="https://leetcode.cn/problems/find-champion-ii/">找到冠军 II</a></h1>
<p><img src="./MDImgs/leetcode-370-weekly-contest-summary/image-20231105133352267.png" alt="image-20231105133352267"></p>
<p><img src="./MDImgs/leetcode-370-weekly-contest-summary/image-20231105133528772.png" alt="image-20231105133528772"></p>
<p><img src="./MDImgs/leetcode-370-weekly-contest-summary/image-20231105133540889.png" alt="image-20231105133540889"></p>
<p>用有向边表示谁比谁强，明显比第一题好理解。边 $(a,b)$ 表示 $a$ 比 $b$ 强，因此那些最强的队伍的入度为 $0$。统计入度即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findChampion</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] inDeg = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="comment">// 统计入度</span></span><br><span class="line">        Arrays.stream(edges).forEach(e -&gt; inDeg[e[<span class="number">1</span>]]++);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> Arrays.stream(inDeg).filter(i -&gt; i == <span class="number">0</span>).count();</span><br><span class="line">        <span class="comment">// 非唯一</span></span><br><span class="line">        <span class="keyword">if</span> (count != <span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inDeg[i] == <span class="number">0</span>) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三、在树上执行操作以后得到的最大分数">三、<a href="https://leetcode.cn/problems/maximum-score-after-applying-operations-on-a-tree/">在树上执行操作以后得到的最大分数</a></h1>
<p><img src="./MDImgs/leetcode-370-weekly-contest-summary/image-20231105134014234.png" alt="image-20231105134014234"></p>
<p><img src="./MDImgs/leetcode-370-weekly-contest-summary/image-20231105134359269.png" alt="image-20231105134359269"></p>
<p><img src="./MDImgs/leetcode-370-weekly-contest-summary/image-20231105134415086.png" alt="image-20231105134415086"></p>
<p>$\forall i, values[i] \ge 1$，并且“从根节点出发，到任意叶子节点经过的路径上的节点值之和都不等于 0”。因此，我们在执行操作时，<strong>每条从根节点到叶节点的路径上，都要留一个节点不去操作</strong>。（多条路径可能共用一个不操作的节点）</p>
<p>令图中所有节点的集合是 $V$，我们<strong>不操作</strong>的节点的集合为 $U$，则“对这棵树执行任意次操作，但要求执行完所有操作以后树是 <strong>健康的</strong> ”，得到的分数为 $\sum\limits_{v\in V} v - \sum\limits_{u\in U}u$。$\sum\limits_{v\in V} v $ 即为 <code>sum(values)</code>，因此，为了使分数最大，我们不操作的节点之和 $\sum\limits_{u\in U}u$ 应该尽可能地小。那么，应该不操作哪些节点呢？</p>
<p>对于树的任意一棵子树，比如下图：</p>
<p><img src="./MDImgs/leetcode-370-weekly-contest-summary/image-20231105135510005.png" alt="image-20231105135510005"></p>
<p>假设我们不操作根节点 0，那么剩余的节点都可以操作；假设我们操作了根节点 0，那么剩余的节点中存在不能操作的节点。这里的剩余节点可能是叶节点，也可能是多棵子树，无论是什么，都不影响该结论。</p>
<p>那么什么时候操作根节点？定义一棵以 $u$ 为根节点的<strong>健康的</strong>子树中<strong>不操作</strong>的节点的<strong>最小和</strong>为 $res(u)$，则 $\forall x, x$ 是 $u$ 的子节点, $res(u) = \min\set{values[u], \sum\limits_x res(x)}$</p>
<p>该递归式的含义是：</p>
<ul>
<li>要么不操作根节点 $u$，此时这棵树是健康的，剩余的所有子节点都可以操作；</li>
<li>要么操作根节点 $u$，但是 $u$ 的所有子树都需要保证自己是健康的；</li>
<li>根据定义，我们要得到<strong>最小和</strong>，因此取两者情况的较小值；</li>
</ul>
<p>对于上述例子，$res(1) = 2,res(2) = 2,res(3) = 5$</p>
<p>$values[0] = 5 &lt; \sum\limits_{x\in\set{1,2,3}}res(x) = 9$，因此不操作根节点 $0$，而操作其所有子树中的节点。</p>
<p>有了 $res(u)$ 的递推式，上述 $\sum\limits_{u\in U}u$ 的值就是 $res(0)$，因此，最大分数是 <code>sum(values) - res(0)</code></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> val, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">            <span class="built_in">this</span>.index = index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Node&gt; children = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">maximumScoreAfterOperations</span><span class="params">(<span class="type">int</span>[][] edges, <span class="type">int</span>[] values)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> values.length;</span><br><span class="line">        <span class="comment">// 建树，实际上是建图</span></span><br><span class="line">        Node[] nodes = IntStream.range(<span class="number">0</span>, n).mapToObj(i -&gt; <span class="keyword">new</span> <span class="title class_">Node</span>(values[i], i)).toArray(Node[]::<span class="keyword">new</span>);</span><br><span class="line">        Arrays.stream(edges).forEach(e -&gt; &#123;</span><br><span class="line">            nodes[e[<span class="number">0</span>]].children.add(nodes[e[<span class="number">1</span>]]);</span><br><span class="line">            nodes[e[<span class="number">1</span>]].children.add(nodes[e[<span class="number">0</span>]]);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        visited[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// values[i] &lt;= 10^9，注意 mapToLong</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(values).mapToLong(i -&gt; i).sum();</span><br><span class="line">        <span class="type">long</span> <span class="variable">min</span> <span class="operator">=</span> dfs(nodes[<span class="number">0</span>], visited);</span><br><span class="line">        <span class="keyword">return</span> sum - min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 根节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> res(root)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">dfs</span><span class="params">(Node root, <span class="type">boolean</span>[] visited)</span> &#123;</span><br><span class="line">        <span class="comment">// count # visited neighbors</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// min = sum(res(children))</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node child : root.children) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[child.index]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            visited[child.index] = <span class="literal">true</span>;</span><br><span class="line">            min += dfs(child, visited);</span><br><span class="line">            visited[child.index] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时该节点为叶节点，直接返回它的 val</span></span><br><span class="line">        <span class="keyword">if</span> (count == root.children.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(root.val, min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="四、平衡子序列的最大和">四、<a href="https://leetcode.cn/problems/maximum-balanced-subsequence-sum/">平衡子序列的最大和</a></h1>
<p><img src="./MDImgs/leetcode-370-weekly-contest-summary/image-20231105162645031.png" alt="image-20231105162645031"></p>
<p><img src="./MDImgs/leetcode-370-weekly-contest-summary/image-20231105162654150.png" alt="image-20231105162654150"></p>
<p>重新读题：平衡子序列中连续的两个元素 <code>nums[i]</code> 和 <code>nums[j]</code> 需要满足 $i &lt; j$ 且 $nums[j] - nums[i] \ge j -i$</p>
<p>对上述不等式移项，得到 $nums[j] - j \ge nums[i] - i$ —— 左右两边的各项都只关于其下标，而与其他条件无关</p>
<p>因此，这道题类似于最长递增子序列，用 DP 解决：</p>
<p>DP 定义：<code>dp[j]</code> 表示以 <code>nums[j]</code> <strong>结尾</strong>的 <strong>平衡</strong> 子序列里面的 <strong>最大元素和</strong></p>
<p>递推式：$dp[j] = nums[j] + \max\set{dp[i] | (i &lt; j) ∧ (nums[j] - j \ge nums[i] - i)}$</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">maxBalancedSubsequenceSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> Long.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp[i]： 以 nums[i] 结尾的子序列的最大元素和</span></span><br><span class="line">        <span class="type">long</span>[] dp = <span class="keyword">new</span> <span class="title class_">long</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            dp[j] = nums[j];</span><br><span class="line">            <span class="type">long</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; j; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] - j &gt;= nums[i] - i) &#123;</span><br><span class="line">                    max = Math.max(max, dp[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[j] += max;</span><br><span class="line"></span><br><span class="line">            ans = Math.max(ans, dp[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题在于，这么做显然是 $O(n^2)$ 的时间复杂度，比赛时我也没想出如何优化。</p>
<p>我准备在下一篇博客中详细描述如何做出这道题（基于大佬的题解），现在先让我去学习相关知识。</p>
]]></content>
      <categories>
        <category>算法题</category>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>动态规划</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>ntfy 安装和使用</title>
    <url>/2024/10/10/ntfy-install-and-usage/</url>
    <content><![CDATA[<h1 id="序言">序言</h1>
<p>在<a href="/2024/10/02/ChangeDetection-install-and-usage/">上一篇文章</a>中，我使用 QQ 邮箱作为 ChangeDetection 的通知服务。当时是为了快速上手 ChangeDetection，显然这是没有必要的，因为存在不少开源的通知系统，比如 <a href="https://github.com/binwiederhier/ntfy">ntfy</a>。本文会介绍 ntfy 的安装和使用，这本身没什么难度。但是，在与 ChangeDetection 整合时，我却遇到了不少困难。本文也将包括这些问题的解决方案。</p>
<span id="more"></span>
<h1 id="安装和配置">安装和配置</h1>
<h2 id="Docker-compose">Docker compose</h2>
<p>ntfy Web UI 使用的 Notifications API 要求 HTTPS，因此要启动一个 Nginx 容器。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.24</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nginx-ntfy</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/opt/docker/nginx_conf/nginx-ntfy.conf:/etc/nginx/nginx.conf:ro</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/opt/docker/nginx_ssl:/etc/nginx/ssl/:ro</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">40043</span><span class="string">:443</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ntfy</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">ntfy:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">binwiederhier/ntfy:v2.11.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">ntfy</span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">serve</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ntfy_data:/var/cache/ntfy</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ntfy_config:/etc/ntfy</span></span><br><span class="line">    <span class="comment"># ports:</span></span><br><span class="line">    <span class="comment">#   - 50080:80</span></span><br><span class="line">    <span class="attr">healthcheck:</span> <span class="comment"># optional: remember to adapt the host:port to your environment</span></span><br><span class="line">        <span class="attr">test:</span> [<span class="string">&quot;CMD-SHELL&quot;</span>, <span class="string">&quot;wget -q --tries=1 http://localhost:80/v1/health -O - | grep -Eo &#x27;\&quot;healthy\&quot;\\s*:\\s*true&#x27; || exit 1&quot;</span>]</span><br><span class="line">        <span class="attr">interval:</span> <span class="string">60s</span></span><br><span class="line">        <span class="attr">timeout:</span> <span class="string">10s</span></span><br><span class="line">        <span class="attr">retries:</span> <span class="number">3</span></span><br><span class="line">        <span class="attr">start_period:</span> <span class="string">40s</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">ntfy_data:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">ntfy_config:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="ntfy-配置">ntfy 配置</h2>
<p>手动创建配置文件：<code>/etc/ntfy/server.yml</code>。具体配置项见<a href="https://github.com/binwiederhier/ntfy/blob/main/server/server.yml">官网提供的模板</a>，我配置了如下选项：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">base-url:</span> <span class="string">&quot;https://主机IP:40043&quot;</span></span><br><span class="line"><span class="attr">cache-file:</span> <span class="string">&quot;/var/cache/ntfy/cache.db&quot;</span></span><br><span class="line"><span class="attr">cache-duration:</span> <span class="string">&quot;24h&quot;</span></span><br><span class="line"><span class="attr">auth-file:</span> <span class="string">&quot;/var/cache/ntfy/user.db&quot;</span></span><br><span class="line"><span class="attr">auth-default-access:</span> <span class="string">&quot;deny-all&quot;</span></span><br><span class="line"><span class="attr">behind-proxy:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>ntfy 默认情况下不持久化消息，只是实时地转发消息。因此，以下两种情况都会导致消息丢失：</p>
<ul>
<li>ntfy 始终在线，客户端遇到网络故障，重新连接后无法收到断网期间他人发送的消息；</li>
<li>客户端始终在线，ntfy 收到消息、来不及转发就下线了，重启后，之前没有转发的消息丢失；</li>
</ul>
<p>使用了 <code>cache-file</code> 就相当于变成了一个消息队列，弥补了上述缺点。消息缓存的时间为 <code>cache-duration</code>。</p>
<hr>
<p>ntfy 还有发送图片、附件等多种功能，但我没有这些需求，就不配置了。</p>
<h2 id="Nginx-配置">Nginx 配置</h2>
<blockquote>
<p>Nginx 和 SSL 证书的配置见<a href="/2024/01/31/Docker-Nginx-SSL-Local-Network/">我之前的文章</a>。</p>
</blockquote>
<p>官网提供了 <a href="https://docs.ntfy.sh/config/#nginxapache2caddy">Nginx 模板</a>，我的配置如下：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">user</span> nginx;</span><br><span class="line"><span class="attribute">worker_processes</span> auto;</span><br><span class="line"></span><br><span class="line"><span class="attribute">error_log</span> /var/log/nginx/<span class="literal">error</span>.log <span class="literal">notice</span>;</span><br><span class="line"><span class="attribute">pid</span> /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">	<span class="attribute">worker_connections</span> <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">	<span class="attribute">include</span> /etc/nginx/mime.types;</span><br><span class="line">	<span class="attribute">default_type</span> application/octet-stream;</span><br><span class="line"></span><br><span class="line">	<span class="attribute">log_format</span> main <span class="string">&#x27;<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] &quot;<span class="variable">$request</span>&quot; &#x27;</span></span><br><span class="line">	<span class="string">&#x27;<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> &quot;<span class="variable">$http_referer</span>&quot; &#x27;</span></span><br><span class="line">	<span class="string">&#x27;&quot;<span class="variable">$http_user_agent</span>&quot; &quot;<span class="variable">$http_x_forwarded_for</span>&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="attribute">access_log</span> /var/log/nginx/access.log main;</span><br><span class="line"></span><br><span class="line">	<span class="attribute">sendfile</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">	<span class="attribute">keepalive_timeout</span> <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">	<span class="section">server</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="attribute">listen</span> <span class="number">443</span> default_server ssl http2;</span><br><span class="line">		<span class="attribute">listen</span> [::]:<span class="number">443</span> ssl http2;</span><br><span class="line"></span><br><span class="line">		<span class="attribute">ssl_certificate</span> /etc/nginx/ssl/nginx_server.crt;</span><br><span class="line">		<span class="attribute">ssl_certificate_key</span> /etc/nginx/ssl/nginx_server.key;</span><br><span class="line"></span><br><span class="line">		<span class="section">location</span> / &#123;</span><br><span class="line"></span><br><span class="line">			<span class="attribute">proxy_pass</span> http://ntfy:80;</span><br><span class="line">			<span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">			<span class="attribute">proxy_buffering</span> <span class="literal">off</span>;</span><br><span class="line">			<span class="attribute">proxy_request_buffering</span> <span class="literal">off</span>;</span><br><span class="line">			<span class="attribute">proxy_redirect</span> <span class="literal">off</span>;</span><br><span class="line"></span><br><span class="line">			<span class="attribute">proxy_set_header</span> Host <span class="variable">$http_host</span>;</span><br><span class="line">			<span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">			<span class="attribute">proxy_set_header</span> Connection <span class="string">&quot;upgrade&quot;</span>;</span><br><span class="line">			<span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line"></span><br><span class="line">			<span class="attribute">proxy_connect_timeout</span> <span class="number">3m</span>;</span><br><span class="line">			<span class="attribute">proxy_send_timeout</span> <span class="number">3m</span>;</span><br><span class="line">			<span class="attribute">proxy_read_timeout</span> <span class="number">3m</span>;</span><br><span class="line"></span><br><span class="line">			<span class="attribute">client_max_body_size</span> <span class="number">0</span>; <span class="comment"># Stream request body to backend</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="虚拟机-NAT-与主机防火墙">虚拟机 NAT 与主机防火墙</h2>
<p>我的主机是 Win10，使用 VMware 运行一个 Linux 虚拟机，该虚拟机里面运行 Docker。因此要配置虚拟机 NAT，并开放主机防火墙。参考<a href="/2024/01/25/LANraragi-manga-server/#%E8%AE%BE%E5%A4%87%E5%85%B1%E4%BA%AB">这篇文章</a>。</p>
<p>我开放了主机的 40043 端口，用于局域网共享。</p>
<h1 id="使用">使用</h1>
<p>Hello World 的案例见<a href="https://docs.ntfy.sh/">官网</a>，这里就不多介绍了。</p>
<h2 id="访问控制">访问控制</h2>
<p>读者可以注意到，我的配置文件中包括：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">auth-default-access:</span> <span class="string">&quot;deny-all&quot;</span></span><br></pre></td></tr></table></figure>
<p>默认情况下，连接到 ntfy 的客户端没有读写任何主题的权限。这是最安全的配置，不过管理起来也最麻烦。</p>
<p>添加一个 <code>test</code> 主题，允许任何人读写：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/ <span class="comment"># ntfy access everyone test rw</span></span><br><span class="line">granted read-write access to topic <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">user * (role: anonymous, tier: none)</span><br><span class="line">- read-write access to topic <span class="built_in">test</span></span><br><span class="line">- no access to any (other) topics (server config</span><br></pre></td></tr></table></figure>
<h1 id="与-ChangeDetection-整合">与 ChangeDetection 整合</h1>
<h2 id="访问控制-2">访问控制</h2>
<p>对于 <code>ChangeDetection</code> 主题，添加一个写者、一个读者。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/ <span class="comment"># ntfy access</span></span><br><span class="line">user ChangeDetectionPublisher (role: user, tier: none)</span><br><span class="line">- write-only access to topic ChangeDetection</span><br><span class="line">user homeDevice (role: user, tier: none)</span><br><span class="line">- read-only access to topic ChangeDetection</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我发现记住这些用户的密码也是一件难事。对于写者，我使用的是随机生成的长密码，因此这个用户就相当于是一次性的，只用于一个主题的写操作。如果密码忘记了，再创建一个新用户即可。而对于读者，使用的是方便记忆的短密码（有被破解的风险）。</p>
</blockquote>
<h2 id="Notification-URL">Notification URL</h2>
<p>参考<a href="https://docs.ntfy.sh/examples/#changedetectionio">官方文档</a>，ChangeDetection 的通知 URL 配置为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ntfys://ChangeDetectionPublisher:用户密码@虚拟机IP:40043/ChangeDetection</span><br></pre></td></tr></table></figure>
<ul>
<li>我使用的是 HTTPS，因此开头是 <code>ntfys</code>；如果只是 HTTP，用 <code>ntfy</code> 即可；</li>
<li>无论一个容器在哪个 Docker 网络中，它始终能正确识别 host 的 IP（在这里是虚拟机 IP），不管这个 IP 属于哪个网络（e.g. Docker 网络、VMware 适配器网络）；</li>
</ul>
<h2 id="容器-CA-证书配置">容器 CA 证书配置</h2>
<p>如果在上一步配置完 ChangeDetection 后点击测试，会出现以下报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(Caused by SSLError(SSLCertVerificationError(1, &#x27;[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: unable to get local issuer certificate (_ssl.c:1006)&#x27;)))</span><br></pre></td></tr></table></figure>
<p>这个错误是显然的，因为 Nginx 的 SSL 证书是自签名的，而 ChangeDetection 容器并没有信任我自己创建的 CA 证书。</p>
<h3 id="方案-1：让容器信任证书">方案 1：让容器信任证书</h3>
<p>先把自签名证书拷贝到容器里：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">cp</span> /path/to/your/certificate.crt &lt;container_name&gt;:/usr/local/share/ca-certificates/</span><br></pre></td></tr></table></figure>
<p>然后进入容器，更新 CA 证书：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">update-ca-certificates</span><br></pre></td></tr></table></figure>
<p>最后重启容器。</p>
<p>这个方案对于 <code>curl</code>、<code>wget</code> 等命令有效，但是对于 ChangeDetection 无效。因为 ChangeDetection 是用 Python 开发的。Python 并不使用 OS 的证书，而是使用 <code>certifi</code> 包中的证书。所以我们的着力点应该是让 Python 信任证书，而不是让容器信任证书。</p>
<h3 id="方案-2：使用-REQUESTS-CA-BUNDLE-环境变量">方案 2：使用 <code>REQUESTS_CA_BUNDLE</code> 环境变量</h3>
<p>修改 ChangeDetection 的 Docker compose：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">changedetection:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">dgtlmoon/changedetection.io</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REQUESTS_CA_BUNDLE=/path/in/container/your_certificate.crt</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/path/to/certificate.crt:/path/in/container/your_certificate.crt</span></span><br></pre></td></tr></table></figure>
<p>这个方案对于 ChangeDetection 也是不正确的，因为设置环境变量会覆盖原有的一系列证书，导致 ChangeDetection 只信任 ntfy 的证书，而不信任因特网上的任何证书。ChangeDetection 显然需要访问因特网，这就造成了矛盾。</p>
<p>对于一些脚本，比如我之前写的<a href="/2024/02/17/jellyfin-original-filename/?highlight=requests_ca_bundle#%E6%88%91%E7%9A%84%E6%96%B9%E6%A1%88">『Jellyfin 显示原始文件名』</a>，使用这个环境变量还是很方便的。</p>
<h3 id="方案-3：将证书添加到-certifi-包中">方案 3：将证书添加到 <code>certifi</code> 包中</h3>
<p>进入容器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import certifi</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; certifi.where()</span></span><br><span class="line">/path/to/the/certifi/cacert.pem</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">exit</span>()</span></span><br><span class="line">cat /path/in/container/your_certificate.crt &gt;&gt; /path/to/the/certifi/cacert.pem</span><br></pre></td></tr></table></figure>
<p>然后重启容器。</p>
<p>这个方案是目前唯一可行的。</p>
<p>对于容器来说，就算 <code>certifi</code> 包弄坏了也无所谓，新建一个容器就行了；对于主机来说，新建一个 venv 或者 conda env 做这件事，不要把原有环境弄坏了。</p>
<hr>
<p>再次测试 ChangeDetection，现在一切正常了，整合成功😁。</p>
<h1 id="参考">参考</h1>
<ul>
<li><a href="https://docs.ntfy.sh/install/#docker">ntfy doc: Installation</a></li>
<li><a href="https://docs.ntfy.sh/config/">ntfy doc: Config</a></li>
<li>ChatGPT</li>
<li><a href="https://stackoverflow.com/a/70988519/23172420">How to get Python requests to trust a self signed SSL certificate?</a></li>
</ul>
]]></content>
      <categories>
        <category>tech</category>
        <category>NAS</category>
        <category>Docker</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>NAS</tag>
        <tag>Docker</tag>
        <tag>ChangeDetection</tag>
        <tag>Python</tag>
        <tag>ntfy</tag>
      </tags>
  </entry>
  <entry>
    <title>pip &amp; conda 常用指令</title>
    <url>/2024/01/14/pip-conda-Common-Commands/</url>
    <content><![CDATA[<h1 id="pip">pip</h1>
<ol>
<li>
<p>安装 <code>script-house</code>，版本为 <code>0.0.2</code></p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pip install script-house==0.0.2</span><br></pre></td></tr></table></figure>
<p>如果默认安装最新版，则不需要写 <code>==0.0.2</code></p>
<p>所有要安装的依赖也可以写在一行：</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pip install script-house==0.0.2 pydantic==2.5.3 pymongo==4.6.1</span><br></pre></td></tr></table></figure>
</li>
</ol>
<span id="more"></span>
<ol start="2">
<li>
<p>列出所有依赖</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pip list</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>以 <code>requirements.txt</code> 的格式列出当前依赖</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pip freeze</span><br></pre></td></tr></table></figure>
<p><code>pip freeze</code> 的结果是 <code>pip list</code> 的子集。<code>pip list</code> 通常还包括 <code>pip</code> 、<code>setuptools</code> 和 <code>wheel</code> 这些基础依赖；</p>
<p><code>pip freeze</code> 的目的是导出该项目的依赖，方便他人使用。而 <code>pip list</code> 仅仅只是展示。</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pip freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>从 <code>requirements.txt</code> 中安装所有依赖</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>删除某一依赖</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pip uninstall script-house</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>删除某些依赖</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pip uninstall -r req.txt -y</span><br></pre></td></tr></table></figure>
<p><code>-y</code> 表示自动确认删除</p>
<p>如何删除当前环境的所有依赖？</p>
 <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">pip freeze &gt; req</span><br><span class="line">pip uninstall <span class="literal">-r</span> req <span class="literal">-y</span></span><br><span class="line"><span class="built_in">del</span> req</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="conda">conda</h1>
<ol>
<li>
<p>在 Linux 安装好 conda，通常需要先执行  <code>conda init</code>，才能使用 conda 命令</p>
</li>
<li>
<p>列出所有环境</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">conda <span class="built_in">env</span> list</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>新建环境</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">conda create -n &lt;环境名&gt; python=3.8</span><br></pre></td></tr></table></figure>
<p>基本命令就是 <code>conda create -n &lt;环境名&gt;</code>，但通常要指定 python 版本。相比 venv，conda 环境会额外安装 OS 相关的一些基础依赖。</p>
</li>
<li>
<p>进入环境</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">conda activate &lt;环境名&gt;</span><br></pre></td></tr></table></figure>
<p>如果是 Windows，不需要写 <code>conda</code></p>
</li>
<li>
<p>退出环境</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">conda deactivate</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>删除环境</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">conda remove -n &lt;环境名&gt; --all</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查看基本信息</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">conda info</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>安装依赖</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">conda install pytorch==1.12.1 torchvision==0.13.1 torchaudio==0.12.1 -c pytorch -c conda-forge</span><br></pre></td></tr></table></figure>
<p>和 pip 类似，也是 <code>依赖==版本号</code>的形式 ；<code>-c</code> 参数是指定下载源（channel），因为默认 channel 经常会查找失败</p>
</li>
<li>
<p>从配置文件（通常叫 <code>environment.yml</code> ）中创建环境：</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">conda <span class="built_in">env</span> create -f environment.yml</span><br></pre></td></tr></table></figure>
<p>配置文件内容：</p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&lt;环境名&gt;</span></span><br><span class="line"><span class="attr">channels:</span> <span class="comment"># -c 参数，指定下载源</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">pytorch</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">conda-forge</span></span><br><span class="line"><span class="attr">dependencies:</span> <span class="comment"># dependencies 默认用 conda install</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">python=3.8</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">numpy</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">pandas</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">matplotlib</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">pip:</span> <span class="comment"># 下面的依赖用 pip install </span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">imageio</span></span><br></pre></td></tr></table></figure>
<p>根据经验，不建议通过这种方式安装，因为 channel 不一定靠谱</p>
</li>
<li>
<p>关闭自动进入 base 环境。如果开启，每个新建的 shell 都会自动进入 base 环境。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">conda config --<span class="built_in">set</span> auto_activate_base <span class="literal">false</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>tech</category>
        <category>cheat sheet</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>pip</tag>
        <tag>conda</tag>
      </tags>
  </entry>
  <entry>
    <title>Python AIOHTTP 基本使用</title>
    <url>/2024/03/29/python-aiohttp-use/</url>
    <content><![CDATA[<h1 id="序言">序言</h1>
<p>最近在用 Python 写爬虫来下载漫画（见<a href="/tags/LANraragi/">之前几篇介绍 LANraragi 的文章</a>）。一本漫画的网页通常是这样的：</p>
<img src="./MDImgs/python-aiohttp-use/image-20240329132644183.png" alt="image-20240329132644183" style="zoom: 33%;" />
<p>该网页上的所有数据可以用 BeautifulSoup 获得，而一个页面只需要一次通信。但是下载图片不一样，一张图片就需要一次通信，而且响应体往往很大。正如包子不会一个个地煮，图片也不用顺序地下载，否则太浪费时间了。</p>
<p>AIOHTTP 是一个异步 HTTP 客户端/服务端模块，很适合这一场景。通过异步编程，能够最大程度地榨取网络（和对方服务器）的性能。本文着眼于介绍 AIOHTTP 的基本使用和案例，不会详细阐述原理。</p>
<span id="more"></span>
<h1 id="原理">原理</h1>
<p>AIOHTTP 是基于 Python 协程机制的 HTTP 库。HTTP 不必多介绍了，而 Python 协程以 asyncio 模块为基础，使用 <code>async</code> 和 <code>await</code> 作为关键字，旨在提高 IO 密集型任务的效率。</p>
<p>使用协程就会涉及并发 —— 任务的同步以及数据的互斥 —— 这一点在写代码时需要注意。</p>
<h1 id="案例1：hello-world">案例1：hello world</h1>
<p>直接复制了官网的案例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> session.get(<span class="string">&#x27;http://python.org&#x27;</span>) <span class="keyword">as</span> response:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Status:&quot;</span>, response.status)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Content-type:&quot;</span>, response.headers[<span class="string">&#x27;content-type&#x27;</span>])</span><br><span class="line"></span><br><span class="line">            html = <span class="keyword">await</span> response.text()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Body:&quot;</span>, html[:<span class="number">15</span>], <span class="string">&quot;...&quot;</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<ul>
<li><code>aiohttp.ClientSession</code> 对象负责发出所有请求；</li>
<li>如果函数体有 <code>async</code> 或 <code>await</code> 关键字，则该函数必须是异步的，即使用 <code>async def</code> 定义；</li>
<li>对于一个异步函数：
<ul>
<li>如果在同步环境调用，需要使用 <code>asyncio.run(异步函数(参数))</code>；</li>
<li>如果在异步环境调用，需要使用 <code>await 异步函数(参数)</code>，比如上面的 <code>html = await response.text()</code></li>
</ul>
</li>
</ul>
<h1 id="案例2：ClientSession">案例2：<code>ClientSession</code></h1>
<p><code>aiohttp.ClientSession</code> 有自己的连接池，通常在整个程序中只创建一个实例，从而复用连接。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">url, session, headers=&#123;&#125;, cookies=&#123;&#125;</span>):</span><br><span class="line">    <span class="comment"># 设置 headers 和 cookies 的方式和 requests.get() 一样</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> session.get(url, headers=headers, cookies=cookies) <span class="keyword">as</span> response:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> response.text()</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        text = <span class="keyword">await</span> get(<span class="string">&quot;http://python.org&quot;</span>, session)</span><br><span class="line">        <span class="built_in">print</span>(text[:<span class="number">50</span>])</span><br><span class="line">        text = <span class="keyword">await</span> get(<span class="string">&quot;https://docs.aiohttp.org/en/stable/&quot;</span>, session)</span><br><span class="line">        <span class="built_in">print</span>(text[:<span class="number">50</span>])</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<h1 id="案例3：下载文件">案例3：下载文件</h1>
<p>如果要下载照片、视频这样的大文件，应该使用如下方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">download_image</span>(<span class="params">session: aiohttp.ClientSession, uri: <span class="built_in">str</span>, file_path: <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> session.get(uri) <span class="keyword">as</span> response:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                chunk = <span class="keyword">await</span> response.content.read(<span class="number">8192</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> chunk:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                file.write(chunk)</span><br></pre></td></tr></table></figure>
<h1 id="案例4：多任务执行">案例4：多任务执行</h1>
<blockquote>
<p>这个是 asyncio 的功能，而非 AIOHTTP 的</p>
</blockquote>
<p>假如我们要下载多张图片，可以这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    site = <span class="string">&#x27;https://gustaavv.github.io/MarkDownImages/&#x27;</span></span><br><span class="line">    images = [<span class="string">&#x27;image-20230722142231405.png&#x27;</span>, <span class="string">&#x27;image-20230722142307844.png&#x27;</span>]</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        <span class="keyword">for</span> im <span class="keyword">in</span> images:</span><br><span class="line">            <span class="keyword">await</span> download_image(session, site + im, im)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p>但是，下载仍然是顺序执行的，不是并发的。</p>
<p>正确的做法是使用 <code>asyncio.gather</code>，该函数可以并发地执行一系列任务。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    site = <span class="string">&#x27;https://gustaavv.github.io/MarkDownImages/&#x27;</span></span><br><span class="line">    images = [<span class="string">&#x27;image-20230722142231405.png&#x27;</span>, <span class="string">&#x27;image-20230722142307844.png&#x27;</span>]</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        tasks = [download_image(session, site + im, im) <span class="keyword">for</span> im <span class="keyword">in</span> images]</span><br><span class="line">        result_list = <span class="keyword">await</span> asyncio.gather(*tasks)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p><code>gather()</code> 的参数是对异步函数的调用，即 <code>gather(f1(), f2())</code>。这里 <code>gather(*[f1(), f2()])</code> 等价于 <code> gather(f1(), f2())</code></p>
<p><code>await</code> 使得所有下载任务都完成后，程序才会执行下一条语句。</p>
<h1 id="总结">总结</h1>
<p>在我的爬虫项目中，AIOHTTP 的使用比较简单，只实现了并发下载图片功能。而工作主要集中在解析 HTML 上。</p>
<p>在项目中，我使用了模板方法的设计模式：在父类中使用 AIOHTTP 实现了并发下载，而子类只需要实现 <code>parse_html()</code> 这个抽象函数就足够了。AIOHTTP 只在搭框架的时候用到了，之后再也不会涉及了。考虑到以后可能再次用到，我写了这篇博客，记录了 AIOHTTP 和 asyncio 的基本用法。</p>
<h1 id="参考">参考</h1>
<ul>
<li>ChatGPT</li>
<li><a href="https://docs.python.org/3/library/asyncio.html">Python doc: asyncio</a></li>
<li><a href="https://docs.aiohttp.org/en/stable/">AIOHTTP</a></li>
</ul>
]]></content>
      <categories>
        <category>tech</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>AIOHTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>致读者</title>
    <url>/3000/01/01/%E7%BD%AE%E9%A1%B6%E9%80%9A%E7%9F%A5/</url>
    <content><![CDATA[<ul>
<li>Visit the English site <a href="/en" onclick="jump()">here</a>, or click ‘Switch to English’ at the left sidebar.</li>
</ul>
<script>
    function jump() {
        window.location.href = "https://gustaavv.github.io/en?timestamp=" + (new Date()).getTime();
    }
</script>]]></content>
  </entry>
</search>
